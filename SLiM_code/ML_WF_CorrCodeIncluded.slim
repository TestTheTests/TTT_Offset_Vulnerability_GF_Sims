//
// Additive gentetic variance for each trait in each population and across metapopulation
// Phenotypic variance for each population and across metapopulation
// Genetic covariance b/w traits for each population and across all populations

initialize()
{
	//setSeed(1707249891095);
	defineConstant("MY_SEED", getSeed());
	defineConstant("C_num", 10);							// number of chromosomes
	defineConstant("C_lengths", rep(50000, C_num));	// lengths for each chromosome
	defineConstant("MU_base", 1e-7);						// base mutation rate overall
	defineConstant("MU", MU_base * 0.02);				// mut rate for QTNs specifically
	defineConstant("R", 1e-6);								// recombination rate
	defineConstant("N", 100);								// subpop size
	defineConstant("MIG", 0.001);							// migration rate between subpops
	defineConstant("BURNIN", 500);						// number of burning generations
	defineConstant("ENV_SHIFT", 1000);					// the generation in which the environment starts to shift
	defineConstant("METAPOP_SIDE", 10);					// x by x matrix of subpops
	defineConstant("RATE", 0.01);							// rate at which environment changes
	defineConstant("S", 0.1);								// selection coefficient for local fitness gradient
	defineConstant("SIGMA_K", 1.25);						// smaller is stronger stabilizing selection, // larger is weaker (wider) stabilizing selection
	defineConstant("SIGMA_STAT", 4.0);					// burn-in stabilizing selection function variance
	defineConstant("METAPOP_NPOPS", METAPOP_SIDE * METAPOP_SIDE);
	
	// set up spatially autocorrelated environmental variables
	xv = rep(seq(-1.0, 1.0, length=METAPOP_SIDE), METAPOP_SIDE);
	yv = repEach(seq(-1.0, 1.0, length=METAPOP_SIDE), METAPOP_SIDE);
	defineConstant("maxOpt0", max(xv));
	defineConstant("maxOpt1", max(yv));
	
	//yv = rep(seq(1.0, -1.0, length=METAPOP_SIDE), METAPOP_SIDE);
	defineConstant("OPTS_0", xv);
	defineConstant("OPTS_1", yv);
	
	//	initializeTreeSeq(simplificationInterval=500);	// infrequent for faster runtimes
	initializeTreeSeq();
	initializeMutationRate(MU);
	initializeSex("A"); //Set each population to contain two autosomal sexes that must reproduce to yield next generation
	
	//initializeMutationType("m1", 0.5, "f", 0.0); // Neutral
	initializeMutationType("m2", 0.5, "f", 0.0); // QTL mutations under selection across the environment
	m2.convertToSubstitution = F;
	
	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, sum(C_lengths[0:(C_num - 2)]));
	
	rates = c(rep(c(R, 0.5), C_num-1), R);
	ends = repEach(cumSum(C_lengths), 2);
	ends = ends[0:(length(ends) - 2)];
	ends = ends + c(rep(c(0,1), C_num-1), 0);
	initializeRecombinationRate(rates, ends);
	
	// QTL-related constants used below
	defineConstant("QTL_mu", c(0, 0));
	//	defineConstant("QTL_mu", 0);
	defineConstant("QTL_cov", 0);
	defineConstant("QTL_var", SIGMA_K);
	defineConstant("QTL_sigma", matrix(c(QTL_var, QTL_cov, QTL_cov, QTL_var), nrow=2));
	
	catn();
	catn("QTL DFE means: ");
	print(QTL_mu);
	catn();
	catn("QTL DFE variance-covariance matrix: ");
	print(QTL_sigma);
}
//METAPOP_SIDE by METAPOP_SIDE matrix of populations
function (void)setUpMigration(void)
{
	subpops = sim.subpopulations;
	for (x in 1:METAPOP_SIDE)
		for (y in 1:METAPOP_SIDE)
		{
			destID = (x - 1) + (y - 1) * METAPOP_SIDE + 1;
			destSubpop = subpops[destID - 1];
			if (x > 1) // Left to right
				destSubpop.setMigrationRates(destID - 1, MIG);
			if (x < METAPOP_SIDE) // Right to left
				destSubpop.setMigrationRates(destID + 1, MIG);
			if (y > 1) // Top to bottom
				destSubpop.setMigrationRates(destID - METAPOP_SIDE, MIG);
			if (y < METAPOP_SIDE) // Bottom to top
				destSubpop.setMigrationRates(destID + METAPOP_SIDE, MIG);
			destSubpop.setValue("opt0", OPTS_0[destID - 1]);
			destSubpop.setValue("opt1", OPTS_1[destID - 1]);
			
			xd = ((x - 1) / (METAPOP_SIDE - 1)) * 0.9 + 0.05;
			yd = ((y - 1) / (METAPOP_SIDE - 1)) * 0.9 + 0.05;
			
			destSubpop.setValue("xd", xd);
			destSubpop.setValue("yd", yd);
		
		}
}

function (void)outputMigration(string$ path)
{
	s = sim.subpopulations;
	m = matrix(rep(0.0, (size(s) + 1) * (size(s) + 1)), nrow=size(s) + 1, ncol=size(s) + 1);
	
	for (i in seqAlong(s))
	{
		s_i = s[i];
		s_i_mig = s_i.immigrantSubpopIDs;
		s_i_frac = s_i.immigrantSubpopFractions;
		
		for (j in seqAlong(s))
		{
			s_j = s[j];
			match = (s_i_mig == s_j.id);
			
			if (sum(match))
			{
				which_match = which(match);
				m[i+1, j+1] = s_i_frac[which_match];
			}
		}
	}
	
	contents = NULL;
	for (i in seqAlong(1:(size(s)+1)))
	{
		line = "[" + paste(m[i,], sep=",") + "],";
		contents = c(contents, line);
	}
	//	for (i in seqAlong(1:(size(s)+1)))
	//	{
	//		line = paste(m[i,], sep=",");
	//		if (i == 0)
	//			line = "[[" + line + "],";
	//		else if (i == size(s))
	//			line = "[" + line + "]]";
	//		else
	//			line = "[" + line + "],";
	//		contents = c(contents, line);
	//	}
	
	writeFile(path, contents);
}


1 {
	for (i in 1:METAPOP_NPOPS)
		sim.addSubpop(i, N);
	setUpMigration();
	
	//sim.rescheduleScriptBlock(s1, Burnin);
	//sim.rescheduleScriptBlock(s2, Burnin, Sim_Len);
	//sim.rescheduleScriptBlock(s3, Sim_Len);
}

2: {
	subpops = sim.subpopulations;
	for (destSubpop in subpops)
		if (F)
		{
			// this version lets you visualize an environmental variable using a color gradient
			//				col = rgb2color(hsv2rgb(c((destSubpop.getValue("scaled_opt0")+1)/10, 1.0, 1.0)));
			col = rgb2color(hsv2rgb(c((destSubpop.getValue("scaled_opt0")), 1.0, 1.0)));
			destSubpop.configureDisplay(c(destSubpop.getValue("xd"), destSubpop.getValue("yd")), 1.0, color=col);
		}
	else
	{
		// this version lets normal fitness coloring occur
		destSubpop.configureDisplay(c(destSubpop.getValue("xd"), destSubpop.getValue("yd")), 1.0);
	}
}

mutation(m2) {
	// draw mutational effects for the new m2 mutation
	effects = rmvnorm(1, QTL_mu, QTL_sigma);
	//	effects = rnorm(1, QTL_mu, QTL_var);
	mut.setValue("e0", effects[0]);
	mut.setValue("e1", effects[1]);
	
	return T;
}

// estimate and output individual fitness scaling 
2:early() {
	for (subpop in sim.subpopulations)
	{
		// calculate fitness optima
		opt0 = subpop.getValue("opt0");
		opt1 = subpop.getValue("opt1");
		if (sim.generation < BURNIN)
		{
			opt0 = opt0 * (sim.generation / BURNIN);
			opt1 = opt1 * (sim.generation / BURNIN);
		}
		if (sim.generation > ENV_SHIFT)
		{
			opt0 = opt0 > maxOpt0+0.5 ? 40 else opt0 + 0.1;
			opt1 = opt1 > maxOpt1+0.5 ? 40 else opt1 + 0.1;
			subpop.setValue("opt0", opt0);
			subpop.setValue("opt1", opt1);
		}
		opts = c(opt0, opt1);
		subpop.setValue("scaled_opt0", opt0);
		subpop.setValue("scaled_opt1", opt1);
		
		// calculate the fitness covariance matrix, sigma, normalization factor
		fitness_var = SIGMA_K;
		if (sim.generation < BURNIN)
			fitness_var = SIGMA_K * (sim.generation / BURNIN) + SIGMA_STAT * (1.0 - sim.generation / BURNIN);
		fitness_cov = 0.0;
		
		fitness_varcov = matrix(c(fitness_var, fitness_cov, fitness_cov, fitness_var), nrow=2);
		fitness_norm = dmvnorm(c(0.0, 0.0), c(0.0, 0.0), fitness_varcov);
		//		fitness_norm = dnorm(0.0, 0.0, fitness_var);
		subpop.setValue("fitness_varcov", fitness_varcov);
		subpop.setValue("fitness_norm", fitness_norm);
		
		for (ind in subpop.individuals)
		{
			// construct phenotypes from additive effects of QTL mutations
			muts = ind.genomes.mutationsOfType(m2);
			ind.setValue("phenotype0", size(muts) ? sum(muts.getValue("e0")) else 0.0);
			ind.setValue("phenotype1", size(muts) ? sum(muts.getValue("e1")) else 0.0);
		}
		
//		subpop.fitnessScaling = subpop.getValue("K")/ subpop.individualCount;
		// calculate fitness effects - normalize the height of the finess function to be 1.0
		inds = subpop.individuals;
		inds.fitnessScaling = dmvnorm(cbind(inds.getValue("phenotype0"), inds.getValue("phenotype1")), opts, fitness_varcov) / fitness_norm;
		//		inds.fitnessScaling = dnorm(inds.getValue("phenotype0"), opt0, fitness_var) / fitness_norm;
	}
	
	// calculate and print common garden results; this is based upon the fitness code above
	//	if (sim.generation % 100 == 0)
	//	{
	//		subpops = sim.subpopulations;
	//		nsubpops = size(subpops);
	//		fitness_matrix = matrix(rep(0.0, nsubpops*nsubpops), nrow=nsubpops, ncol=nsubpops);
	//		
	//		for (source_index in seqAlong(subpops))
	//		{
	//			source_subpop = subpops[source_index];
	//			inds = source_subpop.individuals;
	//			phenotype0 = inds.getValue("phenotype0");
	//			phenotype1 = inds.getValue("phenotype1");
	//			
	//			for (test_index in seqAlong(subpops))
	//			{
	//				test_subpop = subpops[test_index];
	//				opt0 = test_subpop.getValue("scaled_opt0");
	//				opt1 = test_subpop.getValue("scaled_opt1");
	//				fitness_varcov = test_subpop.getValue("fitness_varcov");
	//				fitness_norm = test_subpop.getValue("fitness_norm");
	//				fitnesses = dmvnorm(cbind(phenotype0, phenotype1), c(opt0, opt1), fitness_varcov) / fitness_norm;
	//				//				fitnesses = dnorm(phenotype0, opt0, fitness_var) / fitness_norm;
	//				fitness_matrix[test_index,source_index] = mean(fitnesses);
	//			}
	//		
	//		}
	//		diagonals = rep(0.0, nsubpops);
	//		for (i in seqAlong(diagonals))
	//			diagonals[i] = fitness_matrix[i,i];
	//		sympatric = mean(diagonals);
	//		allopatric = (sum(fitness_matrix) - sum(diagonals)) / (length(fitness_matrix) - length(diagonals));
	//		local_adapt = sympatric - allopatric;
	//		catn(sim.generation + ": common garden matrix:");
	//		catn("   local adaptation: " + local_adapt);
	//		catn(" sympatric adaptation: " + sympatric);
	//		catn("   allopatric adaptation: " + allopatric);
	//		catn();
	//		
	if (sim.generation % 10 == 1)
	{
		subpops = sim.subpopulations;
		all_opt0 = subpops.getValue("opt0");
		all_opt1 = subpops.getValue("opt1");
		mean_phen0 = rep(0.0, length(subpops));
		mean_phen1 = rep(0.0, length(subpops));
		nsubpops = size(subpops);
		fitness_matrix = matrix(rep(0.0, nsubpops*nsubpops), nrow=nsubpops, ncol=nsubpops);
		for (source_index in seqAlong(subpops))
		{
			source_subpop = subpops[source_index];
			inds = source_subpop.individuals;
			phenotype0 = inds.getValue("phenotype0");
			phenotype1 = inds.getValue("phenotype1");
			mean_phen0[source_index] = mean(phenotype0);
			mean_phen1[source_index] = mean(phenotype1);
			for (test_index in seqAlong(subpops))
			{
				test_subpop = subpops[test_index];
				opt0 = test_subpop.getValue("scaled_opt0");
				opt1 = test_subpop.getValue("scaled_opt1");
				fitness_varcov = test_subpop.getValue("fitness_varcov");
				fitness_norm = test_subpop.getValue("fitness_norm");
				fitnesses = dmvnorm(cbind(phenotype0, phenotype1), c(opt0, opt1), fitness_varcov) / fitness_norm;
				fitness_matrix[test_index,source_index] = mean(fitnesses);
			} // end loop through subpops
		} // end loop through subpops
		//catn(sim.generation + ": common garden matrix:");
		//print(fitness_matrix);
		diagonals = rep(0.0, nsubpops);
		for (i in seqAlong(diagonals))
			diagonals[i] = fitness_matrix[i,i];
		sympatric = mean(diagonals);
		allopatric = (sum(fitness_matrix) - sum(diagonals)) / (length(fitness_matrix) - length(diagonals));
		local_adapt = sympatric - allopatric;
		cor_0 = cor(all_opt0, mean_phen0);
		cor_1 = cor(all_opt1, mean_phen1);
		catn("Gen: " + sim.generation + ", sympatric: " + sympatric + ", allopatric: " + allopatric +", local adapt.: "+ local_adapt +", mean pheno0: "+mean(mean_phen0)+", mean pheno1: "+mean(mean_phen1)+", corr. pheno0 to env: "+ cor_0 +", corr. pheno1 to env: "+ cor_1);
		catn();
		//catn(sim.generation + ":" +mean(mean_phen0)+" "+mean(mean_phen1));
	} // end if 10 generations
	
	
	//		for(i in 0:(nrow(fitness_matrix)-1)){
	//			CG_fit = fitness_matrix[i,];
	//			writeFile(paste(c("SLiM_output/", getSeed() ,"_multi_GF_Gen",(sim.generation-1),".txt"), sep=""), paste(CG_fit),append=T);
	//		}
	//	}
}
// estimate and output individual fitness scaling 
//late() {
//	for (subpop in sim.subpopulations)
//	{
//		// calculate fitness optima
//		opt0 = subpop.getValue("opt0");
//		opt1 = subpop.getValue("opt1");
//		if (sim.generation < BURNIN)
//		{
//			opt0 = opt0 * (sim.generation / BURNIN);
//			opt1 = opt1 * (sim.generation / BURNIN);
//		}
//		if (sim.generation > ENV_SHIFT)
//		{
//			opt0 = opt0 > maxOpt0+0.5 ? 40 else opt0 + 0.1;
//			opt1 = opt1 > maxOpt1+0.5 ? 40 else opt1 + 0.1;
//			subpop.setValue("opt0", opt0);
//			subpop.setValue("opt1", opt1);
//		}
//		opts = c(opt0, opt1);
//		subpop.setValue("scaled_opt0", opt0);
//		subpop.setValue("scaled_opt1", opt1);
//		
//		// calculate the fitness covariance matrix, sigma, normalization factor
//		fitness_var = SIGMA_K;
//		if (sim.generation < BURNIN)
//			fitness_var = SIGMA_K * (sim.generation / BURNIN) + SIGMA_STAT * (1.0 - sim.generation / BURNIN);
//		fitness_cov = 0.0;
//		
//		fitness_varcov = matrix(c(fitness_var, fitness_cov, fitness_cov, fitness_var), nrow=2);
//		fitness_norm = dmvnorm(c(0.0, 0.0), c(0.0, 0.0), fitness_varcov);
//		//		fitness_norm = dnorm(0.0, 0.0, fitness_var);
//		subpop.setValue("fitness_varcov", fitness_varcov);
//		subpop.setValue("fitness_norm", fitness_norm);
//		
//		for (ind in subpop.individuals)
//		{
//			// construct phenotypes from additive effects of QTL mutations
//			muts = ind.genomes.mutationsOfType(m2);
//			ind.setValue("phenotype0", size(muts) ? sum(muts.getValue("e0")) else 0.0);
//			ind.setValue("phenotype1", size(muts) ? sum(muts.getValue("e1")) else 0.0);
//		}
//		
//		// calculate fitness effects - normalize the height of the finess function to be 1.0
//		inds = subpop.individuals;
//		
//		inds.fitnessScaling = dmvnorm(cbind(inds.getValue("phenotype0"), inds.getValue("phenotype1")), opts, fitness_varcov) / fitness_norm;
//		
//		//		inds.fitnessScaling = dnorm(inds.getValue("phenotype0" ), opt0, fitness_var) / fitness_norm;
//		//		inds.fitnessScaling = any(dnorm(inds.getValue("phenotype0" ), opt0, fitness_var) / fitness_norm == 0) ? dnorm(inds.getValue("phenotype0"), opt0, fitness_var) / fitness_norm else rep(1e-9,size(inds));
//	}
//	
//	// calculate and print common garden results; this is based upon the fitness code above
//	if (sim.generation % 100 == 0)
//	{
//		subpops = sim.subpopulations;
//		nsubpops = size(subpops);
//		fitness_matrix = matrix(rep(0.0, nsubpops*nsubpops), nrow=nsubpops, ncol=nsubpops);
//		
//		for (source_index in seqAlong(subpops))
//		{
//			source_subpop = subpops[source_index];
//			inds = source_subpop.individuals;
//			phenotype0 = inds.getValue("phenotype0");
//			phenotype1 = inds.getValue("phenotype1");
//			
//			for (test_index in seqAlong(subpops))
//			{
//				test_subpop = subpops[test_index];
//				opt0 = test_subpop.getValue("scaled_opt0");
//				opt1 = test_subpop.getValue("scaled_opt1");
//				fitness_varcov = test_subpop.getValue("fitness_varcov");
//				fitness_norm = test_subpop.getValue("fitness_norm");
//				fitnesses = dmvnorm(cbind(phenotype0, phenotype1), c(opt0, opt1), fitness_varcov) / fitness_norm;
//				//				fitnesses = dnorm(phenotype0, opt0, fitness_var) / fitness_norm;
//				fitness_matrix[test_index,source_index] = mean(fitnesses);
//			}
//		
//		}
//		diagonals = c(fitness_matrix[0,0], fitness_matrix[1,1], fitness_matrix[2,2], fitness_matrix[3,3]);
//		catn(sim.generation + ": common garden matrix:");
//		//print(fitness_matrix);
//		catn("   local adaptation: " + (mean(diagonals) - (sum(fitness_matrix) - sum(diagonals)) / (length(fitness_matrix) - length(diagonals))));
//		//		paste mean(diagonals)
//		catn("   allopatric adaptation: " + (sum(fitness_matrix) - sum(diagonals)) / (length(fitness_matrix) - length(diagonals)));
//		catn();
//		
//		for(i in 0:(nrow(fitness_matrix)-1)){
//			CG_fit = fitness_matrix[i,];
//			writeFile(paste(c("SLiM_output/multi_GF", getSeed(), "_Gen",(sim.generation-1),".txt"), sep=""), paste(CG_fit),append=T);
//		}
//	}
//}

1 : late(){
	if(sim.generation % 100 == 0){
		catn("m2 frequency in meta-pop :" + size(sim.subpopulations.individuals.genomes.mutationsOfType(m2))/size(sim.subpopulations.individuals.genomes));
		catn("Number of unique m2 alleles in meta-pop :" + size(unique(sim.subpopulations.individuals.genomes.mutationsOfType(m2))));
		catn();
	}
}

//1001 late() {
//	sim.treeSeqRememberIndividuals(sim.subpopulations.individuals);
//}

//2: early(){
//	//inds = sim.subpopulations.individuals;
//	pops = sim.subpopulations;
//	if ((sim.generation-1) % 100 == 0){
//		// get positions of all m2 mutations and store in Q
//		//g = sim.subpopulations.genomes;
//		// get the unique mutations in the sample, sorted by position		
//		//o = sortBy(unique(g.mutationsOfType(m2)), "position"); 
//		mut = sim.mutationsOfType(m2);
//		
//		fit=c();
//		for (i in pops){
//			fit = c(fit,mean(i.cachedFitness(NULL)));
//		}
//		
//		freq=c();
//		for (i in 0:(size(sim.subpopulations)-1)){
//			freq = c(freq,size(sim.subpopulations[i].genomes.mutationsOfType(m2))/size(sim.subpopulations[i].genomes));
//		}
//		
//		env=c();
//		for (i in 0:(size(sim.subpopulations)-1)){
//			env=c(env,sim.subpopulations[i].getValue("xd"));
//		}
//		info=paste(c(MIG,N,sim.chromosome.mutationRates,R,RATE,BURNIN,ENV_SHIFT));
//		out = paste(c(info,sim.generation, fit, freq, env));
//		writeFile(paste(c("SLiM_output/Fit_MM_100_", getSeed(), ".txt"), sep=""), out, append=T);
//	}
//}

//2: late(){
//	if (sim.generation % 100 == 0){
//		pos = paste(c(0.0,paste(sim.mutationsOfType(m2).position)));
//		eff=paste(c(0.0,paste(sim.mutationsOfType(m2).getValue("e0"))));
//		
//		writeFile(paste(c("SLiM_output/Freq_MM_100_", getSeed(), "_Gen",sim.generation, ".txt"), sep=""), paste(pos), append=T);
//		writeFile(paste(c("SLiM_output/Freq_MM_100_", getSeed(), "_Gen",sim.generation, ".txt"), sep=""), paste(eff), append=T);
//		
//		for (i in sim.subpopulations){
//			writeFile(paste(c("SLiM_output/Freq_MM_100_", getSeed(), "_Gen",sim.generation, ".txt"), sep=""),
//				paste(c(i.getValue("scaled_opt0"), sim.mutationFrequencies(i))), append=T);
//		}
//	}
//}


1100 late() {
	//	sim.treeSeqOutput(paste(c("SLiM_output/TSR_files/TTT_MM_100_TSR_", getSeed(), "_Gen",sim.generation,".tree"), sep=""));
	//	outputMigration("SLiM_output/mig_mat_" + getSeed() + ".txt");
}










