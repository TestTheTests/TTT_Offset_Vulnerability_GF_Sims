initialize()
{
	//setSeed(1707249891095);
	defineConstant("MY_SEED", getSeed());
	defineConstant("C_num", 10);							// number of chromosomes
	defineConstant("C_lengths", rep(50000, C_num));	// lengths for each chromosome
	defineConstant("MU_base", 1e-8);						// base mutation rate overall
	defineConstant("MU", MU_base * 0.02);				// mut rate for QTNs specifically
	defineConstant("R", 1e-8);								// recombination rate
	defineConstant("K", 100);								// subpop carrying capacity
	defineConstant("LITTER_MEAN", 4.0);					// mean litter size
	defineConstant("MIG", 0.05);							// migration rate between subpops
	defineConstant("SIGMA_K", 0.05);						// QT selection strength
	defineConstant("BURNIN", 1000);						// number of burning generations
	defineConstant("ENV_SHIFT", 1200);					// the generation in which the environment starts to shift
	defineConstant("METAPOP_SIDE", 10);					// x by x matrix of subpops
	defineConstant("METAPOP_SIZE", METAPOP_SIDE * METAPOP_SIDE);
	defineConstant("RATE", 0.01);							// rate at which environment changes
	defineConstant("S", 0.1);								// selection coefficient for local fitness gradient
	
	initializeSLiMModelType("nonWF");
	//initializeTreeSeq(simplificationInterval=500);	// infrequent for faster runtimes
	initializeMutationRate(0.0);	//MU);	// 0.0 since tree-seq overlay is generating m1 and we are introducing m2
	initializeSex("A"); //Set each population to contain two autosomal sexes that must reproduce to yield next generation
	
	//initializeMutationType("m1", 0.5, "f", 0.0); // Neutral
	initializeMutationType("m2", 0.5, "f", 0.0); // Mutation under selection across an environmental
	m2.convertToSubstitution = F;
	
	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, sum(C_lengths[0:(C_num - 2)]));
	
	rates = c(rep(c(R, 0.5), C_num-1), R);
	ends = repEach(cumSum(C_lengths), 2);
	ends = ends[0:(length(ends) - 2)];
	ends = ends + c(rep(c(0,1), C_num-1), 0);
	initializeRecombinationRate(rates, ends);
}
reproduction(NULL, "F") {
	mate = subpop.sampleIndividuals(1, sex="M");
	litterSize = rpois(1, LITTER_MEAN);
	all_subpops = sim.subpopulations;
	
	for (i in seqLen(litterSize))
	{
		// handle migration, choose a target subpopulation
		target_x = subpop.getValue("x");
		target_y = subpop.getValue("y");
		
		mig_p = runif(1);
		if (mig_p < MIG)
			target_x = target_x - 1;
		else if (mig_p < 2*MIG)
			target_x = target_x + 1;
		else if (mig_p < 3*MIG)
			target_y = target_y - 1;
		else if (mig_p < 4*MIG)
			target_y = target_y + 1;
		
		// find the target subpop if the coordinates are within bounds
		// out-of-bounds x/y coordinates do not migrate
		if ((target_x >= 1) & (target_x <= METAPOP_SIDE) &
			(target_y >= 1) & (target_y <= METAPOP_SIDE))
			target = all_subpops[target_x - 1 + (target_y - 1) * METAPOP_SIDE];
		else
			target = subpop;
		
		target.addCrossed(individual, mate);
	}
}
//10 by 10 matrix of populations
function (void)setUpSubpops(void)
{
	subpops = sim.subpopulations;
	for (x in 1:METAPOP_SIDE)
		for (y in 1:METAPOP_SIDE)
		{
			destID = (x - 1) + (y - 1) * METAPOP_SIDE + 1;
			destSubpop = subpops[destID - 1];
			destSubpop.setValue("xc", x);
			destSubpop.setValue("x", x);
			destSubpop.setValue("y", y);
			
			xd = ((x - 1) / (METAPOP_SIDE - 1)) * 0.9 + 0.05;
			yd = ((y - 1) / (METAPOP_SIDE - 1)) * 0.9 + 0.05;
			destSubpop.configureDisplay(c(xd, yd), 0.4);
		}
}
1 late() {
	for (i in 1:METAPOP_SIZE)
		sim.addSubpop(i, K);
	setUpSubpops();
	
	//sim.rescheduleScriptBlock(s1, Burnin);
	//sim.rescheduleScriptBlock(s2, Burnin, Sim_Len);
	//sim.rescheduleScriptBlock(s3, Sim_Len);
}
1000 early() {
	// introduce m2 mutation
	target = sample(p19.genomes, 1);
	target.addNewDrawnMutation(m2, 224999);
	sim.outputFull("/tmp/slim_temp_" + MY_SEED + ".txt");
}
1000:4000 early() {
	if (size(sim.subpopulations.genomes.mutationsOfType(m2)) == 0)
	{
		// Stop at extinction
		catn("Extinction in generation " + sim.generation + ".");
		//sim.simulationFinished();
		sim.readFromPopulationFile("/tmp/slim_temp_" + MY_SEED  + ".txt");
		setUpSubpops();		// restore subpop info after reloading
		setSeed(getSeed() + 1);
	}
}
2: early () {
	// calculate environmental values
	d = sim.subpopulations.getValue("xc") - 1;
	
	if (sim.generation <= ENV_SHIFT)
		env = d - 4.5;
	else
		env = d - 4.5 + RATE * (sim.generation - ENV_SHIFT);
	
	for (subpop in sim.subpopulations)
	{
		d_sub = subpop.getValue("xc") - 1;
		subpop.setValue("Env", env[d_sub]);
	}
	
	// density-dependent selection for each subpop
	sim.subpopulations.fitnessScaling = K / sim.subpopulations.individualCount;
}
//Set fitness for each population based on 10x10 grid.
fitness(m2)
{
	env = subpop.getValue("Env");
	
	if (env < 5)
		return (homozygous ? 1 + S*env else 1 + 0.5*S*env);
	else
		return (homozygous ? 1 + S*4 + -3*S*(env-4) else 1 + S*0.5*4 + -3*S*0.5*(env-4));
}

200000 late() { sim.outputFixedMutations(); }










