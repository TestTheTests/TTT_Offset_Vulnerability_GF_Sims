initialize()
{
	//setSeed(1707249891095);
	defineConstant("MY_SEED", getSeed());
	defineConstant("C_num", 10);							// number of chromosomes
	defineConstant("C_lengths", rep(50000, C_num));	// lengths for each chromosome
	defineConstant("MU_base", 1e-6);						// base mutation rate overall
	defineConstant("MU", MU_base * 0.02);				// mut rate for QTNs specifically
	defineConstant("R", 1e-8);								// recombination rate
	defineConstant("N", 100);								// subpop size
	defineConstant("MIG", 0.001);							// migration rate between subpops
	defineConstant("BURNIN", 5000);						// number of burning generations
	defineConstant("METAPOP_SIDE", 2);					// x by x matrix of subpops
	defineConstant("RATE", 0.01);							// rate at which environment changes
	defineConstant("S", 0.1);								// selection coefficient for local fitness gradient
	defineConstant("SIGMA_K", 1.25);						// smaller is stronger stabilizing selection, // larger is weaker (wider) stabilizing selection
	defineConstant("SIGMA_STAT", 4.0);					// burn-in stabilizing selection function variance
	defineConstant("METAPOP_NPOPS", METAPOP_SIDE * METAPOP_SIDE);
	
	// set up spatially autocorrelated environmental variables
	xv = rep(seq(0.0, 0.0, length=METAPOP_SIDE), METAPOP_SIDE);
	yv = repEach(seq(-1.0, 1.0, length=METAPOP_SIDE), METAPOP_SIDE);
	env = rep(seq(-1.0, 1.0, length=METAPOP_SIDE), METAPOP_SIDE);
	defineConstant("OPTS_0", xv);
	defineConstant("OPTS_1", yv);
	defineConstant("ENVS", env);
	
	//initializeTreeSeq(simplificationInterval=500);	// infrequent for faster runtimes
	initializeMutationRate(MU);
	initializeSex("A"); //Set each population to contain two autosomal sexes that must reproduce to yield next generation
	
	//initializeMutationType("m1", 0.5, "f", 0.0); // Neutral
	initializeMutationType("m2", 0.5, "f", 0.0); // QTL mutations under selection across the environment
	m2.convertToSubstitution = F;
	
	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, sum(C_lengths[0:(C_num - 2)]));
	
	rates = c(rep(c(R, 0.5), C_num-1), R);
	ends = repEach(cumSum(C_lengths), 2);
	ends = ends[0:(length(ends) - 2)];
	ends = ends + c(rep(c(0,1), C_num-1), 0);
	initializeRecombinationRate(rates, ends);
	
	// QTL-related constants used below
	defineConstant("QTL_mu", c(0, 0));
	defineConstant("QTL_cov", 0);
	defineConstant("QTL_var", SIGMA_K);
	defineConstant("QTL_sigma", matrix(c(QTL_var, QTL_cov, QTL_cov, QTL_var), nrow=2));
	
	catn();
	catn("QTL DFE means: ");
	print(QTL_mu);
	catn();
	catn("QTL DFE variance-covariance matrix: ");
	print(QTL_sigma);
}

//METAPOP_SIDE by METAPOP_SIDE matrix of populations
function (void)setUpMigration(void)
{
	subpops = sim.subpopulations;
	for (x in 1:METAPOP_SIDE)
		for (y in 1:METAPOP_SIDE)
		{
			destID = (x - 1) + (y - 1) * METAPOP_SIDE + 1;
			destSubpop = subpops[destID - 1];
			if (x > 1) // Left to right
				destSubpop.setMigrationRates(destID - 1, MIG);
			if (x < METAPOP_SIDE) // Right to left
				destSubpop.setMigrationRates(destID + 1, MIG);
			if (y > 1) // Top to bottom
				destSubpop.setMigrationRates(destID - METAPOP_SIDE, MIG);
			if (y < METAPOP_SIDE) // Bottom to top
				destSubpop.setMigrationRates(destID + METAPOP_SIDE, MIG);
			destSubpop.setValue("opt0", OPTS_0[destID - 1]);
			destSubpop.setValue("opt1", OPTS_1[destID - 1]);
			destSubpop.setValue("env", ENVS[destID - 1]);
			destSubpop.setValue("x", x);
			destSubpop.setValue("y", y);
			
			xd = ((x - 1) / (METAPOP_SIDE - 1)) * 0.9 + 0.05;
			yd = ((y - 1) / (METAPOP_SIDE - 1)) * 0.9 + 0.05;
			
			if (T)
			{
				// this version lets you visualize an environmental variable using a color gradient
				col = rgb2color(hsv2rgb(c((destSubpop.getValue("opt0") + 1.0) / 3, 1.0, 1.0)));
				destSubpop.configureDisplay(c(xd, yd), 2.0, color=col);
			}
			else
			{
				// this version lets normal fitness coloring occur
				destSubpop.configureDisplay(c(xd, yd), 2.0);
			}
		}
}
1 {
	for (i in 1:METAPOP_NPOPS)
		sim.addSubpop(i, N);
	setUpMigration();
	
	//sim.rescheduleScriptBlock(s1, Burnin);
	//sim.rescheduleScriptBlock(s2, Burnin, Sim_Len);
	//sim.rescheduleScriptBlock(s3, Sim_Len);
	
	defineConstant("pdfPath", writeTempFile("plot_", ".pdf", ""));
	
	// If we're running in SLiMgui, open a plot window
	if (exists("slimgui"))
		slimgui.openDocument(pdfPath);
}
mutation(m2) {
	// draw mutational effects for the new m2 mutation
	effects = rmvnorm(1, QTL_mu, QTL_sigma);
	
	// make some fraction of mutation affect only one of the two traits
	if (runif(1) < 0.2)
	{
		if (runif(1) < 0.5)
			effects[0] = 0.0;
		else
			effects[1] = 0.0;
	}
	
	mut.setValue("e0", effects[0]);
	mut.setValue("e1", effects[1]);
	
	return T;
}
late() {
	for (subpop in sim.subpopulations)
	{
		// calculate fitness optima
		env = subpop.getValue("env");
		opt0 = subpop.getValue("opt0");
		opt1 = subpop.getValue("opt1");
		if (sim.generation < BURNIN)
		{
			opt0 = opt0 * (sim.generation / BURNIN);
			opt1 = opt1 * (sim.generation / BURNIN);
		}
		opts = c(opt0, opt1);
		subpop.setValue("scaled_opt0", opt0);
		subpop.setValue("scaled_opt1", opt1);
		
		// calculate the fitness covariance matrix, sigma, normalization factor
		fitness_var = SIGMA_K;
		if (sim.generation < BURNIN)
			fitness_var = SIGMA_K * (sim.generation / BURNIN) + SIGMA_STAT * (1.0 - sim.generation / BURNIN);
		fitness_norm = dnorm(0.0, 0.0, fitness_var);
		
		for (ind in subpop.individuals)
		{
			// construct phenotypes from additive effects of QTL mutations
			muts = ind.genomes.mutationsOfType(m2);
			phenotype0 = size(muts) ? sum(muts.getValue("e0")) else 0.0;
			phenotype1 = size(muts) ? sum(muts.getValue("e1")) else 0.0;
			ind.setValue("phenotype0", phenotype0);
			ind.setValue("phenotype1", phenotype1);
			
			// plasticity with a two-trait reaction norm
			// phenotype0 is the "intercept" for the phenotype, phenotype1 is the "slope"
			// we calculate the final phenotype based upon those traits given the environment
			phenotype = phenotype0 + env * phenotype1;
			ind.tagF = phenotype;	// remember phenotype for output below
			
			// calculate fitness effects - normalize the height of the finess function to be 1.0
			//ind.fitnessScaling = dnorm(phenotype, opts[0], fitness_var) / fitness_norm;
			ind.fitnessScaling = dnorm(phenotype, opts[0], fitness_var) / fitness_norm * (0.5 ^ abs((0.5-phenotype1)*0.1));
			
			//			if (sim.generation > 3010)
			//			{
			//				catn("============================");
			//				catn("individual phenotype: " + phenotype);
			//				catn("optimum: " + opts[0]);
			//				catn("fitness_var: " + fitness_var);
			//				catn("fitness_norm: " + fitness_norm);
			//				catn("final fitness: " + ind.fitnessScaling);
			//			}
		}
		
		// debugging output for optima
		if (sim.generation % 50 == 1)
		{
			mean_ph0 = mean(subpop.individuals.getValue("phenotype0"));
			mean_ph1 = mean(subpop.individuals.getValue("phenotype1"));
			mean_ph = mean(subpop.individuals.tagF);
			
			catn("======================== " + sim.generation);
			catn("subpop " + subpop.id + " (" + subpop.getValue("x") + ", " + subpop.getValue("y") + ") optima: " + paste(opts) + " trait means: " + mean_ph0 + " " + mean_ph1 + " phenotypic mean: " + mean_ph);
			
			subpop.setValue("mean_ph0", mean_ph0);
			subpop.setValue("mean_ph1", mean_ph1);
			subpop.setValue("mean_ph", mean_ph);
		}
	}
	
	if (sim.generation % 50 == 1)
	{
		// output QTL effect sizes and frequencies
		muts = sim.mutationsOfType(m2);
		f = sim.mutationFrequencies(NULL, muts);
		muts = muts[f > 0.2];
		for (mut in muts) catn(mut.getValue("e0") + " " + mut.getValue("e1") + " (" + sim.mutationFrequencies(NULL, mut) + ")");
		
		// update plot
		rstr = paste(c('{',
			'intercepts <- c(' + paste(sim.subpopulations.getValue("mean_ph0"), sep=", ") + ')',
			'slopes <- c(' + paste(sim.subpopulations.getValue("mean_ph1"), sep=", ") + ')',
			'x <- c(-1, 1)',
			'y <- c(-2, 2)',
			'color <- c("red", "cornflowerblue", "red", "cornflowerblue")',
			'quartz(width=4, height=4, type="pdf", file="' + pdfPath + '")',
			'par(mar=c(4.0, 4.0, 1.5, 1.5))',
			'plot(x=x, y=y, xlab="environment", ylab="phenotype", cex.axis=0.95,',
			'                cex.lab=1.2, mgp=c(2.5, 0.7, 0), type="n",',
			'                xaxp=c(-1, 1, 2), yaxp=c(-2, 2, 4))',
			'points(c(-1,1), c('+ paste(c(p1,p2).getValue("scaled_opt0"), sep=", ") +'), col=c("red","cornflowerblue"), cex=2)',
			'for (subpop in 1:4) abline(a=intercepts[subpop], b=slopes[subpop], col=color[subpop])',
			'box()',
			'dev.off()',
			'}'), sep="\n");
		
		scriptPath = writeTempFile("plot_", ".R", rstr);
		//catn("script file saved to: " + scriptPath);
		system("/usr/local/bin/Rscript", args=scriptPath);
	}
}
200000 late() { sim.outputFixedMutations(); }










