initialize()
{
	//setSeed(1707249891095);
	defineConstant("MY_SEED", getSeed());
	defineConstant("C_num", 10);							// number of chromosomes
	defineConstant("C_lengths", rep(50000, C_num));	// lengths for each chromosome
	defineConstant("MU_base", 1e-6);						// base mutation rate overall
	defineConstant("MU", MU_base * 0.02);				// mut rate for QTNs specifically
	defineConstant("R", 1e-8);								// recombination rate
	defineConstant("N", 100);								// subpop size
	defineConstant("MIG", 0.05);							// migration rate between subpops
	defineConstant("SIGMA_K", 0.05);						// QT selection strength
	defineConstant("BURNIN", 0);						// number of burning generations
	defineConstant("ENV_SHIFT", 300);					// the generation in which the environment starts to shift
	defineConstant("METAPOP_SIDE", 10);					// x by x matrix of subpops
	defineConstant("METAPOP_SIZE", METAPOP_SIDE * METAPOP_SIDE);
	defineConstant("RATE", 0.01);							// rate at which environment changes
	defineConstant("D", 0.1);								// slope parameter for local fitness gradient
	
	//initializeTreeSeq(simplificationInterval=500);	// infrequent for faster runtimes
	initializeMutationRate(0.0);	//MU);	// 0.0 since tree-seq overlay is generating m1 and we are introducing m2
	initializeSex("A"); //Set each population to contain two autosomal sexes that must reproduce to yield next generation
	
	initializeTreeSeq();
	//simplificationRatio=INF);
	
	//initializeMutationType("m1", 0.5, "f", 0.0); // Neutral
	initializeMutationType("m2", 0.5, "f", 0.0); // Mutation under selection across an environmental
	m2.convertToSubstitution = F;
	
	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, sum(C_lengths[0:(C_num - 2)]));
	
	rates = c(rep(c(R, 0.5), C_num-1), R);
	ends = repEach(cumSum(C_lengths), 2);
	ends = ends[0:(length(ends) - 2)];
	ends = ends + c(rep(c(0,1), C_num-1), 0);
	initializeRecombinationRate(rates, ends);
}
//10 by 10 matrix of populations
function (void)setUpMigration(void)
{
	subpops = sim.subpopulations;
	for (x in 1:METAPOP_SIDE)
		for (y in 1:METAPOP_SIDE)
		{
			destID = (x - 1) + (y - 1) * METAPOP_SIDE + 1;
			destSubpop = subpops[destID - 1];
			if (x > 1) // Left to right
				destSubpop.setMigrationRates(destID - 1, MIG);
			if (x < METAPOP_SIDE) // Right to left
				destSubpop.setMigrationRates(destID + 1, MIG);
			if (y > 1) // Top to bottom
				destSubpop.setMigrationRates(destID - METAPOP_SIDE, MIG);
			if (y < METAPOP_SIDE) // Bottom to top
				destSubpop.setMigrationRates(destID + METAPOP_SIDE, MIG);
			destSubpop.setValue("xc", x);
			
			xd = ((x - 1) / (METAPOP_SIDE - 1)) * 0.9 + 0.05;
			yd = ((y - 1) / (METAPOP_SIDE - 1)) * 0.9 + 0.05;
			destSubpop.configureDisplay(c(xd, yd), 0.4);
		}
}

function (void)outputMigration(string$ path)
{
	s = sim.subpopulations;
	m = matrix(rep(0.0, (size(s) + 1) * (size(s) + 1)), nrow=size(s) + 1, ncol=size(s) + 1);
	
	for (i in seqAlong(s))
	{
		s_i = s[i];
		s_i_mig = s_i.immigrantSubpopIDs;
		s_i_frac = s_i.immigrantSubpopFractions;
		
		for (j in seqAlong(s))
		{
			s_j = s[j];
			match = (s_i_mig == s_j.id);
			
			if (sum(match))
			{
				which_match = which(match);
				m[i+1, j+1] = s_i_frac[which_match];
			}
		}
	}
	
	contents = NULL;
	for (i in seqAlong(1:(size(s)+1)))
	{
		line = paste(m[i,], sep=",");
		if (i == 0)
			line = "[[" + line + "],";
		else if (i == size(s))
			line = "[" + line + "]]";
		else
			line = "[" + line + "],";
		contents = c(contents, line);
	}
	
	writeFile(path, contents);
}


1 {
	for (i in 1:METAPOP_SIZE)
		sim.addSubpop(i, N);
	setUpMigration();
	outputMigration("mig_mat.txt");
	
	//sim.rescheduleScriptBlock(s1, Burnin);
	//sim.rescheduleScriptBlock(s2, Burnin, Sim_Len);
	//sim.rescheduleScriptBlock(s3, Sim_Len);
}
1 late() {
	// introduce m2 mutation
	target = sample(p19.genomes, 1);
	target.addNewDrawnMutation(m2, 224999);
	sim.outputFull("/tmp/slim_temp_" + MY_SEED + ".txt");
}
1:1000 late() {
	if (size(sim.subpopulations.genomes.mutationsOfType(m2)) == 0)
	{
		// Stop at extinction
		catn("Extinction in generation " + sim.generation + ".");
		//sim.simulationFinished();
		sim.readFromPopulationFile("/tmp/slim_temp_" + MY_SEED  + ".txt");
		setUpMigration();		// restore migration after reloading
		setSeed(getSeed() + 1);
	}
}
late () {
	d = sim.subpopulations.getValue("xc") - 1;
	
	if (sim.generation <= ENV_SHIFT)
		env = d - 4.5;
	else
		env = d - 4.5 + RATE * (sim.generation - ENV_SHIFT);
	
	for (subpop in sim.subpopulations)
	{
		d_sub = subpop.getValue("xc") - 1;
		subpop.setValue("Env", env[d_sub]);
	}
	
	// BCH: Tell SLiM to evaluate fitnesses with s1 only, for the fitness values SLiM will actually use
	s1.active = 1;
	s2.active = 0;
}

300 {
	sim.treeSeqRememberIndividuals(sim.subpopulations.individuals);
}

// Set fitness for each population based on 10x10 grid.
// This fitness() callback performs normal fitness evaluations for SLiM
s1 fitness(m2)
{
	env = subpop.getValue("Env");
	
	if (env < 5)
		return (homozygous ? 1 + D*env else 1 + 0.5*D*env);
	else
		return (homozygous ? 1 + 4*D + -3*D*(env-4) else 1 + 2*D + -1.5*D*(env-4));
}

// This fitness() callback performs common-garden fitness evaluations using
// the environmental value set by the late() event below
s2 fitness(m2)
{
	env = sim.getValue("Common_Env");
	
	if (env < 5)
		return (homozygous ? 1 + D*env else 1 + 0.5*D*env);
	else
		return (homozygous ? 1 + 4*D + -3*D*(env-4) else 1 + 2*D + -1.5*D*(env-4));
}

// calculate and print common garden results; this is based upon the fitness code above
// this needs to be an early() event because SLiM doesn't like it if we called cachedFitness()
// in a late() event in a WF model; arguably that is a bug, but using an early() event should work
2:1001 early(){
	if ((sim.generation - 1) % 10 == 1)
	{
		subpops = sim.subpopulations;
		nsubpops = size(subpops);
		fitness_matrix = matrix(rep(0.0, nsubpops*nsubpops), nrow=nsubpops, ncol=nsubpops);
		CG_fit = NULL;
		// BCH fitness calculation experiment: use the s2 fitness() callback to evaluate
		// fitnesses in each common garden, disabling s1 for this purpose
		for (source_index in seqAlong(subpops))
		{
			source_subpop = subpops[source_index];
			sim.setValue("Common_Env", source_subpop.getValue("Env"));
			
			s1.active = 0;
			s2.active = 1;
			sim.recalculateFitness();
			
			for (test_index in seqAlong(subpops))
			{
				test_subpop = subpops[test_index];
				
				fitness_matrix[source_index,test_index] = mean(test_subpop.cachedFitness(NULL));
			}
				CG_fit = c(CG_fit,fitness_matrix[source_index,]);
				writeFile(paste(c("CG_SP_100_", getSeed(), ".txt"), sep=""), paste(CG_fit), append=T);

		}
		
		//		for (source_index in seqAlong(subpops))
		//		{
		//			source_subpop = subpops[source_index];
		//			env = source_subpop.getValue("Env");
		//			
		//			for (test_index in seqAlong(subpops))
		//			{
		//				test_subpop = subpops[test_index];
		//				fitness_value = NULL;
		//				for (ind in test_subpop.individuals){
		//					if (size(ind.genomes.mutationsOfType(m2))==2)
		//						fitness_value = c(fitness_value, 1 + -D*env);
		//					else
		//						fitness_value = c(fitness_value, 1 + -0.5*D*env);
		//				}
		//				fitness_matrix[source_index, test_index] = mean(fitness_value);
		//			}
		//		}
		
		catn((sim.generation - 1) + ": common garden matrix:");
		print(fitness_matrix);
		diagonals = NULL;
		for (x in 0:(METAPOP_SIDE-1))
			for (y in 0:(METAPOP_SIDE-1))
			{
				if (y==x)
					diagonals = c(diagonals,fitness_matrix[x,y]);
			}
		catn("   local adaptation: " + (mean(diagonals) - (sum(fitness_matrix) - sum(diagonals)) / (length(fitness_matrix) - length(diagonals)))); //Updated to subtract off-diagonal from diagonal
		catn("   allopatric adaptation: " + (sum(fitness_matrix) - sum(diagonals)) / (length(fitness_matrix) - length(diagonals)));
		catn();
		
		// BCH: Tell SLiM to evaluate fitnesses with s1 only, for the fitness values SLiM will actually use
		// This restores the correct fitness values prior to reproduction.  It's unfortunate to have to do this;
		// if this could be a late() event instead, this redundant calculation would be avoided.
		s1.active = 1;
		s2.active = 0;
		sim.recalculateFitness();
	}
}

2:600 early(){
	//inds = sim.subpopulations.individuals;
	pops = sim.subpopulations;
	if ((sim.generation-1) % 10 == 0){
		// get positions of all m2 mutations and store in Q
		//g = sim.subpopulations.genomes;
		// get the unique mutations in the sample, sorted by position		
		//o = sortBy(unique(g.mutationsOfType(m2)), "position"); 
		mut = sim.mutationsOfType(m2);
		
		fit=c();
		for (i in pops){
			fit = c(fit,mean(i.cachedFitness(NULL)));
		}
		
		freq=c();
		for (i in 0:(size(sim.subpopulations)-1)){
			freq = c(freq,size(sim.subpopulations[i].genomes.mutationsOfType(m2))/size(sim.subpopulations[i].genomes));
		}
		
		env=c();
		for (i in 0:(size(sim.subpopulations)-1)){
			env=c(env,sim.subpopulations[i].getValue("Env"));
		}
		info=paste(c(MIG,N,sim.chromosome.mutationRates,R,RATE,BURNIN,ENV_SHIFT));
		out = paste(c(info,sim.generation, fit, freq, env));
		writeFile(paste(c("Fit_SP_100_", getSeed(), ".txt"), sep=""), out, append=T);
	}
}

600 late(){
	sim.treeSeqOutput(paste(c("TTT_SP_100_TSR_", getSeed(), "_Gen",sim.generation,".tree"), sep=""));
}












