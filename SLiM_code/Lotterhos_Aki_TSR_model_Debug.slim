initialize()
{
	//setSeed(1707249891095);
	defineConstant("MY_SEED", getSeed());
	defineConstant("C_num", 10);							// number of chromosomes
	defineConstant("C_lengths", rep(50000, C_num));	// lengths for each chromosome
	defineConstant("MU_base", 1e-8);						// base mutation rate overall
	defineConstant("MU", MU_base * 0.02);				// mut rate for QTNs specifically
	defineConstant("R", 1e-8);								// recombination rate
	defineConstant("N", 100);								// subpop size
	defineConstant("MIG", 0.2);							// migration rate between subpops
	defineConstant("SIGMA_K", 0.05);						// QT selection strength
	defineConstant("BURNIN", 1000);						// number of burning generations
	defineConstant("ENV_SHIFT", 1200);					// the generation in which the environment starts to shift
	defineConstant("METAPOP_SIDE", 6);					// x by x matrix of subpops
	defineConstant("METAPOP_SIZE", METAPOP_SIDE * METAPOP_SIDE);
	defineConstant("RATE", 0.01);							// rate at which environment changes
	defineConstant("S", 0.1);								// selection coefficient for local fitness gradient
	
	//initializeTreeSeq(simplificationInterval=500);	// infrequent for faster runtimes
	initializeMutationRate(0.0);	//MU);	// 0.0 since tree-seq overlay is generating m1 and we are introducing m2
	initializeSex("A"); //Set each population to contain two autosomal sexes that must reproduce to yield next generation
	
	initializeTreeSeq();
	//simplificationRatio=INF);
	
	//initializeMutationType("m1", 0.5, "f", 0.0); // Neutral
	initializeMutationType("m2", 0.5, "f", 0.0); // Mutation under selection across an environmental
	m2.convertToSubstitution = F;
	
	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, sum(C_lengths[0:(C_num - 2)]));
	
	rates = c(rep(c(R, 0.5), C_num-1), R);
	ends = repEach(cumSum(C_lengths), 2);
	ends = ends[0:(length(ends) - 2)];
	ends = ends + c(rep(c(0,1), C_num-1), 0);
	initializeRecombinationRate(rates, ends);
}
//10 by 10 matrix of populations
function (void)setUpMigration(void)
{
	subpops = sim.subpopulations;
	for (x in 1:METAPOP_SIDE)
		for (y in 1:METAPOP_SIDE)
		{
			destID = (x - 1) + (y - 1) * METAPOP_SIDE + 1;
			destSubpop = subpops[destID - 1];
			if (x > 1) // Left to right
				destSubpop.setMigrationRates(destID - 1, MIG);
			if (x < METAPOP_SIDE) // Right to left
				destSubpop.setMigrationRates(destID + 1, MIG);
			if (y > 1) // Top to bottom
				destSubpop.setMigrationRates(destID - METAPOP_SIDE, MIG);
			if (y < METAPOP_SIDE) // Bottom to top
				destSubpop.setMigrationRates(destID + METAPOP_SIDE, MIG);
			destSubpop.setValue("xc", x);
			
			xd = ((x - 1) / (METAPOP_SIDE - 1)) * 0.9 + 0.05;
			yd = ((y - 1) / (METAPOP_SIDE - 1)) * 0.9 + 0.05;
			destSubpop.configureDisplay(c(xd, yd), 0.4);
		}
}

function (void)outputMigration(string$ path)
{
    s = sim.subpopulations;
    m = matrix(rep(0.0, (size(s) + 1) * (size(s) + 1)), nrow=size(s) + 1, ncol=size(s) + 1);
    
    for (i in seqAlong(s))
    {
        s_i = s[i];
        s_i_mig = s_i.immigrantSubpopIDs;
        s_i_frac = s_i.immigrantSubpopFractions;
        
        for (j in seqAlong(s))
        {
            s_j = s[j];
            match = (s_i_mig == s_j.id);
            
            if (sum(match))
            {
                which_match = which(match);
                m[i, j] = s_i_frac[which_match];
            }
        }
    }
    
    contents = NULL;
    for (i in seqAlong(s))
    {
        line = paste(m[i,], sep=",");
        if (i == 0)
            line = "[[" + line + "],";
        else if (i == size(s) - 1)
            line = "[" + line + "]]";
        else
            line = "[" + line + "],";
        contents = c(contents, line);
    }
    
    writeFile(path, contents);
}


1 {
	for (i in 1:METAPOP_SIZE)
		sim.addSubpop(i, N);
	setUpMigration();
	outputMigration("mig_mat.txt");
	
	//sim.rescheduleScriptBlock(s1, Burnin);
	//sim.rescheduleScriptBlock(s2, Burnin, Sim_Len);
	//sim.rescheduleScriptBlock(s3, Sim_Len);
}
1000 late() {
	// introduce m2 mutation
	target = sample(p2.genomes, 1);
	target.addNewDrawnMutation(m2, 224999);
	sim.outputFull("/tmp/slim_temp_" + MY_SEED + ".txt");
}
1000:1400 late() {
	if (size(sim.subpopulations.genomes.mutationsOfType(m2)) == 0)
	{
		// Stop at extinction
		catn("Extinction in generation " + sim.generation + ".");
		//sim.simulationFinished();
		sim.readFromPopulationFile("/tmp/slim_temp_" + MY_SEED  + ".txt");
		setUpMigration();		// restore migration after reloading
		setSeed(getSeed() + 1);
	}
}
late () {
	d = sim.subpopulations.getValue("xc") - 1;
	
	if (sim.generation <= ENV_SHIFT)
		env = d - 4.5;
	else
		env = d - 4.5 + RATE * (sim.generation - ENV_SHIFT);
	
	for (subpop in sim.subpopulations)
	{
		d_sub = subpop.getValue("xc") - 1;
		subpop.setValue("Env", env[d_sub]);
	}
}

1200 {
   sim.treeSeqRememberIndividuals(sim.subpopulations.individuals);
}

//Set fitness for each population based on 10x10 grid.
fitness(m2)
{
	env = subpop.getValue("Env");
	
	if (env < -3)
		return (homozygous ? 1 + -S*env else 1 + -0.5*S*env);
	else
		return (homozygous ? 1 + -S*env +0.25 else 1 + -S*env +0.15);
}

1400 late(){
sim.treeSeqOutput(paste(c("TTT_SP_100_TSR_", getSeed(), "_Gen",sim.generation,".tree"), sep=""));
}
	











