---
title: "GF thought experiments"
author: "By KE Lotterhos with input from all authors"
date: "5/4/2021"
output: html_document
---



```{r setup, eval=FALSE, echo=FALSE}
setwd("/scratch/lotterhos/NewGFExample2")
#packrat::init(".")
packrat::on()
install.packages("devtools") # this failed
#install.packages("knitr")
#install.packages("tinytex")
#install.packages("rmarkdown")
#install.packages("viridisLite")
#install.packages("gradientForest", repos="http://R-Forge.R-project.org")
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r load library}
library(gradientForest)
cols <- viridisLite::turbo(10)
pchs <- c(0, 1, 2, 15, 23)
options(warn = -1)
```


## Run GF model Function

```{r run GF model}
runMod <- function(envPop, alFreq, ntree=500, corr.threshold=0.5){
  # envPop is a dataframe of environments
  # alfreq is the pattern of allele frequency across that environment
  alFreq1 <- data.frame(alFreq)
  #names(alFreq1) <- "alFreq1"
  gfMod <- gradientForest(data=data.frame(envPop, alFreq1),
                          predictor.vars=names(envPop),
                          response.vars=names(alFreq1),
                          corr.threshold=corr.threshold, 
                          ntree=ntree, 
                          trace=F)
  
  CI <- cumimp(gfMod, "envPop")
  return(list(CI=CI, IsZero=sum(CI$y)==0, R2=gfMod$result))
}

runMod_multi <- function(envPop, alFreq, ntree=500, corr.threshold=0.5){
  # envPop is a dataframe of environments
  # alfreq is the pattern of allele frequency across that environment
  alFreq1 <- data.frame(alFreq)
  #save the different environment names
  pred.vars<-names(envPop)
  resp.vars <- names(alFreq1)
  gfMod <- gradientForest(data=data.frame(envPop, alFreq1),
                          predictor.vars=pred.vars,
                          response.vars=resp.vars,
                          corr.threshold=corr.threshold, 
                          ntree=ntree, 
                          trace=F)
  #create a list of CI for each environment and an IsZero entry for each one as well
  CI_env <- list()
  CI_locus_env <- list()
  IsZero <- list()
  for(i in 1:length(pred.vars)){
    CI_env[[pred.vars[i]]]<-cumimp(gfMod, pred.vars[i], type="Overall")
    IsZero[[pred.vars[i]]]<-sum(CI_env[[pred.vars[i]]]$y)==0
    CI_locus_env[[pred.vars[i]]]<-cumimp(gfMod, pred.vars[i], type="Species")
  }
  #save as a list of lists, including the overall CI (gfMod$Y)
  return(list(CI_env=CI_env, CI=gfMod$Y, IsZero=IsZero, R2=gfMod$result, CI_locus_env))
}
```

Output 1: *Cumulative importance prediction as a function of the environment.* We found that in sparse sampling (see below), this sometimes output all 0's

Output 2: *R2* This is the proportion of variance in the allele frequency that is explained by the model.

# First comparison: few vs. many populations sampled along a cline

## First take home message: GF outputs depends on sampling scheme

Sometimes in pop gen we only have a few populations sampled. Here we explore the consequences of sampling design on GF outputs. All sampling schemes were based on the same relationship betweeen allele frequency and the environment. We sampled 6, 8, 10, 15, or 50 populations across an environmental gradient.

```{r, echo=FALSE}

### Compare the same cline for 10 vs. 50 environment sites ####
envPop_short <- data.frame(envPop=seq(-1,1,length.out=6)) #create env

# check that the environment is numeric
str(envPop_short)

#create four allele frequency gradients of varying steepness
alFreq_L1_short<-seq(0.1,0.9,length.out=6)
CI_short <- replicate(100,runMod(envPop_short, alFreq_L1_short))
CI_short_prop0 <- sum(unlist(CI_short[seq(2,length(CI_short), by=3)]))/100
CI_short_R2 <- (unlist(CI_short[seq(3,length(CI_short), by=3)]))

envPop_med <- data.frame(envPop=seq(-1,1,length.out=8)) #create env
#create four allele frequency gradients of varying steepness
alFreq_L1_med<-seq(0.1,0.9,length.out=8)
CI_med <- replicate(100,runMod(envPop_med, alFreq_L1_med))
CI_med_prop0 <- sum(unlist(CI_med[seq(2,length(CI_short), by=3)]))/100
CI_med_R2 <- (unlist(CI_med[seq(3,length(CI_short), by=3)]))

envPop_med2 <- data.frame(envPop=seq(-1,1,length.out=10)) #create env
#create four allele frequency gradients of varying steepness
alFreq_L1_med2 <-seq(0.1,0.9,length.out=10)
CI_med2 <- replicate(100,runMod(envPop_med2, alFreq_L1_med2))
CI_med2_prop0 <- sum(unlist(CI_med2[seq(2,length(CI_short), by=3)]))/100
CI_med2_R2 <- (unlist(CI_med2[seq(3,length(CI_short), by=3)]))


envPop_long <- data.frame(envPop=seq(-1,1,length.out=15)) #create env
#create four allele frequency gradients of varying steepness
alFreq_L1_long<-seq(0.1,0.9,length.out=15)
CI_long <- replicate(100,runMod(envPop_long, alFreq_L1_long))
CI_long_prop0 <- sum(unlist(CI_long[seq(2,length(CI_long), by=3)]))/100
CI_long_R2 <- (unlist(CI_long[seq(3,length(CI_long), by=3)]))


envPop_long2 <- data.frame(envPop=seq(-1,1,length.out=50)) #create env
#create four allele frequency gradients of varying steepness
alFreq_L1_long2<-seq(0.1,0.9,length.out=50)
CI_long2 <- replicate(100,runMod(envPop_long2, alFreq_L1_long2))
CI_long2_prop0 <- sum(unlist(CI_long2[seq(2,length(CI_long2), by=3)]))/100
CI_long2_R2 <- (unlist(CI_long2[seq(3,length(CI_long2), by=3)]))


# How many times does it give all 0's?
samp_sizes <- c(6,8,10,15, 50)
```

The following plot shows the relationship between allele frequency and the environment is the same for the different sampling schemes:
```{r, fig.height=12, fig.width=6}
par(mar=c(3,1,3,0.4), mfrow=c(5,1), oma=c(4,4,0,0))
plot(envPop_short$envPop, alFreq_L1_short, xlab="environment", ylab="allele freq.", col=cols[1], pch=pchs[1], bty="n", main="6 sites", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.3))
plot(envPop_med$envPop, alFreq_L1_med, xlab="environment", ylab="allele freq.", col=cols[3], pch=pchs[2], bty="n", main="8 sites", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.3))
plot(envPop_med2$envPop, alFreq_L1_med2, xlab="environment", ylab="allele freq.", col=cols[5], pch=pchs[3], bty="n" , main="10 sites", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.3))
plot(envPop_long$envPop, alFreq_L1_long, xlab="environment", ylab="allele freq.", col=cols[7], pch=pchs[4], bty="n", main="15 sites", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.3))
plot(envPop_long2$envPop, alFreq_L1_long2, xlab="environment", ylab="allele freq.", col=cols[9], pch=pchs[5], bty="n", main="50 sites", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.3))
mtext("environment", side=1, outer=TRUE, line=2)
mtext("allele frequency", side=2, outer=TRUE, line=1)
```

For each sampling scheme, we conducted 100 replicate simulations of GF with 500 trees.

The R^2 value from GF is typically interpreted to be similar to a regression. However, it increases with the number of sites sampled along the gradient, as shown in the next graph:

```{r, fig.width=6}
# Histogram of R2 values
hist(CI_short_R2, xlim=c(0,1), ylim=c(0,40), col=cols[1], xlab="R^2", main="Distribution of R^2 for\ndifferent sampling schemes")
hist(CI_med_R2, xlim=c(0,1), col=cols[3], add=TRUE )
hist(CI_med2_R2, xlim=c(0,1), col=cols[5], add=TRUE)
hist(CI_long_R2, xlim=c(0,1), col=cols[7], add=TRUE , border = cols[4])
hist(CI_long2_R2, xlim=c(0,1), col=cols[9], add=TRUE )

legend(0, 40, fill=cols[seq(1,9, by=2)], legend = samp_sizes)
```

The above two graphs illustrate that the R^2 value from a gradient forests output is not similar to a R^2 value from a regression (which should be the same in all 5 of these cases).

The next figure illustrates that the shape and height of the cumulative importance curve is also sensitive to the sampling design:

```{r, fig.width=6}
# CI vs. env
sequ <- seq(1, length(CI_short), by=3)
plot(CI_short[[1]]$x, CI_short[[1]]$y, type="l", col=cols[1], ylim=c(-0.1,1), ylab="CI", xlab="environment")
for (i in sequ){
  points(CI_short[[i]]$x, CI_short[[i]]$y, type="l", col=adjustcolor(cols[1], 0.5))
  points(CI_med[[i]]$x, CI_med[[i]]$y, type="l", col=adjustcolor(cols[3], 0.5))
  points(CI_med2[[i]]$x, CI_med2[[i]]$y, type="l", col=adjustcolor(cols[5], 0.5))
  points(CI_long[[i]]$x, CI_long[[i]]$y, type="l", col=adjustcolor(cols[7], 0.5))
  points(CI_long2[[i]]$x, CI_long2[[i]]$y, type="l", col=adjustcolor(cols[9], 0.5))
}

legend(-0.8, 1, fill=rev(cols[seq(1,9, by=2)]), legend = rev(samp_sizes))
```

The above plot highlights some interesting behavior. 

First, the height of the CI curve depends on the sampling scheme. Sampling more sites along the gradient results in a higher overall CI.

Second, the shape of the CI curve depends on the sampling scheme. Sampling more sites along the gradient results in more sigmodal shaped CI function near the intermediate environment. For example, the actual allele frequency turnover is the same across all 5 sampling schemes. But the CI function makes it look like the sampling scheme with 50 samples is very steep near `environment=0` compared to the other schemes. This highlights issues with interpreting GF outputs as allele frequency change along a gradient and calculating GF offsets from that.

Third, there is an behavior with the distribution of CI values, but it's hard to see. With the sparsest sampling scheme (6 sites), the CI is always 0. With less sparse sampling schemes (e.g., 8 or 10 sites), the CI is _sometimes_ 0, but it's hard to see because all the lines overlap at the horizontal line at y=0. We will visualized that in the next plot:

```{r, fig.width=6}
# Proportion of 0s
par(mar=c(4,4,3,0.4), mfrow=c(1,1), oma=c(0,0,0,0), bty="l")
plot(samp_sizes, c(CI_short_prop0, CI_med_prop0, CI_med2_prop0, CI_long_prop0, CI_long2_prop0), xlab="number of sites",
     type="l", col="blue", ylab= "proportion", 
     main="proportion of times the CI gives all 0s", ylim=c(0,1))
```

The above plot shows that sometimes GF output all 0s for the cumulative importance function, and that the proportion of times this happened was higher for sparser sampling schemes. We did not find increasing the number of trees changed these proportions.

Another way to visualize it as the distribution of R^2 vs. maximum CI for each replicate simulation:

```{r, fig.width=6}
sequ <- seq(1, length(CI_short), by=3)
plot(CI_short[[3]], max(CI_short[[1]]$y), col=adjustcolor(cols[1], 0.5), ylim=c(-0.1,1), xlab="R2", ylab="max CI", xlim=c(0,1), pch=pchs[1], main="Sampling scheme comparison")
for (i in sequ){
  points(CI_short[[i+2]], max(CI_short[[i]]$y),  col=adjustcolor(cols[1], 0.5), pch=pchs[1])
  points(CI_med[[i+2]], max(CI_med[[i]]$y),  col=adjustcolor(cols[3], 0.5), pch=pchs[2])
  points(CI_med2[[i+2]], max(CI_med2[[i]]$y),  col=adjustcolor(cols[5], 0.5), pch=pchs[3])
  points(CI_long[[i+2]], max(CI_long[[i]]$y), col=adjustcolor(cols[7], 0.5), pch=pchs[4])
  points(CI_long2[[i+2]],max(CI_long2[[i]]$y),  col=adjustcolor(cols[9], 0.5), pch=pchs[5])
}

legend(0.1, 1, col =rev(cols[seq(1,9, by=2)]), legend = rev(samp_sizes), pch=rev(pchs))
```

Maybe this weird behavior is GF's way of weighting individual loci that it has more confidence in (e.g, denser sampling). However, it does raise issues for the way that populations are sampled unequally along gradients in nature. In our simulations we had equal number of sites sampled along each environmental gradient (e.g., a 10 x 10 matrix with latitudinal gradient and a longitudinal gradient), so the effect of unequal sampling along different gradients warrants further investigation. 

# Second comparison: A steep cline vs. less steep cline vs. a reverse cline

## Second take home message: GF outputs are the same regardless of slope of cline

For this comparison, we assumed equal sampling (15 sites along the cline) and manipulated the pattern of allele frequency along the cline.

Code used from first section:
```
envPop_long <- data.frame(envPop=seq(-1,1,length.out=15)) #create env
#create four allele frequency gradients of varying steepness
alFreq_L1_long<-seq(0.1,0.9,length.out=15)
CI_long <- replicate(100,runMod(envPop_long, alFreq_L1_long))
(CI_long_R2 <- (unlist(CI_long[seq(3,length(CI_long), by=3)])))
```

```{r}
alFreq_L1_rev<- rev(alFreq_L1_long)
CI_rev <- replicate(100,runMod(envPop_long, alFreq_L1_rev))
CI_rev_R2 <- (unlist(CI_rev[seq(3,length(CI_rev), by=3)]))

alFreq_L1_shallow<-seq(0.4,0.6,length.out=15)
CI_shallow <- replicate(100,runMod(envPop_long, alFreq_L1_shallow))
CI_shallow_R2 <- (unlist(CI_shallow[seq(3,length(CI_shallow), by=3)]))
```

As you will see below, all of these clines have the same R^2 value and same max CI (e.g., the same proportion of variance explained by the model). The results highlight, however, why the GF output cannot be called a "vulnerability": the output is agnostic to the direction of allele frequency change across the gradient.

```{r, fig.width=6, fig.height=12}
par(mar=c(3,1,3,0.4), mfrow=c(3,1), oma=c(4,4,0,0))
plot(envPop_long$envPop, alFreq_L1_long, xlab="environment", ylab="allele freq.", col=cols[7], pch=pchs[4], bty="n", main="steep", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.1))
plot(envPop_long$envPop, alFreq_L1_rev, xlab="environment", ylab="allele freq.", col=cols[2], pch=pchs[2], bty="n", main="reverse", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.1))
plot(envPop_long$envPop, alFreq_L1_shallow, xlab="environment", ylab="allele freq.", col=cols[10], pch=pchs[3], bty="n", main="shallow", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.1))
```

All these relationships give essentially the same CI curve: 
```{r, fig.width=6}
par(mfrow=c(1,1), mar=c(4,4,1,1))
# CI vs. env
sequ <- seq(1, length(CI_short), by=3)
plot(CI_long[[1]]$x, CI_long[[1]]$y, type="l", col=cols[7], ylim=c(-0.1,1), ylab="CI", xlab="environment")
for (i in sequ){
  points(CI_long[[i]]$x, CI_long[[i]]$y, type="l", col=adjustcolor(cols[7], 0.5))
  points(CI_rev[[i]]$x, CI_rev[[i]]$y, type="l", col=adjustcolor(cols[2], 0.5))
  points(CI_shallow[[i]]$x, CI_shallow[[i]]$y, type="l", col=adjustcolor(cols[10], 0.5))
}

legend(-0.8, 1, fill=cols[c(7,2,10)], legend = c("steep", "reverse", "shallow"))
```

And same R^2 function:
```{r, fig.width=6}
hist(CI_long_R2, xlim=c(0.9,1), col=adjustcolor(cols[7], 0.3), ylim=c(0,50), main="Cline type", xlab="R^2")
hist(CI_rev_R2, xlim=c(0,1), col=adjustcolor(cols[2], 0.3), add=TRUE )
hist(CI_shallow_R2, xlim=c(0,1), col=adjustcolor(cols[10], 0.3), add=TRUE )
legend(0.9, 50, fill=cols[c(7,2,10)], legend = c("steep", "reverse", "shallow"))
```

This section highlighted out the GF output is driven by the proportion of variance the model can explain in the data, which is the same for all shapes of allele frequency curves. To further illustrate this, we will consider in the next section changing the shape of the relationship between a.f. and environment.


# Third comparison: Non-monotonic relationships with allele frequency

## Third take home message: GF outputs are the same regardless of the magnitude of the non-monotonic relationship with allele frequency, when they have the same shape

For this comparison, we assumed equal sampling (15 sites along the cline) and manipulated the pattern of allele frequency along the cline.


```{r, fig.width=6}
envPop_long <- data.frame(envPop=seq(-1,1,length.out=15)) #create env
alFreq_nonMon<- c(seq(0.1,0.9, length.out=5), rep(0.9,5), seq(0.9,0.1, length.out=5))
CI_nonMon <- replicate(100,runMod(envPop_long, alFreq_nonMon))
CI_nonMon_R2 <- (unlist(CI_nonMon[seq(3,length(CI_nonMon), by=3)]))

alFreq_nonMon_rev<- 1-alFreq_nonMon
CI_nonMon_rev <- replicate(100,runMod(envPop_long, alFreq_nonMon_rev))
CI_nonMon_rev_R2 <- (unlist(CI_nonMon_rev[seq(3,length(CI_nonMon_rev), by=3)]))

alFreq_nonMon_shallow<- c(seq(0.4,0.6, length.out=5), rep(0.6,5), seq(0.6,0.4, length.out=5))
CI_nonMon_shallow <- replicate(100,runMod(envPop_long, alFreq_nonMon_shallow))
CI_nonMon_shallow_R2 <- (unlist(CI_nonMon_shallow[seq(3,length(CI_nonMon_shallow), by=3)]))

```

The shallow non-monotonic case gives the following error in GF, but still runs and produces outputs:

```
Warning in randomForest.default(m, y, ...): The response has five or fewer
unique values. Are you sure you want to do regression?
```

Plot the patterns of allele frequency as a function of the environment:

```{r , fig.width=6, fig.height=12}
par(mar=c(3,1,3,0.4), mfrow=c(3,1), oma=c(4,4,0,0))
plot(envPop_long$envPop, alFreq_nonMon, xlab="environment", ylab="allele freq.", col=cols[1], pch=pchs[5], bty="n", main="steep", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.1))
plot(envPop_long$envPop, alFreq_nonMon_rev, xlab="environment", ylab="allele freq.", col=cols[5], pch=pchs[2], bty="n", main="reverse", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.1))
plot(envPop_long$envPop, alFreq_nonMon_shallow, xlab="environment", ylab="allele freq.", col=cols[3], pch=pchs[3], bty="n", main="shallow", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.1))
```

All these relationships give essentially the same CI curve: 
```{r , fig.width=6}
par(mfrow=c(1,1), mar=c(4,4,1,1))
# CI vs. env
sequ <- seq(1, length(CI_nonMon), by=3)
plot(CI_nonMon[[1]]$x, CI_nonMon[[1]]$y, type="l", col=cols[7], ylim=c(-0.1,1), ylab="CI", xlab="environment")
for (i in sequ){
  points(CI_nonMon[[i]]$x, CI_nonMon[[i]]$y, type="l", col=adjustcolor(cols[1], 0.5))
  points(CI_nonMon_rev[[i]]$x, CI_nonMon_rev[[i]]$y, type="l", col=adjustcolor(cols[5], 0.5))
  points(CI_nonMon_shallow[[i]]$x, CI_nonMon_shallow[[i]]$y, type="l", col=adjustcolor(cols[3], 0.5))
}

legend(-0.8, 1, fill=cols[c(1,5,3)], legend = c("steep", "reverse", "shallow"))
```

And same R^2 function:
```{r , R^2 hist}
hist(CI_nonMon_R2, xlim=c(0.5,1), col=adjustcolor(cols[1], 0.5), ylim=c(0,50), xlab="R^2", main=
      "Distribution of R^2 from\nreplicate non-monotonic sims")
hist(CI_nonMon_rev_R2, xlim=c(0,1), col=adjustcolor(cols[5], 0.3), add=TRUE )
hist(CI_nonMon_shallow_R2, xlim=c(0,1), col=adjustcolor(cols[3], 0.3), add=TRUE )
legend(0.8, 40, fill=cols[c(1,5,3)], legend = c("steep", "reverse", "shallow"))
```

The above two sections illustrate  that the GF CI curves do not correspond the amount of turnover in allele frequency. If we consider turnover in allele frequency in the mathematical sense, it is the amount of change in allele frequency per unit change in the environment. In the examples in the above two sections, steeper clines have greater amount of change in allele frequency per unit change in the environment than shallower clines. Hence, if the maximum CI of an allele reflected the turnover, alleles with steeper clines should have greater maximum CI. However, the above two sections show this is not the case when comparing alleles with similar patterns but different amounts of frequency change across the gradient. The maximum CI is, instead, driven by how much variation in allele frequency the gradient-forests model explains, which is the same for steep, shallow, and reverse clines of the same general pattern across the environmental gradient.

The non-monotonic clines in the above example all have the same allele frequency at the extremes of the environmental variable. If the genetic basis of adaptation was monogenic (e.g. caused by a single allele), and fitness followed the same non-monotonic pattern (e.g., individuals with the focal allele had highest fitness in the intermediate values of the environment, and individuals with the alternate allele had highest fitness in the extreme values of the environment), then this conceptual example illustrates issues with calling the GF-offset a genetic offset or genomic vulnerability. In this hypothetical case, individuals of the same genotype would have the same fitness at extreme values of the environment, and hence the genetic offset should be 0. But GF would predict a maximum offset (e.g. the vertical distance in the CI evaluated an environment of -1 and the CI evaluated an environment of +1 in the previous plot).

```{r eval=FALSE, echo=FALSE}
pdf("AFpatternsForManuscript.pdf", width=6, height=6)
  par(mar=c(3,3,3,0.4), mfrow=c(2,2), oma=c(2,2,0,0))
  plot(envPop_long$envPop, alFreq_L1_long, xlab="environment", ylab="allele freq.", col=cols[7], pch=pchs[4], bty="n", main="steep", ylim=c(0,1))
  abline(h=0.5, col=rgb(0,0,0,0.1))
  plot(envPop_long$envPop, alFreq_L1_rev, xlab="environment", ylab="allele freq.", col=cols[2], pch=pchs[2], bty="n", main="reverse", ylim=c(0,1))
  abline(h=0.5, col=rgb(0,0,0,0.1))
  plot(envPop_long$envPop, alFreq_L1_shallow, xlab="environment", ylab="allele freq.", col=cols[10], pch=pchs[3], bty="n", main="shallow", ylim=c(0,1))
  abline(h=0.5, col=rgb(0,0,0,0.1))
  plot(envPop_long$envPop, alFreq_nonMon, xlab="environment", ylab="allele freq.", col=cols[3], pch=pchs[1], bty="n", main="non-monotonic", ylim=c(0,1))
  abline(h=0.5, col=rgb(0,0,0,0.1))
  mtext("Environment", side=1, outer=TRUE)
  mtext("Allele frequency", side=2, outer=TRUE, line=0)
dev.off()

pdf("AFpatternsForManuscript_CIcurves.pdf", width=6, height=3)
  par(mfrow=c(1,1), mar=c(4,4,1,1))
  # CI vs. env
  sequ <- seq(1, length(CI_short), by=3)
  plot(CI_long[[1]]$x, CI_long[[1]]$y, pch=pchs[4], col=cols[7], ylim=c(-0.1,1), ylab="CI", xlab="environment", bty="l")
  for (i in sequ){
    points(CI_long[[i]]$x, CI_long[[i]]$y, pch=pchs[4], col=adjustcolor(cols[7], 0.5), lwd=1)
    points(CI_rev[[i]]$x, CI_rev[[i]]$y, pch=pchs[2], col=adjustcolor(cols[2], 0.5), lwd=1, lty=2)
    points(CI_shallow[[i]]$x, CI_shallow[[i]]$y,  pch=pchs[3], col=adjustcolor(cols[10], 0.5), lty=3, lwd=1)
    points(CI_nonMon[[i]]$x, CI_nonMon[[i]]$y, pch=pchs[1], col=adjustcolor(cols[3], 0.5), lty=1)
  }
  
  legend(-0.95, 1, col=cols[c(7,2,10,3)], legend = c("steep", "reverse", "shallow", "non-monotonic"), pch=pchs[c(4,2,3,1)], bty="n")
dev.off()


```
#  Fourth comparison: A steep cline vs. a non-monotonic cline

## Fourth take home message: The shape of the CI function reflects the pattern of turnover in allele frequency

For this comparison, we assumed equal sampling (15 sites along the cline). We compared the linear cline from the second comparison with a non-monotonic clines from the third comparison.


```{r , fig.width=6, fig.height=12}
par(mar=c(4,4,3,0.4), mfrow=c(3,1))
plot(envPop_long$envPop, alFreq_L1_long, xlab="environment", ylab="allele freq.", col=cols[7], pch=pchs[4], bty="n", main="cline", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.1))

plot(envPop_long$envPop, alFreq_nonMon, xlab="environment", ylab="allele freq.", col=cols[1], pch=pchs[5], bty="n", main="non-monotonic", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.1))

# CI vs. env
sequ <- seq(1, length(CI_nonMon), by=3)
plot(CI_nonMon[[1]]$x, CI_nonMon[[1]]$y, type="l", col=cols[1], ylim=c(-0.1,1), ylab="CI", xlab="environment")
for (i in sequ){
  points(CI_nonMon[[i]]$x, CI_nonMon[[i]]$y, type="l", col=adjustcolor(cols[1], 0.5))
  points(CI_long[[i]]$x, CI_long[[i]]$y, type="l", col=adjustcolor(cols[7], 0.5))
}

legend(-0.8, 1, fill=cols[c(7,1)], legend = c("cline", "non-mon."))
```

The non-monotonic pattern has a flat CI in the intermediate values of the environment that have very little turnover. However, the clinal pattern, which is linear, results in a non-linear CI function. This illustrates a potential problem with interpreting the GF-offset as a genetic offset. For the cline at extreme values of the environment, a very small GF-offset would be calculated, and at intermediate values of the environment, a very large GF-offset would be calculated. However, the actual "genetic offset" (in terms of allele frequency change per unit environment change) is the same at all values of the environment.


# A steep cline vs. more randomness in the cline

## Fifth take home message: The maximum value of the CI function reflects the amount of variation in the data that the model explains.

For this comparison, we assumed equal sampling (15 sites along the cline). We compared the linear cline from the second comparison with the same cline, but random noise added.

```{r}
alFreq_L1_long_error <- alFreq_L1_long + rnorm(length(alFreq_L1_long), 0, 0.1)
alFreq_L1_long_error[alFreq_L1_long_error>1] <- 1
alFreq_L1_long_error[alFreq_L1_long_error<0] <- 0
CI_long_error <- replicate(100,runMod(envPop_long, alFreq_L1_long_error))
CI_long_error_R2 <- (unlist(CI_long_error[seq(3,length(CI_long_error), by=3)]))
```

```{r , fig.width=6, fig.height=6}
par(mar=c(4,4,3,0.4), mfrow=c(3,1))
plot(envPop_long$envPop, alFreq_L1_long, xlab="environment", ylab="allele freq.", col=cols[7], pch=pchs[4], bty="n", main="cline", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.1))

plot(envPop_long$envPop, alFreq_L1_long_error, xlab="environment", ylab="allele freq.", col=cols[3], pch=pchs[1], bty="n", main="cline + noise", ylim=c(0,1))
abline(h=0.5, col=rgb(0,0,0,0.1))

# CI vs. env
sequ <- seq(1, length(CI_long), by=3)
plot(CI_long[[1]]$x, CI_long[[1]]$y, type="l", col=cols[7], ylim=c(-0.1,1), ylab="CI", xlab="environment")
for (i in sequ){
  points(CI_long_error[[i]]$x, CI_long_error[[i]]$y, type="l", col=adjustcolor(cols[3], 0.5))
  points(CI_long[[i]]$x, CI_long[[i]]$y, type="l", col=adjustcolor(cols[7], 0.5))
}

legend(-0.8, 1, fill=cols[c(7,3)], legend = c("cline", "cline + noise"))
```

The above example shows that adding noise (as might occur due to genetic drift) changes the shape of the CI curve, and also lowers the maximum value that can be obtained. That is because the maximum value of the CI for an allele depends on how much variance in the allele frequency as a function of the environment the model can explain. When there is more noise in the data, the model explains less of the variance in allele frequency.

In addtion, we see the "all zeros in the CI despite high R^2" problem again with the noisy data, but it appeared to only happen once (and may not happen when the markdown renders).


```{r, fig.width=6}
sequ <- seq(1, length(CI_short), by=3)
plot(CI_long[[3]], max(CI_long[[1]]$y), col=adjustcolor(cols[7], 0.5), ylim=c(-0.1,1), xlab="R2", ylab="max CI", xlim=c(0,1), pch=pchs[4], main="Adding error")
for (i in sequ){
  points(CI_long[[i+2]], max(CI_long[[i]]$y), col=adjustcolor(cols[7], 0.5), pch=pchs[4])
  points(CI_long_error[[i+2]],max(CI_long_error[[i]]$y),  col=adjustcolor(cols[3], 0.5), pch=pchs[1])
}

legend(0.1, 1, col =cols[c(7,3)], legend = c("cline", "cline + error"), pch=pchs[c(4,1)])
```


# Appendix: Varying the parameters

Here we examine:
(1) varying number of trees and other parameters
(2) varying number of loci and environments


### testing smaller number of trees
The following chunck tests what happens when 50, instead of 500 trees are used in the gradient forest.
```{r}
### 50 trees ####
envPop_short <- data.frame(envPop=seq(-1,1,length.out=6)) #create env
alFreq_L1_short<-seq(0.1,0.9,length.out=6)
CI_short <- replicate(100,runMod(envPop_short, alFreq_L1_short, 50))
(CI_short_prop0 <- sum(unlist(CI_short[seq(2,length(CI_short), by=3)]))/100)
(CI_short_R2 <- (unlist(CI_short[seq(3,length(CI_short), by=3)])))

par(mfrow=c(1,1))
plot(CI_short[[3]], max(CI_short[[1]]$y), col=adjustcolor(cols[1], 0.5), ylim=c(-0.1,1), xlab="R2", ylab="max CI", xlim=c(0,1), pch=pchs[1], main="50 trees, 6 populations on cline")
for (i in sequ){
  points(CI_short[[i+2]], max(CI_short[[i]]$y),  col=adjustcolor(cols[1], 0.5), pch=pchs[1])
}
```
With 50 trees, there is higher variance in the R^2, but fewer replicates randomly have a max CI=0.

### testing larger number of trees
The following chunck tests what happens when 3000, instead of 500 trees are used in the gradient forest.
```{r}
### 3000 Trees
envPop_short <- data.frame(envPop=seq(-1,1,length.out=6)) #create env
alFreq_L1_short<-seq(0.1,0.9,length.out=6)
CI_short <- replicate(100,runMod(envPop_short, alFreq_L1_short, 3000))
(CI_short_prop0 <- sum(unlist(CI_short[seq(2,length(CI_short), by=3)]))/100)
(CI_short_R2 <- (unlist(CI_short[seq(3,length(CI_short), by=3)])))

par(mfrow=c(1,1))
plot(CI_short[[3]], max(CI_short[[1]]$y), col=adjustcolor(cols[1], 0.5), ylim=c(-0.1,1), xlab="R2", ylab="max CI", xlim=c(0,1), pch=pchs[1], main="3000 trees, 6 populations on cline")
for (i in sequ){
  points(CI_short[[i+2]], max(CI_short[[i]]$y),  col=adjustcolor(cols[1], 0.5), pch=pchs[1])
}
```
With 3000 trees, there is lower variance in the R^2, but all replicates have a max CI=0.
That was weird. Moving on.


### testing higher corr threshold
The following chunck tests if different correlation thresholds in the gradient forest affects the output.
```{r}
### Compare the same cline for 10 vs. 50 environment sites ####
envPop_short <- data.frame(envPop=seq(-1,1,length.out=8)) #create env
alFreq_L1_short<-seq(0.1,0.9,length.out=8)
CI_short <- replicate(100,runMod(envPop_short, alFreq_L1_short, 500, 0.9))
print("Proportion of times we get all 0's in the CI with 8 sites, 500 trees, cor threshold 0.9:")
(CI_short_prop0 <- sum(unlist(CI_short[seq(2,length(CI_short), by=3)]))/100)


CI_short <- replicate(100,runMod(envPop_short, alFreq_L1_short, 500, 0.5))
print("Proportion of times we get all 0's in the CI with 8 sites, 500 trees, cor threshold 0.5:")
(CI_short_prop0 <- sum(unlist(CI_short[seq(2,length(CI_short), by=3)]))/100)


CI_short <- replicate(100,runMod(envPop_short, alFreq_L1_short, 500, 0.1))
print("Proportion of times we get all 0's in the CI with 8 sites, 500 trees, cor threshold 0.1:")
(CI_short_prop0 <- sum(unlist(CI_short[seq(2,length(CI_short), by=3)]))/100)


CI_short <- replicate(100,runMod(envPop_short, alFreq_L1_short, 50, 0.1))
print("Proportion of times we get all 0's in the CI with 8 sites, 50 trees, cor threshold 0.1:")
(CI_short_prop0 <- sum(unlist(CI_short[seq(2,length(CI_short), by=3)]))/100)

CI_short <- replicate(100,runMod(envPop_short, alFreq_L1_short, 1000, 0.1))
print("Proportion of times we get all 0's in the CI with 8 sites, 1000 trees, cor threshold 0.1:")
(CI_short_prop0 <- sum(unlist(CI_short[seq(2,length(CI_short), by=3)]))/100)


CI_short <- replicate(100,runMod(envPop_short, alFreq_L1_short, 10, 0.1))
print("Proportion of times we get all 0's in the CI with 8 sites, 10 trees, cor threshold 0.1:")
(CI_short_prop0 <- sum(unlist(CI_short[seq(2,length(CI_short), by=3)]))/100)
(CI_short_R2 <- (unlist(CI_short[seq(3,length(CI_short), by=3)])))

par(mfrow=c(1,1))
plot(CI_short[[3]], max(CI_short[[1]]$y), col=adjustcolor(cols[1], 0.5), ylim=c(-0.1,1), xlab="R2", ylab="max CI", xlim=c(0,1), pch=pchs[1], main="10 trees, 6 pops, threshold 0.1")
for (i in sequ){
  points(CI_short[[i+2]], max(CI_short[[i]]$y),  col=adjustcolor(cols[1], 0.5), pch=pchs[1])
}
```

I'm wondering if this has something to do with the number of trees far exceeding the number of possible splits given only a few samples along a gradient. When the number of requested permutations exceeds the number possible in the data, the result is a large number of identical trees (?). 

I did find that I was getting errors when the number of tress was _less_ then the number of samples in the data.


### testing multiple environmental predictors

Here, I compare two models. The first "univariate" model only includes the true environmental predictor.
The second "multivariate model" includes the true predictor and two random environmental variables.

Each has 15 sites sampled along the true environmental gradient.
```{r, eval=FALSE}
envPop_short <- data.frame(envPop=seq(-1,1,length.out=15),
                           env2 = rnorm(15),
                           env3 = rnorm(15)) #create env
alFreq_L1_short<-seq(0.1,0.9,length.out=15)

uni <- runMod(data.frame(envPop=envPop_short[,1]), alFreq_L1_short)
multi <- runMod_multi(envPop_short, alFreq_L1_short)

print("The univariate model, which only includes the true predictor, has an R^2 of:")
print(uni$R2)

print("The multivariate model, which includes the true predictor and two random predictors, has an R^2 of:")
print(multi$R2)

# How are the CI functions affected by including multiple predictors?
plot(uni$CI$x, uni$CI$y, main="compare univariate (black circ.)\nto multivariate (blue tri.)")
points(multi$CI_env$envPop$x, multi$CI_env$envPop$y, col="blue", pch=2)
```

The above R^2 results make sense. When more random predictors are included, the random forest would choose these sometimes to build the model, and this would lower the overal predictive power of the model compared to a model that only includes the true predictor.

The plot shows that when adding additional random environmental predictors, it affects the total CI of the model for the true environmental predictor. In addition this would affect genetic offset calculations near the environmental extremes.


### Testing multiple loci and one environment
Here we ask, does adding more loci to the model affect the results for one locus? Based on first princples, it should not, because each locus is an independent model.
I created a second allele with frequencies sampled from a beta distribution, and a third allele with frequencies sampled randomly from the first locus. The second allele does not have a positive R^2 in a univariate model, but the third allele does.
Here, I test if the statistics output from the 1-locus-1-environment model are the same as the multi-locus-multi-environment model.
```{r, eval=FALSE}
L1 = seq(0.1,0.9,length.out=15)
L2 = rbeta(15, 1, 1)
set.seed(9126)
L3 = sample(L1)
envPop_short <- data.frame(envPop=seq(-1,1,length.out=15)) #create env
alFreq_L1_short<-data.frame(L1,L2, L3)
# use "uni" model above
uni
# uni_L2 <- runMod(envPop_short, L2) this returns NULL
uni_L3 <- runMod(envPop_short, L3)
uni_L3
uni_L3_2 <- runMod(envPop_short, L3)
uni_L3_2

multi_loc <- runMod_multi(envPop_short, alFreq_L1_short)
multi_loc


plot(uni$CI$y, multi_loc[[5]]$envPop$L1$y, xlab="CI L1 one locus", ylab="CI L1 three locus")
abline(0,1)

plot(uni_L3$CI$y, uni_L3_2$CI$y, xlab="CI L3 one locus", ylab="CI L3 one locus again")
abline(0,1)

plot(uni_L3$CI$y, multi_loc[[5]]$envPop$L3$y[2:43], xlab="CI L3 one locus", ylab="CI L3 three locus")
abline(0,1)

print("The R^2 for L1 from the one-locus model:")
print(uni$R2)
print("The R^2 for L1 from the multi-locus model:")
print(multi_loc$R2[1])

print("The R^2 for L3 from the one-locus model:")
print(uni_L3$R2)
print("The R^2 for L3 from the multi-locus model:")
print(multi_loc$R2[2])
```

The last analysis shows that adding more loci does not affect the CI curves for a single locus, above and beyond what happens from run to run given the randomness in the forest.
