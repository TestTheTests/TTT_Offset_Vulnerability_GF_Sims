require(gradientForest)
#require(gdm)

envPop_L <- data.frame(seq(-1,1,length.out=9))
names(envPop_L) <- "envSelect"

alFreq<-data.frame(seq(0.1,0.9,0.1))
colnames(alFreq)<-"LP"

all_freq_L<-alFreq

alFreq<-data.frame(seq(0.9,0.1,-0.1))
colnames(alFreq)<-"LN"

all_freq_L$LN<-alFreq$LN

all_freq_L$envSelect<-envPop_L$envSelect

envPop_NL <- data.frame(seq(-1,1,length.out=10))
names(envPop_NL) <- "envSelect"

alFreq<-data.frame(c(seq(0.9,0.1,-0.2),seq(0.1,0.9,0.2)))
colnames(alFreq)<-"NLV"

all_freq_NL<- alFreq

alFreq<-data.frame(c(seq(0.1,0.9,0.2),seq(0.9,0.1,-0.2))) 
colnames(alFreq)<-"NLA"

all_freq_NL$NLA<-alFreq$NLA

all_freq_NL$envSelect<-envPop_NL$envSelect

##############################################
# Chunk to fit GF models to minor allele frequencies at the level of
# populations
# GF is fit to each SNP individually to 
# ease computational / memory burden

alFreq <- data.frame(all_freq_NL$NLA)
colnames(alFreq)<-"NLA"
envPop <- envPop_NL

gfMod <- gradientForest(data=data.frame(envPop, alFreq),
                        predictor.vars=colnames(envPop),
                        response.vars=colnames(alFreq),
                        corr.threshold=0.5, 
                        ntree=500, 
                        trace=T)

# Calculate genomic offset
# note that I am doing this for the avearge across all alleles since 
# GF was fit to all alleles simultaneously
# The more correct way is to calculate offset for adaptive alleles only,
# either individually or for a model fit to just those alleles.
gfTrans1 <- predict(gfMod, envPop)
colnames(gfTrans1)<-"C.Imp_genome_before"

#gfTrans1_LP <- gfTrans1
#gfTrans1_LN <- gfTrans1
#gfTrans1_NLV <- gfTrans1
gfTrans1_NLA <- gfTrans1

#gfTrans2 <- predict(gfMod, envPop.shift)
#colnames(gfTrans2)<-"C.Imp_genome_after"

# offset needs to be considered using absolute values ()
#offset <- gfTrans2-gfTrans1
#offset <- gfTrans2-gfTrans1
#colnames(offset)<-"D_C.Imp_genome"


#Visual of linear CI
cols <- c("AF increasing w/ env"="#0000FFBF","AF decreasing w/ env"="#FF0000BF")
ggplot() + 
  geom_line(aes(x=envPop$envSelect, y=gfTrans1_LP$C.Imp_genome_before, colour="AF increasing w/ env"), lwd=1) + #blue
  labs(y="GF Cumulative Importance", x="Environment") +
  geom_line(aes(x=envPop$envSelect, y=gfTrans1_LN$C.Imp_genome_before,colour="AF decreasing w/ env"), lwd=1) + #red
  theme(plot.margin = unit(c(1.25,1.25,1.25,1.25), "in")) +
  theme_bw() +
  scale_colour_manual(name="",values=cols) + 
  ggtitle("Linear relationship between allele frequency (AF) and environment")+
  theme(axis.text.x = element_text(size = 18, colour = "grey60"),
        axis.title.x = element_text(size=24)) +
  theme(axis.text.y = element_text(size = 16, colour = "grey60"),
        axis.title.y = element_text(size=24, vjust=1)) +
  theme(strip.text = element_text(size=16)) +
  theme(plot.title = element_text(size=14, face="bold.italic"))+
  theme(legend.position = "none")

#Visual of non-linear CI
cols <- c("Stabilizing"="#0000FFBF","Disruptive"="#FF0000BF")
ggplot() + 
  geom_line(aes(x=envPop$envSelect, y=gfTrans1_NLA$C.Imp_genome_before, colour="Stabilizing"), lwd=1) + #blue
  labs(y="GF Cumulative Importance", x="Environment") +
  geom_line(aes(x=envPop$envSelect, y=gfTrans1_NLV$C.Imp_genome_before,colour="Disruptive"), lwd=1) + #red
  theme(plot.margin = unit(c(1.25,1.25,1.25,1.25), "in")) +
  theme_bw() +
  scale_colour_manual(name="",values=cols) + 
  ggtitle("Non-linear relationship between allele frequency (AF) and environment")+
  theme(axis.text.x = element_text(size = 18, colour = "grey60"),
        axis.title.x = element_text(size=24)) +
  theme(axis.text.y = element_text(size = 16, colour = "grey60"),
        axis.title.y = element_text(size=24, vjust=1)) +
  theme(strip.text = element_text(size=16)) +
  theme(plot.title = element_text(size=14, face="bold.italic"))+
  theme(legend.position = NULL)


plot(envPop_L$envSelect,all_freq_L$LN,type="l",col="blue", xlab="", ylab="",lwd=4, yaxp  = c(0.1, 0.9, 8), las=1, cex.axis=2)
lines(envPop_L$envSelect,all_freq_L$LP,col="red",lwd=4)

plot(envPop$envSelect,all_freq_NL$NLV,type="l",col="blue", xlab="", ylab="",lwd=4, yaxp  = c(0.1, 0.9, 8), las=1, cex.axis=2)
lines(envPop$envSelect,all_freq_NL$NLA,col="red",lwd=4)
####################################################################

phen_i = seq(0,1,0.1)
phen_opt = 1
s = 1


fit_noCon <- function(phen_i,phen_opt, s){
  w <- exp(-0.5 * ((phen_i - phen_opt)/s)^2)
  return(w)
}

fit_noCon(phen_i, phen_opt, s)

plot(phen_i , fit_noCon(phen_i, phen_opt, s))

c=1
plot(exp((-0.5 * ((phen_i - phen_opt)/s)^2) - ((c/2)*(phen_i/s)^2)))

fit_Con <- function(phen_i,phen_opt, s){
  w <- exp((-0.5 * ((phen_i - phen_opt)/s)^2) - ((c/2)*(phen_i/s)^2))
  return(w)
}

plot(phen_i , fit_Con(phen_i, phen_opt, s))


phen0 <- seq(-1,1,0.1)
phen1 <- seq(-1,1,0.1)

opts <- c(-0.77777,0.5)
#opt0 = opt0 > maxOpt0+0.5 ? 20 else opt0 + RATE;
#opt1 = opt1 > maxOpt1+0.5 ? 20 else opt1 + RATE;

fitness_varcov <- matrix(c(1,0,0,1),nrow=2)

fitness_norm = dmvnorm(c(0, 0), c(0,0), fitness_varcov)

#- (0.5*(floor((phen0+phen1)/2)^2)
dmvnorm(cbind(phen0, phen1), opts, fitness_varcov) / fitness_norm

plot(phen0, dmvnorm(cbind(phen0, phen1), opts, fitness_varcov) / fitness_norm)
plot(phen1, dmvnorm(cbind(phen0, phen1), opts, fitness_varcov) / fitness_norm)


phen0 <- rnorm(100,sd=2) #draw one hundred random phenotypes, with a mean of zero, and a standard deviation of two
phen1 <- rnorm(100,sd=2) #same as above for the second phenotype
fitness_varcov <- matrix(c(1,0,0,1),nrow=2) #fitness variance set at 1, with no covariance
fitness_norm = dmvnorm(c(0, 0), c(0,0), fitness_varcov) #normalization factor for the fitness values (the maximum)

ind<-as.character(1:100) #generate IDs for the individuals posessing these phenotypes

opts <- c(3,3) #set the values of the two optima

fitness <- dmvnorm(cbind(phen0, phen1), opts, fitness_varcov) / fitness_norm #calculate the fitness value for the drawn phenotypes

dat<-data.frame(ind,phen0, phen1, fitness) #combine these variables in a dataframe

dat.m <- melt(dat, c("ind","fitness")) #melt the data frame to allow for easier visualization in ggplot

ggplot(data=dat.m) + 
  geom_point(aes(value, fitness,  col=variable,size=2))+ #plot the fitness values as points that are colored by phenotype
  geom_line(aes(value, fitness, group = ind))+ #draw a line connecting the two phenotypes of each individual
  scale_shape_manual(values=c(15,18,16,17,19,20,21,22,23,25), name="Ind.")+
  ylab("Relative fitness")+
  xlab("Phenotype value")+
  scale_color_discrete(name="")+
  scale_size(guide = 'none')+
  geom_vline(xintercept = c(opts[1], opts[2]),linetype="dashed")+ #draw reference lines for where the optima are
  ggtitle(paste("Without constraint\nOpt0: ", opts[1], ", Opt1: ", opts[2]))+
  xlim(c(-6,6))+
  ylim(c(0,1.0))+
  theme_classic()

fitness <- (dmvnorm(cbind(phen0, phen1), opts, fitness_varcov) / fitness_norm)  * exp(- floor(abs(phen0+phen1)/2)) #alternative fitness function to limit extreme phenotypes
dat<-data.frame(ind,phen0, phen1, fitness) #combine these variables in a dataframe
dat.m <- melt(dat, c("ind","fitness")) #melt the data frame to allow for easier visualization in ggplot

ggplot(data=dat.m) + 
  geom_point(aes(value, fitness,  col=variable,size=2))+ #plot the fitness values as points that are colored by phenotype
  geom_line(aes(value, fitness, group = ind))+ #draw a line connecting the two phenotypes of each individual
  scale_shape_manual(values=c(15,18,16,17,19,20,21,22,23,25), name="Ind.")+
  ylab("Relative fitness")+
  xlab("Phenotype value")+
  scale_color_discrete(name="")+
  scale_size(guide = 'none')+
  geom_vline(xintercept = c(opts[1], opts[2]),linetype="dashed")+ #draw reference lines for where the optima are
  ggtitle(paste("With constraint\nOpt0: ", opts[1], ", Opt1: ", opts[2]))+
  xlim(c(-6,6))+
  ylim(c(0,1.0))+
  theme_classic()
