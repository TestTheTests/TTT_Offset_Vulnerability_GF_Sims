import pyslim, msprime
import numpy as np
import random
import time
import re
import ast
NODE_IS_SAMPLE = np.array(msprime.NODE_IS_SAMPLE, dtype='uint32')

#Time how long it takes to read in file
#start = time.time()
#T2 = pyslim.load("TTT_SP_100_TSR_2248139792466_Gen1600.tree") #10x10 of 100 inds each, r: 10-6
#T2 = pyslim.load("TTT_SP_100_TSR_2249077042518_Gen1600.tree") #Small test file 4x4
start = time.time()
T2 = pyslim.load("TTT_SP_100_TSR_1580816368455_Gen600.tree") #Full file 10x10
end = time.time()
print(end - start)

#Open the migration matrix (generated by SLiM code)
with open('mig_mat.txt') as infile:
    data = infile.read()

#Save migration matrix as 'mig_mat'
mig_mat = []
for i in re.findall(r"(\[.*?\])", data, flags=re.S):
    mig_mat.append(ast.literal_eval(i))

#Time how long it takes to recapitate the TSR file
start = time.time()
recapT2 = T2.recapitate(recombination_rate = 1e-06, migration_matrix=mig_mat, Ne=100,random_seed=1) #Ne is multiplied by the number of populations in the file
end = time.time()
print(end - start)

#Add mutations to the recapitated tree
mutatedT2 = pyslim.SlimTreeSequence(msprime.mutate(recapT2, rate=1e-7, random_seed=1, keep=True))

#Look at the times at which individuals were recorded (in terms of time from end of simulation, i.e. end of simulation is time "0"
set(mutatedT2.individual_times)

#Save individuals at the two time points as a vector
T1ind = mutatedT2.individuals_alive_at(301)
T2ind = mutatedT2.individuals_alive_at(0)

#Get the list of nodes that label the genomes of the saved individuals at each time point
sampled_nodes1 = []
for ind in T1ind:
    sampled_nodes1.extend(mutatedT2.individual(ind).nodes)

sampled_nodes2 = []
for ind in T2ind:
    sampled_nodes2.extend(mutatedT2.individual(ind).nodes)

#Subset the recapitated and mutated TSR file by the individuals at each time point
out_ts1 = mutatedT2.simplify(sampled_nodes1)
out_ts2 = mutatedT2.simplify(sampled_nodes2)

sampled_pop2 = []
for ind in T2ind:
    sampled_pop2.extend(mutatedT2.individual(ind).population)

# Sample the desired invividuals
# Create new sample IDs
num_samples = 1000
sample_names = []
sampled_nodes = []
for pop in sorted(samples_of_pop):
    samples = sorted(np.random.choice(samples_of_pop[pop], num_samples, replace=False))
    for sam in samples:
        sampled_nodes.append(sam)
        new_sam_name = 'msp_{}'.format(sam)
        sample_names.append(new_sam_name)

# Determine all samples that are in a population
samples_of_pop = dict()
for u in nodes:
    pop = ts.node(u).population
    samples_of_pop.setdefault(pop, []).append(u)
    
for pop in sorted(samples_of_pop):
    samples = sorted(np.random.choice(samples_of_pop[pop], num_samples, replace=False))
for sam in samples:
    sampled_nodes.append(sam)
    new_sam_name = 'msp_{}'.format(sam)
    sample_names.append(new_sam_name)


#Write out the genomes of the individuals at each time point as VCF files
with open("T1.vcf", "w") as vcf_file:
    out_ts1.write_vcf(vcf_file,2)

with open("T2.vcf", "w") as vcf_file:
    out_ts2.write_vcf(vcf_file,2)
