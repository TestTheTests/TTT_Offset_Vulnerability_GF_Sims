import pyslim, msprime
import numpy as np
import random
import time
import re
import ast
NODE_IS_SAMPLE = np.array(msprime.NODE_IS_SAMPLE, dtype='uint32')

#T2 = pyslim.load("TTT_SP_100_TSR_2248126903209_Gen1600.tree") #10x10 of 100 inds each, r: 10-5
#T2 = pyslim.load("TTT_SP_100_TSR_2248138456564_Gen1600.tree") #10x10 of 100 inds each, r: 10-7
start = time.time()
T2 = pyslim.load("TTT_SP_100_TSR_2248139792466_Gen1600.tree") #10x10 of 100 inds each, r: 10-6
end = time.time()
print(end - start)

def mark_samples(ts, samples, keep=True):
    '''
        Returns the same tree sequence except with the the nodes listed in `samples`
        marked as samples (keeping existing samples if `keep` is True).
        '''
    if (min(samples) < 0) or (max(samples) >= ts.num_nodes):
        raise ValueError("Illegal samples.")
    tables = ts.dump_tables()
    flags = tables.nodes.flags
    if not keep:
        flags = np.bitwise_or(flags, (~ NODE_IS_SAMPLE))
    flags[samples] = np.bitwise_or(flags[samples], NODE_IS_SAMPLE)
    tables.nodes.set_columns(flags=flags, population=tables.nodes.population,
                             individual=tables.nodes.individual, time=tables.nodes.time,
                             metadata=tables.nodes.metadata,
                             metadata_offset=tables.nodes.metadata_offset)
    ts = tables.tree_sequence()
    return ts

# pull out 10 random individuals from each of the 100 populations
pop_inds = [[] for _ in range(T2.num_populations)]
for ind in T2.individuals():
    pops = [T2.node(n).population for n in ind.nodes]
    for pop in set(pops):
        pop_inds[pop].append(ind.id)

ind_samples = [random.sample(pop, min(len(pop), 10)) for pop in pop_inds]

node_samples = []
samples = []
for pop in ind_samples:
    nodes = []
    for ind in pop:
        nodes.extend(T2.individual(ind).nodes)
    node_samples.append(nodes)
    samples.extend(nodes)

start = time.time()
sub_ts = pyslim.SlimTreeSequence(mark_samples(T2, samples, keep=False))
end = time.time()
print(end - start)

with open('mig_mat.txt') as infile:
    data = infile.read()

mig_mat = []
for i in re.findall(r"(\[.*?\])", data, flags=re.S):
    mig_mat.append(ast.literal_eval(i))

start = time.time()
recapT2 = sub_ts.recapitate(recombination_rate = 1e-06, migration_matrix=mig_mat, Ne=100,random_seed=1)
end = time.time()
print(end - start)

mutatedT2 = pyslim.SlimTreeSequence(msprime.mutate(recapT2, rate=1e-7, random_seed=1, keep=True))

set(mutatedT2.individual_times)

T1ind = mutatedT2.individuals_alive_at(300)
T2ind = mutatedT2.individuals_alive_at(0)

node_samplesT1 = []
samplesT1 = []
node_samplesT2 = []
samplesT2 = []

for ind in T1ind:
    nodes = []
    nodes.extend(mutatedT2.individual(ind).nodes)
    node_samplesT1.append(nodes)
    samplesT1.extend(nodes)

for ind in T2ind:
    nodes = []
    nodes.extend(mutatedT2.individual(ind).nodes)
    node_samplesT2.append(nodes)
    samplesT2.extend(nodes)

subT1_ts = pyslim.SlimTreeSequence(mark_samples(mutatedT2, samplesT1, keep=False))
subT1_ts = pyslim.SlimTreeSequence(mark_samples(mutatedT2, samplesT2, keep=False))

with open("T1.vcf", "w") as vcf_file:
    subT1_ts.write_vcf(vcf_file,2)

with open("T2.vcf", "w") as vcf_file:
    subT2_ts.write_vcf(vcf_file,2)
