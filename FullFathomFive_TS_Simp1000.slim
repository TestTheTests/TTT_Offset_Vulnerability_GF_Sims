initialize() {

defineConstant("s", 0.1); // Selection coefficient for local fitness gradient
defineConstant("d", seq(0,4,1)); // Set of environmental "demes" 
defineConstant("m", 0.05); // Set universal migration rate between populations
defineConstant("n", 1000); // Set universal deme population size

initializeMutationRate(1e-7);

//initializeMutationType("m1", 0.5, "f", 0.0); // Neutral
initializeMutationType("m2", 0.5, "f", 0.0); // Mutation under selection across an environmental gradient, initially neutral

//initializeGenomicElementType("g1", m1, 1); // Majority of genome experiencing only neutral mutations
initializeGenomicElementType("g2", m2, 1); // 10 percent of the mutations in this genomic element will eventually be under selection 

//initializeGenomicElement(g1, 0, 9999); // Generate one exclusively neutral genomic regions

initializeGenomicElement(g2, 10000, 10099); // Generate a single potentially adaptable genomic region, containing 100 nucleotides, on a 10.1 kb chromosome

initializeRecombinationRate(1e-8); // Single recombination rate for entire genome

initializeSex("A"); //Set each population to contain two autosomal sexes that must reproduce to yield next generation

initializeTreeSeq(simplificationRatio=INF);
}

//5 by 5 matrix of populations
1 {
metapopSide = 5; // Number of subpops along one side of the grid, in this case 5
metapopSize = metapopSide * metapopSide; // Create a full 5 by 5 matrix 
for (i in 1:metapopSize)
sim.addSubpop(i, n);
subpops = sim.subpopulations;
for (x in 1:metapopSide)
for (y in 1:metapopSide)
{
destID = (x - 1) + (y - 1) * metapopSide + 1;
destSubpop = subpops[destID - 1];
if (x > 1) // Left to right
destSubpop.setMigrationRates(destID - 1, m);
if (x < metapopSide) // Right to left
destSubpop.setMigrationRates(destID + 1, m);
if (y > 1) // Top to bottom
destSubpop.setMigrationRates(destID - metapopSide, m);
if (y < metapopSide) // Bottom to top
destSubpop.setMigrationRates(destID + metapopSide, m);
}
}

//Set fitness for each population based on 5x5 grid. Fitness based on x*(s/2)+(1-s), where s=0.1 and d=seq(0,4,1)

fitness(m2,p1) {return d[0]*(s/2)+(1-s);}
fitness(m2,p6) {return d[0]*(s/2)+(1-s);}
fitness(m2,p11) {return d[0]*(s/2)+(1-s);}
fitness(m2,p16) {return d[0]*(s/2)+(1-s);}
fitness(m2,p21) {return d[0]*(s/2)+(1-s);}

fitness(m2,p2) {return d[1]*(s/2)+(1-s);}
fitness(m2,p7) {return d[1]*(s/2)+(1-s);}
fitness(m2,p12) {return d[1]*(s/2)+(1-s);}
fitness(m2,p17) {return d[1]*(s/2)+(1-s);}
fitness(m2,p22) {return d[1]*(s/2)+(1-s);}

fitness(m2,p3) {return d[2]*(s/2)+(1-s);}
fitness(m2,p8) {return d[2]*(s/2)+(1-s);}
fitness(m2,p13) {return d[2]*(s/2)+(1-s);}
fitness(m2,p18) {return d[2]*(s/2)+(1-s);}
fitness(m2,p23) {return d[2]*(s/2)+(1-s);}

fitness(m2,p4) {return d[3]*(s/2)+(1-s);}
fitness(m2,p9) {return d[3]*(s/2)+(1-s);}
fitness(m2,p14) {return d[3]*(s/2)+(1-s);}
fitness(m2,p19) {return d[3]*(s/2)+(1-s);}
fitness(m2,p24) {return d[3]*(s/2)+(1-s);}

fitness(m2,p5) {return d[4]*(s/2)+(1-s);}
fitness(m2,p10) {return d[4]*(s/2)+(1-s);}
fitness(m2,p15) {return d[4]*(s/2)+(1-s);}
fitness(m2,p20) {return d[4]*(s/2)+(1-s);}
fitness(m2,p25) {return d[4]*(s/2)+(1-s);}

1:15000 {
if (sim.generation%1000==0)
sim.treeSeqSimplify();
}

15000 late() { sim.treeSeqOutput("FFF_TS_Simp1000.trees"); }
