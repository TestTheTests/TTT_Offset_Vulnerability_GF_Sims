\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\
\\ File      : FullFathomFive_nWF.slim
\\ History : 2018/10/19  Created by Áki Jarl Láruson (AJL), modified by Ben Haller (BCH)
\\        
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\
\\ This script codes for a 5 by 5 interconnected population matrix with non Wright-Fisher dynamics, experiencing a temporal shift in selection pressure.
\\ 
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

initialize() {
	initializeSLiMModelType("nonWF");
	
	defineConstant("K", 1000);	// carrying capacity
	defineConstant("N", 25); // number of subpopulations
	defineConstant("s", 0.1); // Selection coefficient for local fitness gradient
	defineConstant("d", seq(0,4,1)); // Set of environmental "demes" 
	defineConstant("m", 0.05); // Set universal migration rate between populations
	defineConstant("n", 1000); // Set universal deme population size
	defineConstant("e",0.00001);	// BCH: I found that e has to be extremely small to avoid extinction, because the reproduction rate is so extremely low; if e is too high, the population simply can't reproduce fast enough to keep up with the individuals being taken out by these extinction events, especially given the low migration rate as well.
	
	initializeMutationRate(1e-7);
	
	initializeMutationType("m1", 0.5, "f", 0.0); // Neutral
	initializeMutationType("m2", 0.5, "e", 0.0); // Mutation under selection across an environmental gradient, initially neutral
	
	m1.convertToSubstitution = T; //Allow fixed neutral mutations to be replaced
	m2.convertToSubstitution = F; //Keep fixed mutations that affect fitness
	
	initializeGenomicElementType("g1", m1, 1); // Majority of genome experiencing only neutral mutations
	initializeGenomicElementType("g2", c(m1,m2), c(0.999,0.001)); // One thousanth of the genome in which a mutation under selection will eventually rise
	
	for (index in 0:9)
		initializeGenomicElement(g1, index*1000, index*1000 + 999); // Generate ten exclusively neutral genomic regions, each with 1,000 nucleotides
	
	initializeGenomicElement(g2, 10000, 10099); // Generate a single potentially adaptable genomic region, containing 100 nucleotides
	
	initializeRecombinationRate(1e-8); // Single recombination rate for entire genome
	
	initializeSex("A"); //Set each population to contain two autosomal sexes that must reproduce to yield next generation
}

reproduction(NULL, "F") {
	if (runif(1) < 0.005)
	{
		mate = subpop.sampleIndividuals(1, sex="M");
		subpop.addCrossed(individual, mate);
	}
}

1 early() {
	for (i in 1:N)
		sim.addSubpop(i, n);
}

early() {
	// random migration
	metapopSide = 5; // Number of subpops along one side of the grid, in this case 5
	metapopSize = metapopSide * metapopSide; // Create a full 5 by 5 matrix 
	nIndividuals = sum(sim.subpopulations.individualCount);
	nMigrants = rbinom(1, nIndividuals, m);
	//catn(nMigrants + " migrants:");
	
	migrants = sample(sim.subpopulations.individuals, nMigrants);
	subpops = sim.subpopulations;
	
	// BCH: move all the migrants.  Note that subpops at the corners/sides of the grid will *lose* just as many migrants as subpops in the middle, but will *gain* fewer, so their equilibrium subpop size will be smaller than in the middle.This is an emergent behavior caused by the edge effects.
	for (migrant in migrants)
	{
		// figure out where in the grid the migrant currently is
		migrantSubpopID = migrant.subpopulation.id;
		migrantX = integerDiv(migrantSubpopID - 1, 5);
		migrantY = integerMod(migrantSubpopID - 1, 5);
		
		// choose a new position that is adjacent, different, and legal
		do {
			newX = migrantX + rdunif(1, -1, 1);
			newY = migrantY + rdunif(1, -1, 1);
		} while (((newX == migrantX) & (newY == migrantY)) | (newX < 0) | (newX > 4) | (newY < 0) | (newY > 4));
		
		// find the new subpop and move the migrant
		newSubpopID = newX * 5 + newY + 1;
		newSubpop = subpops[subpops.id == newSubpopID];
		newSubpop.takeMigrants(migrant);
		//catn("   migrating from " + migrantSubpopID + " (" + migrantX + ", " + migrantY + ") to " + newSubpopID + " (" + newX + ", " + newY + ")");
	}
	
	// density-dependence and random extinctions	
	for (subpop in sim.subpopulations)
	{
		if (runif(1) < e)
			subpop.fitnessScaling = 0.0;
		else
			subpop.fitnessScaling = K / subpop.individualCount;
		
		//catn(sim.generation + ": " + subpop.fitnessScaling);
	}
}

late() {
	if (sum(sim.subpopulations.individualCount) == 0)
		stop("Global extinction in generation " + sim.generation + ".");
}


//Set fitness for each population based on 5x5 grid. Fitness based on x*((2*x)/4)+(1-s), where s=0.1 and d=seq(0,4,1)

4000:20000 fitness(m2,p1) {return d[0]*((2*d[0])/4)+(1-s);}
4000:20000 fitness(m2,p6) {return d[0]*((2*d[0])/4)+(1-s);}
4000:20000 fitness(m2,p11) {return d[0]*((2*d[0])/4)+(1-s);}
4000:20000 fitness(m2,p16) {return d[0]*((2*d[0])/4)+(1-s);}
4000:20000 fitness(m2,p21) {return d[0]*((2*d[0])/4)+(1-s);}

4000:20000 fitness(m2,p2) {return d[1]*((2*d[1])/4)+(1-s);}
4000:20000 fitness(m2,p7) {return d[1]*((2*d[1])/4)+(1-s);}
4000:20000 fitness(m2,p12) {return d[1]*((2*d[1])/4)+(1-s);}
4000:20000 fitness(m2,p17) {return d[1]*((2*d[1])/4)+(1-s);}
4000:20000 fitness(m2,p22) {return d[1]*((2*d[1])/4)+(1-s);}

4000:20000 fitness(m2,p3) {return d[2]*((2*d[2])/4)+(1-s);}
4000:20000 fitness(m2,p8) {return d[2]*((2*d[2])/4)+(1-s);}
4000:20000 fitness(m2,p13) {return d[2]*((2*d[2])/4)+(1-s);}
4000:20000 fitness(m2,p18) {return d[2]*((2*d[2])/4)+(1-s);}
4000:20000 fitness(m2,p23) {return d[2]*((2*d[2])/4)+(1-s);}

4000:20000 fitness(m2,p4) {return d[3]*((2*d[3])/4)+(1-s);}
4000:20000 fitness(m2,p9) {return d[3]*((2*d[3])/4)+(1-s);}
4000:20000 fitness(m2,p14) {return d[3]*((2*d[3])/4)+(1-s);}
4000:20000 fitness(m2,p19) {return d[3]*((2*d[3])/4)+(1-s);}
4000:20000 fitness(m2,p24) {return d[3]*((2*d[3])/4)+(1-s);}

4000:20000 fitness(m2,p5) {return d[4]*((2*d[4])/4)+(1-s);}
4000:20000 fitness(m2,p10) {return d[4]*((2*d[4])/4)+(1-s);}
4000:20000 fitness(m2,p15) {return d[4]*((2*d[4])/4)+(1-s);}
4000:20000 fitness(m2,p20) {return d[4]*((2*d[4])/4)+(1-s);}
4000:20000 fitness(m2,p25) {return d[4]*((2*d[4])/4)+(1-s);}


20000 late() {
	allIndividuals = sim.subpopulations.individuals;
	allIndividuals.genomes.outputVCF(filePath = "FFFnwf.vcf");
}
