## Multilocus model comments

__Multilocus model proposition from Ben__:
 Instead of setting mutation effect sizes and phenotypes as values associated with each mutation/individual respectively, draw the selection coefficient for each mutation from a normal distribution then tally up the selection coefficients to get the phenotype. The fitness of each mutation is fixed at 1.0 so the selection coefficient has no direct effect on fitness, instead fitness is calculated from the quantile at which the phenotype falls on a normal distribution set at an average which is the environmental optimum at that x-coordinate. 

__Multilocus model currently implemented__:
Currently we have it set up so that each mutation simultaneously has an effect on two phenotypes (phen0 and phen1), and the 
 phenotypes are tallied from the sum of these respective effects. This allows each mutation to have an epistatic effect on the two measurable phenotypes, who contribute a combined fitnesses value based on where phen0 falls on the x-coordinate and where phen1 falls on the y-coordinate. 

This way of assessing fitness currently seems the better option as it allows us more control over different effects of each mutation, as opposed to being limited to a single effect value.

<br/>
### 2020/03/27

Current summaries that are coming out of the multilocus simulation:
File: seed_Freq_ML_WF.txt output files 
m	| n	| u	| r	| mean_Eff	| var_Eff	| var_Opt	| Env_rate	| Burnin	| Env_shift	| Generation	| P#_fit | P#_freq | P#_phen0 | P#_phen1 | P#_env0 | P#_env1
---	| ---	| ---	| ---	| ---	| ---	| ---	| ---	| ---	| ---	| ---	| ---	| ---	| ---	| ---	| ---	| ---	 
0.01	| 100	| 2E-09	| 1E-05	| 0	| 0.01	| 0.75	| 0.01	| 500	| 1000	| 11	| 0.999867	| ---	| ---	| ---	| ---	| ---	| ---
0.01	| 100	| 2E-09	| 1E-05	| 0	| 0.01	| 0.75	| 0.01	| 500	| 1000	| 21	| 0.99951| ---	| ---	| ---	| ---	| ---	| ---
0.01	| 100	| 2E-09	| 1E-05	| 0	| 0.01	| 0.75	| 0.01	| 500	| 1000	| 31	| 0.998981| ---	| ---	| ---	| ---	| ---	| ---
 
File: seed_ML_WF_CG_sum_Gen.txt
generation | sympatry | allopatry | local_adaptation | mean_pheno0 | mean_pheno1 | corr_pheno0_opt0 | corr_pheno1_opt1 
 ---	| ---	| ---	| ---	| ---	| ---	| ---	| ---
11 | 0.999898 | 0.9999 | -2.34075e-06 | -1.3578e-05 | 0.000160508 | -0.206071 | -0.0339769
21 | 0.999738 | 0.999742 | -4.06078e-06 | -0.000411798 | 6.2371e-05 | -0.139279 | 0.0267145
31 | 0.999467 | 0.999472 | -4.36944e-06 | -1.79996e-05 | -0.000639966 | -0.130915 | 0.0521416


<br/>
### 2020/04/08

Implementing Katie's code to have the multilocus model have two distinct burnin periods.

First burn-in: A thousand generation were both optima are at "0" and the selection function variance is very large (e.g. 4). This allows for a good long accumulation period of variants prior to becoming selected.
```
if (sim.generation < BURNIN_1)
		{
			opt0 = 0;
			opt1 = 0;
			fitness_var = SIGMA_STAT;
		}
```
Second burn-in: A thousand generation run following the first burnin, where both optima start to shift towards their respective terminal states, with a selection variance slowly growing smaller (selection becomes stronger).

```
if (sim.generation > BURNIN_1 & sim.generation < BURNIN_2)  //Changed this line here to have two conditions
		{
			opt0 = opt0 * ((sim.generation - BURNIN_1) / (BURNIN_2 - BURNIN_1));
			opt1 = opt1 * ((sim.generation - BURNIN_1) / (BURNIN_2 - BURNIN_1));
			fitness_var = SIGMA_K * ((sim.generation- BURNIN_1) / (BURNIN_2 - BURNIN_1)) + SIGMA_STAT * (1.0 - (sim.generation- BURNIN_1) / (BURNIN_2 - BURNIN_1));
```
After these two burn in periods, we should have accumulated a good deal of standing variation, and potentially some level of standing variation, but we need to check that down the road.

Output for the multilocus model has been updated to contain the following:

File: seed_ML_WF_CG_sum_Gen.txt - population level summaries of the Common Garden output.
Columns:
generation | sympatry | allopatry | local_adaptation | mean_pheno0 | mean_pheno1 | corr_pheno0_opt0 | corr_pheno1_opt1 
 ---	| ---	| ---	| ---	| ---	| ---	| ---	| ---
 
File: seed_fitnessmat_pop.txt - the full population common garden fitness matrix, output right before climate change

File: seed_fitnessmat_ind.txt - the full _individual_ common garden fitness matrix, output right before climate change

File: seed_T1_Pos_ML_WF_CG_sum_Gen.txt - IDs and Positions of all mutations in the simulation right before climate change 

File: seed_T2_Pos_ML_WF_CG_sum_Gen.txt - IDs and Positions of all mutations in the simulation at the end of the simulation

File: seed_muts.txt - Each mutation, with it's minor allele frequency, correlation to each optima, and each effect size. Output right before climate change.
Columns:
mutID | MAF | cor_opt0 | cor_opt1 | mut_e0 | mutt_e1 
 ---	| ---	| ---	| ---	| ---	| ---	
 
File: ind.txt - Each individual, with an individual ID (0-10,000), their SLiM pedigreeID, source subpopulation, both their phenotypes, both optima, and their fitness. Output right before climate change.
Columns:
indID | pedigreeID | subpop | phen0 | phen1 | opt0 | opt1 | fitness 
 ---	| ---	| ---	| ---	| ---	| --- | --- | ---
 
File: seed_Freq_ML_WF.txt output files - Subpopulation summaries output every 100 generations (includes basic simulation details as well). Outputs migration rate, subpopulation size, QTL mutation rate, recombination rate, mean QTL effect, variance in QTL effect, variance in fitness effect, rate of climate change, end generation of first burn in, end generation of second burn in, generation in which climate change begins, total number of generations in the simulation, the average fitness, number of causal alleles, mean phenotype0, mean phenotype1, scaled opt0, and scaled opt1.
Columns:
m	| n	| u	| r	| mean_Eff	| var_Eff	| var_Opt	| Env_rate	| Burnin	| Env_shift	| Generation	| P#_fit | P#_freq | P#_phen0 | P#_phen1 | P#_env0 | P#_env1
 ---	| ---	| ---	| ---	| ---	| --- | --- | --- |---	| ---	| ---	| ---	| ---	| --- | --- | --- | ---

File: seed_migmat.txt - Migration matrix for the pyslim/msprime recapitation

File: seed_ML_WF_GenFINAL_GEN.tree - The tree sequence recorded file, the final output file from the simulation
