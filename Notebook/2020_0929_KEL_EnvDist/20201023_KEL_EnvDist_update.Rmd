---
title: "Untitled"
author: "KE Lotterhos"
date: "10/23/2020"
output:
  html_document: default
  pdf_document: default
---

This is an update since the 9/28 post, which used standardized environments. In our last meeting, Matt said not to use the standardized environments. So this update does not standardize the environments.

Also update on Home vs. Transplant language.

setwd("/Users/lotterhos/Documents/GitHub/TTT_Offset_Vulnerability_GF_Sims/Notebook/2020_0929_KEL_EnvDist")

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
#install.packages("clusterGeneration")
library(clusterGeneration)
```

## Calculating environment distances

1) Create fake environments

* Correlated with Env 1 (~0.5)
* Correlated with Env 2 (~0.5)
* Random environments with mean 0 and sd 1

2) Make sure each environment is standardized by subracting the mean and dividing by the sd. (This should also be true for what is being put into GF)

3) Calculate the following between all populations (although technically, only needed for core and edge populations):

* Euclidean distance for selective environments
* Mahalanobis distance for selective environments
* Euclidean distance for ALL environments
* Mahalanobis distance for ALL environments


```{r load files}
CGfit <- read.csv("Common_Garden_fit.csv")
Popsenv <- read.csv("Pops_env.csv")

head(CGfit)
head(Popsenv)
```

## Create fake environments

Here I am going to create 2 fake environments, each correlated about 0.5 with the selective environment.

In addition, I am going to create 10 more fake environments with a multivariate normal distribution. The covariance matrix for the mvnorm was generated with a positive definite matrix/covariance matrix using the `genPositiveDefMat` function from the 
`clusterGeneration` package v1.3.4, using the `unifcorrmat` option. This generates the covariance matrix by sampling the correlation among variables from a uniform distribution.
https://www.rdocumentation.org/packages/clusterGeneration/versions/1.3.4/topics/genPositiveDefMat
```{r create fake env}
set.seed(21313)
fakeEnv1 <- Popsenv$envPop1 + rnorm(nrow(Popsenv),0,1.3)
  # this standard deviation generally produces a correlation between 0.3 and 0.6
cor(Popsenv$envPop1, fakeEnv1)

set.seed(21314)
fakeEnv2 <- Popsenv$envPop2 + rnorm(nrow(Popsenv),0,1.3)
  # this standard deviation generally produces a correlation between 0.3 and 0.6
cor(Popsenv$envPop2, fakeEnv2)

Popsenv$fakeEnv1 <- fakeEnv1
Popsenv$fakeEnv2 <- fakeEnv2
dim(Popsenv)

nfake <- 10
Popsenv[,6:(5+nfake)] <- NA
head(Popsenv)

# All I'm doing here is creating environments with a covariance structure
#cov1 <- genPositiveDefMat(nfake, covMethod="eigen", rangeVar=c(1,10))
cov1 <- genPositiveDefMat(nfake,covMethod="unifcorrmat" )
head(cov1)

a<- mvrnorm(nrow(Popsenv),mu=rep(0, nfake), Sigma=cov1$Sigma)

Popsenv[,6:(5+nfake)] <- a
head(Popsenv)
tail(Popsenv)

sel_env_cols <- 2:3
all_env_cols <- 2:ncol(Popsenv)
sel_env_cols_plus2 <- 2:5
```

Heatmap of envi correlation
```{r}
heatmap(cor(Popsenv[all_env_cols]))
```

## Understand CG fit

From Aki: HOME is where the individual originally came from, TRANSPLANT is the location of the common garden

`D_CI` is GF_offset_genome?

`D_CI_sel` is GF_offset for the causal loci?
```{r}
head(CGfit)
```

## Understanding Mahalanobis
?mahalanobis
We are interested in calculating the Mahalanobis distance between pop1 and pop2, while controlling for the covariance among the environmental variables in the population

Let's look at an example where we take the Md between population 1 and population 50, for all the environments
```{r}
(envpop1 <- Popsenv[1,all_env_cols]) # The common garden environment

(envpop2 <- Popsenv[50,all_env_cols]) # The origin environment of the population/individual

# We calculate the covariance based on the entire landscape:
cov_allEnv <- cov(Popsenv[,all_env_cols])
round(cov_allEnv,2)

mahalanobis(as.numeric(envpop1), 
            as.numeric(envpop2), 
            cov_allEnv)
  # This will have to be calculated in a for loop for each individual pairwise comparison

# sanity check (should be 0)
mahalanobis(as.numeric(envpop1), 
            as.numeric(envpop1), 
            cov_allEnv)

#compare to eucl.
dist(rbind(envpop1, envpop2))
```

## Calculate environment distances
```{r calc envi dist}

cov_allEnv <- cov(Popsenv[,all_env_cols])
cov_selEnv <- cov(Popsenv[,sel_env_cols])
cov_selEnv_plus2 <- cov(Popsenv[,sel_env_cols_plus2])

head(Popsenv)

CGfit$EdSelEnv <- NA
  # Euclidean distance for selective environments

CGfit$MdSelEnv <- NA
  # Mahalanobis distance for selective environments

CGfit$EdAllEnv <- NA
  # Euclidean distance for ALL environments

CGfit$MdAllEnv <- NA
  # Mahalanobis distance for ALL environments

CGfit$MdSelEnvPlus2 <- NA
  # Mahalanobis distance for Selective environments and 2 correlated environments

CGfit$EdSelEnvPlus2 <- NA
  # Euclidean distance for Selective environments and 2 correlated environments

head(CGfit)

for (i in 1:nrow(CGfit)){
  # get the row in PopsenvStnd for the common garden genotype
  row1 = which(Popsenv==gsub("T","P",as.character(CGfit$Transplant[i])))
    # get the row in PopsenvStnd for the genotype source
  row2 = which(Popsenv==gsub("H","P",as.character(CGfit$Home[i])))
  
  # Look up the envi (all var)
  (envpop1_all <- Popsenv[row1,all_env_cols])
  (envpop2_all <- Popsenv[row2,all_env_cols])
  
  # Look up the envi selected only
  (envpop1_sel <- Popsenv[row1,sel_env_cols])
  (envpop2_sel <- Popsenv[row2,sel_env_cols])
  
  # Look up the envi selected plus 2 correlated env
  (envpop1_sel_plus2 <- Popsenv[row1,sel_env_cols_plus2])
  (envpop2_sel_plus2 <- Popsenv[row2,sel_env_cols_plus2])  
  
  
  ### Calculate the environmental distance between the two rows
  
  # Euclidean distance for selective environments
  CGfit$EdSelEnv[i] <- dist(rbind(envpop1_sel,
                                  envpop2_sel))
 
  # Mahalanobis distance for selective environments
  CGfit$MdSelEnv[i] <- mahalanobis(as.numeric(envpop1_sel), 
            as.numeric(envpop2_sel), 
            cov_selEnv)
  
  # Euclidean distance for ALL environments
  CGfit$EdAllEnv[i] <- dist(rbind(envpop1_all,
                                  envpop2_all))
  
  # Mahalanobis distance for ALL environments
  CGfit$MdAllEnv[i] <- mahalanobis(as.numeric(envpop1_all), 
            as.numeric(envpop2_all), 
            cov_allEnv)
  
  # Euclidean distance for selective environments + 2 env
  CGfit$EdSelEnvPlus2[i] <- dist(rbind(envpop1_sel_plus2,
                                  envpop2_sel_plus2))
 
  # Mahalanobis distance for selective environments + 2 env
  CGfit$MdSelEnvPlus2[i] <- mahalanobis(as.numeric(envpop1_sel_plus2), 
            as.numeric(envpop2_sel_plus2), 
            cov_selEnv_plus2) 
}
# this take a few minutes
```


## Compare correlations between fitness and different environmental distances
```{r check results}
head(CGfit)

#any missing data?
sum(!complete.cases(CGfit))
# should be 0

par(mar=c(4,4,1,1), mfrow=c(3,2), oma=c(0,0,3,0))

#plot(CGfit$Fitness[CGfit$Home=="H1"]~
#       CGfit$D_CI[CGfit$Home=="H1"])

CGsite = "T1"

## Only selective environments
plot(CGfit$Fitness[CGfit$Transplant==CGsite]~
       CGfit$EdSelEnv[CGfit$Transplant==CGsite], 
     ylab="fitness", xlab="Euclidean Sel Env")

mtext(paste("Common Garden Site", CGsite), outer=TRUE, side=3)

plot(CGfit$Fitness[CGfit$Transplant==CGsite]~
       CGfit$MdSelEnv[CGfit$Transplant==CGsite], 
     ylab="fitness", xlab="Md Sel Env")

## Only selective environments + 2
plot(CGfit$Fitness[CGfit$Transplant==CGsite]~
       CGfit$EdSelEnvPlus2[CGfit$Transplant==CGsite], 
     ylab="fitness", xlab="Euclidean Sel Env + 2")
(cor(CGfit$Fitness[CGfit$Transplant==CGsite],
     CGfit$EdSelEnvPlus2[CGfit$Transplant==CGsite]))

plot(CGfit$Fitness[CGfit$Transplant==CGsite]~
       CGfit$MdSelEnvPlus2[CGfit$Transplant==CGsite], 
     ylab="fitness", xlab="Md Sel Env + 2")
(cor(CGfit$Fitness[CGfit$Transplant==CGsite],
     CGfit$MdSelEnvPlus2[CGfit$Transplant==CGsite]))


## All Environments
plot(CGfit$Fitness[CGfit$Transplant==CGsite]~
       CGfit$EdAllEnv[CGfit$Transplant==CGsite], 
     ylab="fitness", xlab="Euclid All Env")
abline(lm(CGfit$Fitness[CGfit$Transplant==CGsite]~
            CGfit$EdAllEnv[CGfit$Transplant==CGsite]))
(cor(CGfit$Fitness[CGfit$Transplant==CGsite],
     CGfit$EdAllEnv[CGfit$Transplant==CGsite]))

plot(CGfit$Fitness[CGfit$Transplant==CGsite]~
       CGfit$MdAllEnv[CGfit$Transplant==CGsite], 
     ylab="fitness", xlab="Md All Env")
abline(lm(CGfit$Fitness[CGfit$Transplant==CGsite]~
            CGfit$MdAllEnv[CGfit$Transplant==CGsite]))
cor(CGfit$Fitness[CGfit$Transplant==CGsite],
    CGfit$MdAllEnv[CGfit$Transplant==CGsite])
```

## Note: If we standardize the environments to have an SD=1 prior to analysis, results for Euclidean Dist and Mahalanobis are similar because we 

Some notes:

When I first started, I had 2 fake environments (each correlated with one of the selective environments) and 1 random fake environment. This decreased the correlation between EdAllEnv and Fitness, but only slightly (cor ~ -0.8)

Then, I increased it to 10 random fake environments (with no correlation structure), which decreased it more (cor ~ -0.5)

Then, I added covariance structure to the environments, which decreased it more (cor ~ -0.35)

I think we should use the type of environmental data that I generated here, because it retains some realism that is present in empirical data



