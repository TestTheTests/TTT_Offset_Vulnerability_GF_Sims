---
title: "Untitled"
author: "KE Lotterhos"
date: "9/18/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Calculating environment distances

1) Create 3 fake environments

* Correlated with Env 1 (~0.5)
* Correlated with Env 2 (~0.5)
* A random environment with mean 0 and sd 1

2) Make sure each environment is standardized by subracting the mean and dividing by the sd. (This should also be true for what is being put into GF)

3) Calculate the following between all populations (although technically, only needed for core and edge populations):

* Euclidean distance for selective environments
* Mahalanobis distance for selective environments
* Euclidean distance for ALL environments
* Mahalanobis distance for ALL environments


```{r load files}
CGfit <- read.csv("Common_Garden_fit.csv")
Popsenv <- read.csv("Pops_env.csv")

head(CGfit)
head(Popsenv)
```

## Create fake environments

```{r create fake env}
fakeEnv1 <- Popsenv$envPop1 + rnorm(nrow(Popsenv),0,1.3)
  # this standard deviation generally produces a correlation between 0.3 and 0.6
cor(Popsenv$envPop1, fakeEnv1)

fakeEnv2 <- Popsenv$envPop2 + rnorm(nrow(Popsenv),0,1.3)
  # this standard deviation generally produces a correlation between 0.3 and 0.6
cor(Popsenv$envPop2, fakeEnv2)

fakeEnv3 <- rnorm(nrow(Popsenv),0,1)

Popsenv$fakeEnv1 <- fakeEnv1
Popsenv$fakeEnv2 <- fakeEnv2
Popsenv$fakeEnv3 <- fakeEnv3
```

## Standardize environments

```{r stndz envi}
head(Popsenv)
means <- colMeans(Popsenv[2:6])
  # beware of hard coding columns here
sds <- apply(Popsenv[2:6], 2, sd)

PopsenvStnd <- Popsenv
for (i in 2:6){
  PopsenvStnd[,i] <- (Popsenv[,i] - means[i-1])/sds[i-1]
}
head(PopsenvStnd)

# Check for mistakes
round(colMeans(PopsenvStnd[2:6]))
round(apply(PopsenvStnd[2:6], 2, sd))
```

## Understand CG fit
In this dataframe, it appears `Home` is the site of the common garden. 
`Transplant` is the location that the genotype came from
`Fitness` is the average fitness of the individuals from the source location

`D_CI` is GF_offset_genome

`D_CI_sel` is GF_offset for the causal loci
```{r}
head(CGfit)
```

## Understanding Mahalanobis
?mahalanobis
We are interested in calculating the Mahalanobis distance between pop1 and pop2, while controlling for the covariance among the environmental variables in the population

Let's look at an example where we take the Md between population 1 and population 50, for all the environments
```{r}
(envpop1 <- PopsenvStnd[1,2:6])
(envpop2 <- PopsenvStnd[50,2:6])

# We calculate the covariance based on the entire landscape:
cov_allEnv <- cov(PopsenvStnd[,2:6])
round(cov_allEnv,2)

mahalanobis(as.numeric(envpop1), 
            as.numeric(envpop2), 
            cov_allEnv)

# sanity check
mahalanobis(as.numeric(envpop1), 
            as.numeric(envpop1), 
            cov_allEnv)

#compare to eucl.
dist(rbind(envpop1, envpop2))
```

## Calculate environment distances
```{r calc envi dist}

cov_allEnv <- cov(PopsenvStnd[,2:6])
cov_selEnv <- cov(PopsenvStnd[,2:3])
  # BEWARE HARD CODING HERE for selective envis.

head(PopsenvStnd)

CGfit$EdSelEnv <- NA
  # Euclidean distance for selective environments

CGfit$MdSelEnv <- NA
  # Mahalanobis distance for selective environments

CGfit$EdAllEnv <- NA
  # Euclidean distance for ALL environments

CGfit$MdAllEnv <- NA
  # Mahalanobis distance for ALL environments

head(CGfit)

for (i in 1:nrow(CGfit)){
  # get the row in PopsenvStnd for the transplant genotype
  row1 = which(PopsenvStnd==gsub("T","P",as.character(CGfit$Transplant[i])))
    # get the row in PopsenvStnd for the common garden location
  row2 = which(PopsenvStnd==gsub("H","P",as.character(CGfit$Home[i])))
  
  # Look up the envi
  (envpop1_all <- PopsenvStnd[row1,2:6])
  (envpop2_all <- PopsenvStnd[row2,2:6])
  # Look up the envi
  (envpop1_sel <- PopsenvStnd[row1,2:3])
  (envpop2_sel <- PopsenvStnd[row2,2:3])
  # BEWARE HARD CODING
  
  
  ### Calculate the environmental distance between the two rows
  
  CGfit$EdSelEnv[i] <- dist(rbind(envpop1_sel,
                                  envpop2_sel))
  # Euclidean distance for selective environments

  CGfit$MdSelEnv[i] <- mahalanobis(as.numeric(envpop1_sel), 
            as.numeric(envpop2_sel), 
            cov_selEnv)
  # Mahalanobis distance for selective environments

  CGfit$EdAllEnv[i] <- dist(rbind(envpop1_all,
                                  envpop2_all))
  # Euclidean distance for ALL environments

  CGfit$MdAllEnv[i] <- mahalanobis(as.numeric(envpop1_all), 
            as.numeric(envpop2_all), 
            cov_allEnv)
  # Mahalanobis distance for ALL environments
}
```


## Calculate environment distances
```{r check results}
head(CGfit)

#any missing data?
sum(!complete.cases(CGfit))
# should be 0

plot(CGfit$Fitness[CGfit$Home=="H1"]~
       CGfit$D_CI[CGfit$Home=="H1"])

plot(CGfit$Fitness[CGfit$Home=="H1"]~
       CGfit$EdSelEnv[CGfit$Home=="H1"])

plot(CGfit$Fitness[CGfit$Home=="H1"]~
       CGfit$MdSelEnv[CGfit$Home=="H1"])

plot(CGfit$Fitness[CGfit$Home=="H1"]~
       CGfit$EdAllEnv[CGfit$Home=="H1"])
abline(lm(CGfit$Fitness[CGfit$Home=="H1"]~
            CGfit$EdAllEnv[CGfit$Home=="H1"]))
(cor(CGfit$Fitness[CGfit$Home=="H1"],
     CGfit$EdAllEnv[CGfit$Home=="H1"]))

plot(CGfit$Fitness[CGfit$Home=="H1"]~
       CGfit$MdAllEnv[CGfit$Home=="H1"])
abline(lm(CGfit$Fitness[CGfit$Home=="H1"]~
            CGfit$MdAllEnv[CGfit$Home=="H1"]))
cor(CGfit$Fitness[CGfit$Home=="H1"],
    CGfit$MdAllEnv[CGfit$Home=="H1"])
```

# Results for Euclidean Dist and Mahalanobis are similar because we standardize the environments to have an SD=1 prior to analysis



