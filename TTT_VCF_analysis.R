library(OutFLANK)  # outflank package
library(vcfR)
require(adegenet)
require(gdm)
require(gradientForest)
require(foreach)
require(doParallel)
require(OutFLANK)
require(pbapply)
require(gdata)
require(data.table)
require(PresenceAbsence)
require(ROCR)
require(modEvA)
require(ggplot2)
require(grid)
require(gridExtra)
require(gtools)
require(cowplot)

setwd("/Users/akijarl/Desktop/PostDoc/SLiMstuff/SLiM_output/250K/VCF_output/")
#setwd("/Users/akijarl/Desktop/PostDoc/SLiMstuff/SLiM_output/")

vcf1 <- read.vcfR("TTT_SP_100_1599594485287_Gen250000.vcf", verbose = T)
vcf2 <- read.vcfR("TTT_SP_100_1599594485287_Gen250300.vcf", verbose = T)

vcfTSR <- read.vcfR("TTT_SP_100_linear_EnvShift_10RC_1649683388434_recap_mutate.vcf", verbose = T)
vcfTSR <- read.vcfR("TTT_SP_100_linear_EnvShift_10RC_1687770438261_recap_mutate.vcf", verbose = T)

### Convert VCF to 012 format ####
# Character matrix containing the genotypes
# individuals in columns
# Remove 1st column, which is 'Format'
geno1 <- vcf1@gt[,-1] 
geno2 <- vcf2@gt[,-1] 

genoTSR <- vcfTSR@gt[,-1] 

position1 <- getPOS(vcf1) # Positions in bp
chromosome1 <- getCHROM(vcf1) # Chromosome information
ID1 <- getINFO(vcf1) # Meta data information

position2 <- getPOS(vcf2) # Positions in bp
chromosome2 <- getCHROM(vcf2) # Chromosome information
ID2 <- getINFO(vcf2) # Meta data information

positionTSR <- getPOS(vcfTSR) # Positions in bp
chromosomeTSR <- getCHROM(vcfTSR) # Chromosome information
#IDTSR <- getINFO(vcfTSR) # Meta data information

G1 <- matrix(NA, nrow = nrow(geno1), ncol = ncol(geno1))
G1[geno1 %in% c("0/0", "0|0")] <- 0
G1[geno1  %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G1[geno1 %in% c("1/1", "1|1")] <- 2

G2 <- matrix(NA, nrow = nrow(geno2), ncol = ncol(geno2))
G2[geno2 %in% c("0/0", "0|0")] <- 0
G2[geno2  %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G2[geno2 %in% c("1/1", "1|1")] <- 2

GTSR <- matrix(NA, nrow = nrow(genoTSR), ncol = ncol(genoTSR))
GTSR[genoTSR %in% c("0/0", "0|0")] <- 0
GTSR[genoTSR  %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
GTSR[genoTSR %in% c("1/1", "1|1")] <- 2

sum(duplicated(position1))
sum(duplicated(position2))

sum(duplicated(positionTSR))

#Position of M2 allele
position1[grep("MT=2",ID1)]
position2[grep("MT=2",ID2)]

a_freq1 <- rowSums(G1)/(2*ncol(G1))
a_freq2 <- rowSums(G2)/(2*ncol(G2))
a_freqTSR <- rowSums(GTSR)/(2*ncol(GTSR))

hist(a_freq1, breaks=75,xlab="Allele frequency", main="Generation 250000, pre env. shift", col="cyan")
hist(a_freq2, breaks=75, xlab="Allele frequency", main="Generation 250300, post env. shift", col="orange")
hist(a_freqTSR, breaks=75, xlab="Allele frequency", main="From TSR file, Generation 250300, post env. shift", col="red")

plot(a_freq1[order(a_freq1)], ylab="Allele frequency", main="Generation 250000, pre env. shift", col="cyan")

plot(a_freq2[order(a_freq2)], ylab="Allele frequency", main="Generation 250300, post env. shift", col="orange")

plot(a_freqTSR[order(a_freqTSR)], ylab="Allele frequency", main="From TSR file, Generation 250300, post env. shift", col="red")

PreN<-data.frame(a_freq1,position1,ID1,stringsAsFactors = F)
PreN[grep("MT=2",PreN$ID1),]

library(stringr)
pat <- "MID=([^;]+);"
MID_pre<-paste("M",str_match(PreN$ID1, pat)[,2],sep="")
M2_MID<-paste("M",str_match(PreN$ID1[grep("MT=2",ID1)],pat)[,2],sep="")

PostN<-data.frame(a_freq2,position2,ID2)
PostN[grep("MT=2",PostN$ID2),]

MID_post<-paste("M",str_match(PostN$ID2, pat)[,2],sep="")

Start<-seq(1,10000,100)
Stop<-seq(100,10000,100)

Pop_afreq1<-NULL
for(i in 1:100){
  Pop_afreq1<-rbind(Pop_afreq1,rowSums(G1[,Start[i]:Stop[i]])/(2*ncol(G1[,Start[i]:Stop[i]])))
}

Pop_afreq1<-data.frame(Pop_afreq1)
colnames(Pop_afreq1)<-MID_pre

Pops <- NULL
for(j in 1:10){
  for(i in 1:10){
    Pops <- c(Pops,print(paste("A",i,sep="")))
  }
}

require(ggplot2)

Pop_afreq1$Pops<-Pops
Pop_afreq1$Pops <- factor(Pop_afreq1$Pops, levels = Pop_afreq1$Pops[1:10])

M2<-data.frame(Pop_afreq1[,c(which(colnames(Pop_afreq1)==M2_MID))])
colnames(M2)<-M2_MID
  
#ggplot(data = M2)+
#  geom_boxplot(aes(y=M2[,1],x=M2$Pops))

afreq1_N<-Pop_afreq1[,-c(which(colnames(Pop_afreq1)==M2_MID),length(Pop_afreq1))]

#Pop_afreq1_c<-Pop_afreq1[,colnames(Pop_afreq1)%in%unique(imDat_250000$allele)]

#Input Fit & Env file here
names(envPop) <- "envSelect"

alFreq<-cbind(afreq1_N,M2) #Keep track of which M2 generation is beign compared
#alFreq<-alFreq[,-length(alFreq)]

# number of cores to use for parallel processing
cores <- 3

#####
# build output GF data frames
gfR2tab <- function(gfMods.list, alFreqs){
  i=1
  while(is.null(gfMods.list[[i]])){i=i+1}
  tab <- do.call(rbind, gfMods.list)
  vrNm <- rep(row.names(tab)[1:nrow(gfMods.list[[i]])], 
              nrow(tab)/nrow(gfMods.list[[i]]))
  tab <- data.frame(variable=vrNm, tab)
  tab <- dcast(tab, SNPnames~variable, value.var="imps")
  envR2 <- rowSums(data.frame(tab[,-1]))
  R2Tab <- data.frame(tab, envR2=envR2)
  
  # get name of SNP if it has a positive R2
  posR2 <- unlist(lapply(gfMods.list, function(x){
    return(as.character(unique(x[,2])))}))
  
  # Find which loci have R2 < 0 (no GF model for those) & assign R2=0
  negR2 <- !(colnames(alFreqs) %in% posR2)
  negR2 <- colnames(alFreqs)[negR2] 
  
  noGF <- data.frame(matrix(0, nrow=length(negR2), ncol=ncol(R2Tab)))
  colnames(noGF) <- colnames(R2Tab)           
  noGF$SNPnames <- negR2
  
  R2Tab <- rbind(R2Tab, noGF)
  return(R2Tab[order(R2Tab$SNPnames),])}

##############################################
# Chunk to fit GF models to minor allele frequencies at the level of
# populations
# GF is fit to each SNP individually to 
# ease computational / memory burden

cl <- makeCluster(cores)
registerDoParallel(cl)

# use for each to run in parallel - each SNP modeled by GF on different processor
gfAllele.freq <- foreach(k=1:ncol(alFreq), .verbose=F, .packages=c("gradientForest", "data.table")) %dopar% {
  # get locus k & name with SNP ID
  locus <- data.frame(alFreq[,k])
  names(locus) <- colnames(alFreq)[k]
  
  # here's the GF modeling function
  gfLocus <- gradientForest(data=data.frame(envPop, locus),
                            #gfLocus <- gradientForest(data=data.frame(locPop, locus),
                            predictor.vars=colnames(envPop), 
                            #predictor.vars=colnames(locPop),
                            response.vars=colnames(alFreq)[k], 
                            corr.threshold=0.5, 
                            ntree=500, 
                            trace=F)
  
  # get result is the model is not = NULL (no fit)
  if(!is.null(gfLocus)){
    # cumulative importance values (to plot turnover functions)
    cImp <- cumimp(gfLocus, "envSelect", type="Species")
    cImp <- data.frame(rbindlist(cImp, idcol="allele"))
    # return data frame with allele ID, cumulative importance results,
    # and R2 value for GF model
    data.frame(cImp, r2=gfLocus$result)
  }
}
stopCluster(cl)

# Prep table of importance values for each SNP (rows) 
# and each var (columns)
gfAF <- lapply(gfAllele.freq, function(x){
  if(!is.null(x)){
    ttt <- x[1,c("r2", "allele")]
    return(data.frame(imps=ttt$r2, SNPnames=ttt$allele, row.names = "envSelect",
                      stringsAsFactors=F))}})

# run function to convert to table # then write to file
gfAllele.R2.af <- gfR2tab(gfAF, alFreq)
gfAllele.R2.af <- gfAllele.R2.af[match(mixedsort(gfAllele.R2.af$SNPnames), 
                                       gfAllele.R2.af$SNPnames),]
gfAllele.R2.af$SNPnames <- gsub("S", "", gfAllele.R2.af$SNPnames)

finalOut <- data.frame(SNPnames=gfAllele.R2.af$SNPnames, 
                       #cImp.envSelect.alleleFreq=gfAllele.R2.af$envSelect,
                       r_squared.alleleFreq=gfAllele.R2.af$envR2)

#write.table(finalOut, "alFreq_1772056440191_gradientforests.Cpval", row.names=F)
write.table(finalOut, paste("alFreq_",substr(plotTitle, start=19, stop=31),"Gen250000_gradientforests.Cpval",sep=""), row.names=F)
#save(gfAllele.freq, file="alFreq_1772056440191_gradientforests.Rdata")
save(gfAllele.freq, file=paste("alFreq_",substr(plotTitle, start=19, stop=31),"Gen250000_gradientforests.Rdata",sep=""))


