require(OutFLANK)
require(vcfR)
require(adegenet)
require(gdm)
require(gradientForest)
require(foreach)
require(doParallel)
require(OutFLANK)
require(pbapply)
require(gdata)
require(data.table)
require(PresenceAbsence)
require(ROCR)
require(modEvA)
require(ggplot2)
require(dplyr)
require(grid)
require(gridExtra)
require(gtools)
require(cowplot)
require(stringr)
require(reshape2)
require(qqman)

setwd("/Users/akijarl/Desktop/PostDoc/SLiMstuff/SLiM_output/250K/VCF_output/300K/")

#load("PostGF.RData")

f1<-list.files()[grep(".vcf",list.files())][3]
s1<-substr(f1, start=12, stop=24)
g1<-substr(f1, start=26, stop=34)

plotTitle <- paste(s1,"_",g1,"\n",colnames(specs)[1],":",specs[1]," ", colnames(specs)[2],":",specs[2]," ",colnames(specs)[3],":",specs[3]," ",colnames(specs)[4],":",specs[4]," ",colnames(specs)[5],":",specs[5]," ",colnames(specs)[6],":",specs[6]," ",colnames(specs)[7],":",specs[7],sep="")

fit<-read.table(paste("Fit_SP_100_",s1,".txt",sep=""),fill=T) 

fit_nam <- NULL
for(i in 1:100){
  fit_nam <- c(fit_nam,paste("P",i,"_fit",sep=""))
}

freq_nam <- NULL
for(i in 1:100){
  freq_nam <- c(freq_nam,paste("P",i,"_freq",sep=""))
}

env_nam <- NULL
for(i in 1:100){
  env_nam <- c(env_nam,paste("P",i,"_env",sep=""))
}

colnames(fit)<-c("s","m","n","r","Env_rate","Burnin","Env_shift", "Generation", fit_nam, freq_nam, env_nam)
specs<-fit[1,1:7]

gen_nam <- paste("Gen",fit$Generation,sep="")

fitt<-data.frame(t(fit[,-1:-8]))
colnames(fitt)<-gen_nam

fitt$Location <- as.factor(rep(paste("A",seq(1,10,1),sep=""),30))
fitt$Location <- factor(fitt$Location, levels = unique(fitt$Location))

fitt$Type <- as.factor(c(rep("Fit",100),rep("Freq",100),rep("Env",100)))

# number of cores to use for parallel processing
cores <- 3
cl <- makeCluster(cores)
registerDoParallel(cl)

vcf1 <- read.vcfR(paste("TTT_SP_100_",s1, "_",gen_nam[length(gen_nam)-30],".vcf",sep=""), verbose = T)
vcf2 <- read.vcfR(paste("TTT_SP_100_",s1, "_",gen_nam[length(gen_nam)],".vcf",sep=""), verbose = T)

### Convert VCF to 012 format ####
# Character matrix containing the genotypes
# individuals in columns
# Remove 1st column, which is 'Format'
geno1 <- vcf1@gt[,-1] 
geno2 <- vcf2@gt[,-1] 

position1 <- getPOS(vcf1) # Positions in bp
chromosome1 <- getCHROM(vcf1) # Chromosome information
ID1 <- getINFO(vcf1) # Meta data information

position2 <- getPOS(vcf2) # Positions in bp
chromosome2 <- getCHROM(vcf2) # Chromosome information
ID2 <- getINFO(vcf2) # Meta data information

#Create Genotype matrix
G1 <- matrix(NA, nrow = nrow(geno1), ncol = ncol(geno1))
G1[geno1 %in% c("0/0", "0|0")] <- 0
G1[geno1  %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G1[geno1 %in% c("1/1", "1|1")] <- 2

G2 <- matrix(NA, nrow = nrow(geno2), ncol = ncol(geno2))
G2[geno2 %in% c("0/0", "0|0")] <- 0
G2[geno2  %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G2[geno2 %in% c("1/1", "1|1")] <- 2

#Check number of duplicate positions
sum(duplicated(position1))
sum(duplicated(position2))

#Position of M2 allele
position1[grep("MT=2",ID1)]
position2[grep("MT=2",ID2)]

#Calculate allele frequencies across the whole meta population
a_freq1 <- rowSums(G1)/(2*ncol(G1))
a_freq2 <- rowSums(G2)/(2*ncol(G2))

stopCluster(cl)

#a_freq1_NoFixed<-a_freq1[a_freq1!=1]

#Combine allele frequency, genomic position, & meta data into one data frame
PreN<-data.frame(a_freq1,position1,ID1,stringsAsFactors = F)
PreN[grep("MT=2",PreN$ID1),]

#Extract SLiM assigned MIDs to keep track of mutations
pat <- "MID=([^;]+);"
MID_pre<-paste("M",str_match(ID1, pat)[,2],sep="")
M2_MID<-paste("M",str_match(ID1[grep("MT=2",ID1)],pat)[,2],sep="")

PostN<-data.frame(a_freq2,position2,ID2)
PostN[grep("MT=2",ID2),]

MID_post<-paste("M",str_match(ID2, pat)[,2],sep="")

#save(PreN,file="PreN.RData")
#save(PostN,file="PostN.RData")

#load("PreN.RData")
#load("PostN.RData")

Start<-seq(1,ncol(geno1),specs$n)
Stop<-seq(specs$n,ncol(geno1),specs$n)

#Calculate allele frequencies across X locations
Pop_afreq1<-NULL
for(i in 1:100){
  Pop_afreq1<-rbind(Pop_afreq1,rowSums(G1[,Start[i]:Stop[i]])/(2*ncol(G1[,Start[i]:Stop[i]])))
}

Pop_afreq1<-data.frame(Pop_afreq1)
colnames(Pop_afreq1)<-MID_pre

Pop_afreq2<-NULL
for(i in 1:100){
  Pop_afreq2<-rbind(Pop_afreq2,rowSums(G2[,Start[i]:Stop[i]])/(2*ncol(G2[,Start[i]:Stop[i]])))
}

Pop_afreq2<-data.frame(Pop_afreq2)
colnames(Pop_afreq2)<-MID_post

#Filter for MAF<0.05 and >0.95
Pop_afreq1_filt<-Pop_afreq1[,which(colMeans(Pop_afreq1)>0.05)]
Pop_afreq1_filt<-Pop_afreq1_filt[,which(colMeans(Pop_afreq1_filt)<0.95)]

Pop_afreq2_filt<-Pop_afreq2[,which(colMeans(Pop_afreq2)>0.05)]
Pop_afreq2_filt<-Pop_afreq2_filt[,which(colMeans(Pop_afreq2_filt)<0.95)]

#Extract the M2 allele frequency as a distinct vector
M2<-data.frame(Pop_afreq1[,colnames(Pop_afreq1)==M2_MID])
colnames(M2)<-"M2"

#M2_d <- data.frame(fitt[fitt$Type=="Freq",c("Gen300300","Location")]) #Subset M2 allele frequencies and location by Generation
#colnames(M2_d)[1]<-"M2"

#Subset the environmental variables for the generation you're considering (make sure the M2 AF and environmental data are not being compare across generations)
envPop<-data.frame(fitt[fitt$Type=="Env",gen_nam[length(gen_nam)-30]]) #300 years prior to the end of the simulation is taken as the "before environmental shift" time
names(envPop) <- "envSelect"

envPop.shift<-data.frame(fitt[fitt$Type=="Env",gen_nam[length(gen_nam)]])
names(envPop.shift) <- "envSelect"

#Merge the population specific allele frequencies of all neutral (M1) alleles with the population specific frequency of the selected (M2) allele
alFreq<-cbind(data.frame(Pop_afreq1[,colnames(Pop_afreq1)!=M2_MID]),M2) 

#####
# build output GF data frames
gfR2tab <- function(gfMods.list, alFreqs){
  i=1
  while(is.null(gfMods.list[[i]])){i=i+1}
  tab <- do.call(rbind, gfMods.list)
  vrNm <- rep(row.names(tab)[1:nrow(gfMods.list[[i]])], 
              nrow(tab)/nrow(gfMods.list[[i]]))
  tab <- data.frame(variable=vrNm, tab)
  tab <- dcast(tab, SNPnames~variable, value.var="imps")
  envR2 <- rowSums(data.frame(tab[,-1]))
  R2Tab <- data.frame(tab, envR2=envR2)
  
  # get name of SNP if it has a positive R2
  posR2 <- unlist(lapply(gfMods.list, function(x){
    return(as.character(unique(x[,2])))}))
  
  # Find which loci have R2 < 0 (no GF model for those) & assign R2=0
  negR2 <- !(colnames(alFreqs) %in% posR2)
  negR2 <- colnames(alFreqs)[negR2] 
  
  noGF <- data.frame(matrix(0, nrow=length(negR2), ncol=ncol(R2Tab)))
  colnames(noGF) <- colnames(R2Tab)           
  noGF$SNPnames <- negR2
  
  R2Tab <- rbind(R2Tab, noGF)
  return(R2Tab[order(R2Tab$SNPnames),])}

##############################################
# Chunk to fit GF models to minor allele frequencies at the level of
# populations
# GF is fit to each SNP individually to 
# ease computational / memory burden

cl <- makeCluster(cores)
registerDoParallel(cl)

##### added by MCF, running all loci in on model ##########

gfMod <- gradientForest(data=data.frame(envPop, alFreq),
                        predictor.vars=colnames(envPop),
                        response.vars=colnames(alFreq),
                        corr.threshold=0.5, 
                        ntree=500, 
                        trace=T)

stopCluster(cl)

# Calculate genomic offset
# note that I am doing this for the avearge across all alleles since 
# GF was fit to all alleles simultaneously
# The more correct way is to calculate offset for adaptive alleles only,
# either individually or for a model fit to just those alleles.
gfTrans1 <- predict(gfMod, envPop)
colnames(gfTrans1)<-"C.Imp_genome_before"

gfTrans2 <- predict(gfMod, envPop.shift)
colnames(gfTrans2)<-"C.Imp_genome_after"

offset <- gfTrans2-gfTrans1
colnames(offset)<-"D_C.Imp_genome"

# Selected allele only
gfM2 <- gradientForest(data=data.frame(envPop, M2),
                        predictor.vars=colnames(envPop),
                        response.vars=colnames(M2),
                        corr.threshold=0.5, 
                        ntree=500, 
                        trace=T)

gfM2Trans1 <- predict(gfM2, envPop)
colnames(gfM2Trans1)<-"C.Imp_M2_before"

gfM2Trans2 <- predict(gfM2, envPop.shift)
colnames(gfM2Trans2)<-"C.Imp_M2_after"

M2offset <- gfM2Trans2-gfM2Trans1
colnames(M2offset)<-"D_C.Imp_M2"

########################
#Allele by allele GF
########################
cl <- makeCluster(cores)
registerDoParallel(cl)

# use for each to run in parallel - each SNP modeled by GF on different processor
gfAllele.freq <- foreach(k=1:ncol(alFreq), .verbose=F, .packages=c("gradientForest", "data.table")) %dopar% {
  # get locus k & name with SNP ID
  locus <- data.frame(alFreq[,k])
  names(locus) <- colnames(alFreq)[k]
  
  # here's the GF modeling function
  gfLocus <- gradientForest(data=data.frame(envPop, locus),
                            #gfLocus <- gradientForest(data=data.frame(locPop, locus),
                            predictor.vars=colnames(envPop), 
                            #predictor.vars=colnames(locPop),
                            response.vars=colnames(alFreq)[k], 
                            corr.threshold=0.5, 
                            ntree=500, 
                            trace=F)
  
  # get result is the model is not = NULL (no fit)
  if(!is.null(gfLocus)){
    # cumulative importance values (to plot turnover functions)
    cImp <- cumimp(gfLocus, "envSelect", type="Species")
    cImp <- data.frame(rbindlist(cImp, idcol="allele"))
    # return data frame with allele ID, cumulative importance results,
    # and R2 value for GF model
    data.frame(cImp, r2=gfLocus$result)
  }
}
stopCluster(cl)

# Prep table of importance values for each SNP (rows) 
# and each var (columns)
gfAF <- lapply(gfAllele.freq, function(x){
  if(!is.null(x)){
    ttt <- x[1,c("r2", "allele")]
    return(data.frame(imps=ttt$r2, SNPnames=ttt$allele, row.names = "envSelect",
                      stringsAsFactors=F))}})

save(gfAllele.freq, file=paste("alFreq_",substr(plotTitle, start=19, stop=31),"Gen250000__filt_gradientforests.Rdata",sep=""))

#Re-load previous impDat
#load("alFreq_1710137128977Gen250000_gradientforests.Rdata")

impDatList <- gfAllele.freq[unlist(lapply(gfAllele.freq, function(x){!is.null(x)}))]

impDat <- do.call(rbind, impDatList)

cImpMAF.sel<-impDat[which(impDat$allele=="M2"),]

#Highlihgt linked and unlinked variants
#Any allele variant with position below 200000, or above 249999 is unlinked by design.
unlinked<-PreN[PreN$position1>249999 | PreN$position1<200000,] 
linked<-PreN[PreN$position1<=249999,] 
linked<-linked[linked$position1>=200000,]
pat <- "MID=([^;]+);"
unlinked_MID<-paste("M",str_match(unlinked$ID1, pat)[,2],sep="")
impDat_UL<-impDat[impDat$allele%in%unlinked_MID,]
linked_MID<-paste("M",str_match(linked$ID1, pat)[,2],sep="")
impDat_L<-impDat[impDat$allele%in%linked_MID,]

p.imp <- 
  ggplot() + 
  geom_line(data=impDat, aes(x=x, y=y, group=allele), colour=rgb(0,0,0,0.4), lwd=0.5) +
    #geom_line(data=impDat_L, aes(x=x, y=y, group=allele), colour="cyan", lwd=0.5) +
    #geom_line(data=impDat_UL, aes(x=x, y=y, group=allele), colour="orange", lwd=0.5) +
  #facet_grid(. ~ strSel) +
  labs(y="Cumulative Importance", x="Environment") +
  geom_line(data=cImpMAF.sel, aes(x=x, y=y),
            colour=rgb(1,0,0, 0.75), lwd=1) +
  theme(plot.margin = unit(c(1.25,1.25,1.25,1.25), "in")) +
  theme_bw() +
  theme(axis.text.x = element_text(size = 18, colour = "grey60"),
        axis.title.x = element_text(size=24)) +
  theme(axis.text.y = element_text(size = 16, colour = "grey60"),
        axis.title.y = element_text(size=24, vjust=1)) +
  theme(strip.text = element_text(size=16)) +
  ggtitle("") +
  ggtitle(plotTitle) +
  theme(plot.title = element_text(size=14, face="bold.italic"))

p.imp

ggCand1<-cImpMAF.sel
#ggCand1_unfilt<-ggCand1

#########################################
#Proportion of R^2>0 alleles out of total
length(unique(impDat$allele))/length(alFreq)

###############################################
#Get alleles which had R^2>0 (R2) and R^2=0 (R0)
R2<-alFreq[,colnames(alFreq)%in%impDat$allele]
R0<-alFreq[,!colnames(alFreq)%in%impDat$allele]

R2M<-data.frame(colnames(R2),colMeans(R2))
R0M<- data.frame(colnames(R0),colMeans(R0))


ggplot(data = R2M)+#, aes(colour=Pops))+
  geom_histogram(aes(R2M$colMeans.R2.))+
  xlab("Filt. allele Freq of R^2>0 variants")+ 
  ylab("")+
  #scale_color_manual(values=colfunc(10))+
  ylim(c(0,525))+
  geom_hline(yintercept = 0,col="grey") +
  theme(legend.position="none")

ggplot(data = R0M)+#, aes(colour=Pops))+
  geom_histogram(aes(R0M$colMeans.R0.))+
  xlab("Filt. allele Freq of R^2=0 variants")+ 
  ylab("")+
  #scale_color_manual(values=colfunc(10))+
  ylim(c(0,525))+
  geom_hline(yintercept = 0,col="grey") +
  theme(legend.position="none")

###############################################
#Visualize R^2>0 compared to Spearman correltation of alFreq to each env.
###############################################
#envPop
EnvCor<-cor(as.matrix(R2),envPop,method = "spearman")
EnvCor<-data.frame(rownames(EnvCor),EnvCor)
colnames(EnvCor)<-c("MID","rho")

R2MID<-unique(data.frame(impDat$allele,impDat$r2))
colnames(R2MID)<-c("MID","R2")

Comp<-merge(EnvCor,R2MID, by="MID")

Link<-NULL
for(i in 1:length(Comp$MID)){
  if(Comp$MID[i]%in%linked_MID){
    Link<-c(Link,"Linked")
    }
  else{
    Link<-c(Link,"Unlinked")
  }
}

Comp$Link<-Link

ggplot(data = Comp, aes(color=Link))+
  geom_point(aes(x=abs(rho), y=R2))+
  geom_point(aes(x=Comp[Comp$MID==M2_MID,"rho"],y=Comp[Comp$MID==M2_MID,"R2"]), col="red")+
  xlab("Spearman's rho between allele frequency and environment")+ 
  ylab("R^2 value for allele")+
  geom_abline(intercept=0,slope=1)+
  scale_color_manual(values=colfunc(2))+
  #geom_hline(yintercept = 0,col="grey") +
  theme(legend.title = element_blank())


#Location values
Loc <- NULL
for(j in 1:10){
  for(i in 1:10){
    Loc <- c(Loc,print(paste("A",i,sep="")))
  }
}

#Population values
Pop <- NULL
for(i in 1:100){
  Pop <- c(Pop,paste("P",i,sep=""))
}

DCimp<-cbind(offset,M2offset,Loc,Pop,envPop)
colnames(DCimp)<-c("GenOffset","CImp","Loc","Pop","Env")
DCimp$Loc<-factor(DCimp$Loc,levels=Loc[1:10])

colfunc<-colorRampPalette(c("orange","cyan"))

ggplot(data=DCimp,aes(colour=Loc))+
  geom_point(aes(x=DCimp$Loc, y=DCimp$GenOffset),size=4)+
  xlab("Environment")+
  ylab(expression("Genomic offset"))+
  scale_color_manual(values=colfunc(10))

ggplot(data=DCimp,aes(colour=Loc))+
  geom_point(aes(x=DCimp$Loc, y=DCimp$CImp),size=4)+
  xlab("Environment")+
  ylab(expression("Diff. in C.Imp"))+
  scale_color_manual(values=colfunc(10))

DM2<-M2_2-M2
DM2$Pops<-Pops
colnames(DM2)<-c("dM2","Pops")
DM2$Pops <- factor(DM2$Pops, levels = DM2$Pops[1:10])

ggplot(data = DM2, aes(colour=Pops))+
  geom_boxplot(aes(y=DM2$dM2,x=DM2$Pops))+
  xlab("")+ 
  ylab("Results of M2 Allele Freq(future) - Allele Freq(present)")+
  scale_color_manual(values=colfunc(10))+
  geom_hline(yintercept = 0,col="grey") +
  theme(legend.position="none")

CumImp_M2freq<-merge(DM2,DcumImp,by="Pops")
#colnames(CumImp_M2freq)<-c("Pops","dM2","DCumImp","Extr")
CumImp_M2freq$Pops <- factor(CumImp_M2freq$Pops, levels = unique(Pops))

ggplot(data = CumImp_M2freq,aes(colour=Pops, shape=Extr))+
  geom_point(aes(y=DCumImp,x=dM2),size=4)+
  ylab(expression(paste("'Genomic vulnerability' (",Delta,"CumImp)",sep="")))+
  xlab("Results of M2 Allele Freq(future) - Allele Freq(present)")+
  #xlab(expression(paste(Delta,"Freq")))+
  scale_color_manual(values=colfunc(10))

afreq1_N<-afreq1_N[,which(colMeans(afreq1_N)>0.05)]
afreq1_N<-afreq1_N[,which(colMeans(afreq1_N)<0.95)]
afreq2_N<-afreq2_N[,which(colMeans(afreq2_N)>0.05)]
afreq2_N<-afreq2_N[,which(colMeans(afreq2_N)<0.95)]

Cafreq1<-afreq1_N[,colnames(afreq1_N)%in%colnames(afreq2_N)]
Cafreq2<-afreq2_N[,colnames(afreq2_N)%in%colnames(afreq1_N)]

Dafreq<-Cafreq2-Cafreq1
Dafreq<-data.frame(rowMeans(Cafreq2)-rowMeans(Cafreq1))
Dafreq$Pops<-Pops
Dafreq$Pops <- factor(Dafreq$Pops, levels = Dafreq$Pops[1:10])

ggplot(data = Dafreq, aes(colour=Pops))+
  geom_boxplot(aes(y=Dafreq[,-length(Dafreq)],x=DM2$Pops))+
  xlab("")+ 
  ylab("Results of all neutral Allele Freq(future) - Allele Freq(present)")+
  scale_color_manual(values=colfunc(10))+
  geom_hline(yintercept = 0,col="grey") +
  theme(legend.position="none")


CumImp_M1freq<-merge(Dafreq,DcumImp,by="Pops")
colnames(CumImp_M1freq)<-c("Pops","dM1","DCumImp","Extr")
CumImp_M1freq$Pops <- factor(CumImp_M2freq$Pops, levels = unique(Pops))

ggplot(data = CumImp_M1freq,aes(colour=Pops, shape=Extr))+
  geom_point(aes(y=DCumImp,x=dM1),size=4)+
  ylab(expression(paste("'Genomic vulnerability' (",Delta,"CumImp)",sep="")))+
  xlab("Results of neutral Allele Freq(future) - Allele Freq(present)")+
  #xlab(expression(paste(Delta,"Freq")))+
  scale_color_manual(values=colfunc(10))

FST<-data.frame(FSTs,Pops[1:10])
colnames(FST)<-c("FST","Pops")
FST$Pops <- factor(FST$Pops, levels = unique(Pops))

ggplot(data=FST,aes(colour=Pops))+
  geom_point(aes(x=Pops, y=FST),size=4)+
  xlab("Populations")+
  ylab(expression(paste("Difference in F"[ST]," between time points")))+
  scale_color_manual(values=colfunc(10))

CumImp_FST<-merge(FST,DcumImp,by="Pops")
CumImp_FST$Pops <- factor(CumImp_FST$Pops, levels = unique(Pops))

ggplot(data = CumImp_FST,aes(colour=Pops, shape=Extr))+
  geom_point(aes(y=DCumImp,x=FST),size=4)+
  ylab(expression(paste("'Genomic vulnerability' (",Delta,"CumImp)",sep="")))+
  xlab(expression(paste("Results of F"[ST]," between future and present population")))+
  #xlab(expression(paste(Delta,"F"[ST])))+
  scale_color_manual(values=colfunc(10))



##############################################################################
#Get  Weir & Cockerham F_ST values from the VCF files and use population data

#Create an object listing every population in the whole dataset
PopsALL <- NULL
for(j in rep(1:100)){
  for(i in rep(j,100)){
    PopsALL <- c(PopsALL,i)
  }
}

#Create an object splitting a single population into a Pre ("T1") and Post ("T2") "population"
PopsP <- c(rep("T1",100),rep("T2",100))

cores<-3
cl <- makeCluster(cores)
registerDoParallel(cl)

#Prepare the Pre (G1) and Post (G2) G matrices for FST calculation
Gt1<-t(G1)
rownames(Gt1)<-PopsALL
colnames(Gt1)<-MID_pre

Gt2<-t(G2)
rownames(Gt2)<-PopsALL
colnames(Gt2)<-MID_post

#Filter so that only variants present at both time points are compared
Gt1_m<-Gt1[,colnames(Gt1)%in%colnames(Gt2)]
Gt2_m<-Gt2[,colnames(Gt2)%in%colnames(Gt1)]

#Add loop to iterate across each TRUE population, not just x-location

#Filter by population
listGt<-list()
for(i in 1:100){
  Gt1_i<-Gt1_m[rownames(Gt1_m)==i,]
  Gt2_i<-Gt2_m[rownames(Gt2_m)==i,]
  listGt[[i]]<-assign(paste("Gt_P", i, sep=''),rbind(Gt1_i,Gt2_i))
}

#Calculate per locus FST values
listPfst<-list()
for(i in 1:100){
  listPfst[[i]]<-MakeDiploidFSTMat(SNPmat = listGt[[i]], locusNames = colnames(listGt[[i]]), popNames = PopsP)
}



#Filter out NA values
listPfst_noNa<-list()
for(i in 1:100){
  listPfst_noNa<-lapply(listPfst,function(x) x[!is.na(x$FST),])
}

#Calculate FST values for each populations
FST_genome_pop<-NULL
for(i in 1:100){
  FST_genome_pop<-c(FST_genome_pop,mean(listPfst_noNa[[i]]$T1)/mean(listPfst_noNa[[i]]$T2))
}

############################
#Pull out only the M2 allele
Gt1_m2<-matrix(Gt1[,M2_MID])
colnames(Gt1_m2)<-M2_MID
rownames(Gt1_m2)<-PopsALL

Gt2_m2<-matrix(Gt2[,M2_MID])
colnames(Gt2_m2)<-M2_MID
rownames(Gt2_m2)<-PopsALL

listGt_m2<-list()
for(i in 1:100){
  Gt1_m2i<-matrix(Gt1_m2[rownames(Gt1_m2)==i,])
  colnames(Gt1_m2i)<-M2_MID
  rownames(Gt1_m2i)<-PopsALL[which(PopsALL==i)]
  Gt2_m2i<-matrix(Gt2_m2[rownames(Gt2_m2)==i,])
  colnames(Gt2_m2i)<-M2_MID
  rownames(Gt2_m2i)<-PopsALL[which(PopsALL==i)]
  listGt_m2[[i]]<-rbind(Gt1_m2i,Gt2_m2i)
}

getFSTs_diploids = function(popNameList, SNPDataColumn){  
  #eliminating the missing data for this locus
  popnames=unlist(as.character(popNameList))
  popNameTemp=popnames[which(SNPDataColumn!=9)]
  snpDataTemp=SNPDataColumn[SNPDataColumn!=9]
  
  HetCounts <- tapply(snpDataTemp, list(popNameTemp,snpDataTemp), length)
  HetCounts[is.na(HetCounts)] = 0
  
  #Case: all individuals are genetically identical at this locus
  if(dim(HetCounts)[2]==1){
    return (list(He=NA,FST=NA, T1=NA, T2=NA,FSTNoCorr=NA, T1NoCorr=NA, T2NoCorr=NA,meanAlleleFreq = NA))
  }
  
  if(dim(HetCounts)[2]==2){
    if(paste(colnames(HetCounts),collapse="")=="01"){HetCounts=cbind(HetCounts,"2"=0)}
    if(paste(colnames(HetCounts),collapse="")=="12"){HetCounts=cbind("0"=0,HetCounts)} 
    if(paste(colnames(HetCounts),collapse="")=="02"){HetCounts=cbind(HetCounts[,1],"1"=0, HetCounts[,2])}
  }
  
  out = WC_FST_Diploids_2Alleles(HetCounts)	
  return(out)
}

MakeDiploidFSTMat_2<-function(SNPmat,locusNames,popNames){
    locusname <- unlist(locusNames)
    popname <- unlist(popNames)
    snplevs <- levels(as.factor(unlist(SNPmat)))
    ls <- paste(snplevs, collapse = "")
    if (ls != "012" & ls != "0129" & ls != "01") {
      print("Error: Your snp matrix does not have 0,1, and 2")
      break
    }
    if (dim(SNPmat)[1] != length(popname)) {
      print("Error: your population names do not match your SNP matrix")
      break
    }
    if (dim(SNPmat)[2] != length(locusname)) {
      print("Error:  your locus names do not match your SNP matrix")
      break
    }
    writeLines("Calculating FSTs, may take a few minutes...")
    nloci <- length(locusname)
    FSTmat <- matrix(NA, nrow = nloci, ncol = 8)
    for (i in 1:nloci) {
      FSTmat[i, ] = unlist(getFSTs_diploids(popname, SNPmat[,i]))
      if (i%%10000 == 0) {
        print(paste(i, "done of", nloci))
      }
    }
    outTemp = as.data.frame(FSTmat)
    outTemp = cbind(locusname, outTemp)
    colnames(outTemp) = c("LocusName", "He", "FST", "T1", "T2", 
                          "FSTNoCorr", "T1NoCorr", "T2NoCorr", "meanAlleleFreq")
    return(outTemp)
  }

#Calculate M2 locus FST values
list_M2_Pfst<-list()
for(i in 1:100){
  list_M2_Pfst[[i]]<-MakeDiploidFSTMat_2(SNPmat = listGt_m2[[i]], locusNames = colnames(listGt_m2[[i]]), popNames = PopsP)
}

#Filter out NA values
list_M2_Pfst_noNa<-list()
for(i in 1:100){
  list_M2_Pfst_noNa<-lapply(list_M2_Pfst,function(x) x[!is.na(x$FST),])
}

#Calculate M2 FST values for each populations
FST_M2_pop<-NULL
for(i in 1:100){
  FST_M2_pop<-c(FST_M2_pop,mean(list_M2_Pfst_noNa[[i]]$T1)/mean(list_M2_Pfst_noNa[[i]]$T2))
}

stopCluster(cl)

##################################
#Population specific summary stats
##################################
Loc

Pop

X <- NULL
for(j in 1:10){
  for(i in 1:10){
    X <- c(X,i)
  }
}

Y <- NULL
for(j in 1:10){
  Y<-c(Y,rep(j,10))
}

Env_before<-envPop$envSelect

Env_after<-envPop.shift$envSelect

Diff_env<-Env_after-Env_before

Env_shift<- envPop$envSelect%in%round(envPop.shift$envSelect,1)&round(envPop.shift$envSelect,1)%in%envPop$envSelect

M2_AF_before<-data.frame(Pop_afreq1_filt[,c(which(colnames(Pop_afreq1_filt)==M2_MID))])
colnames(M2_AF_before)<-"M2_AF_before"

M2_AF_after<-data.frame(Pop_afreq2_filt[,c(which(colnames(Pop_afreq2_filt)==M2_MID))])
colnames(M2_AF_after)<-"M2_AF_after"

M2_AF_diff<-M2_AF_after-M2_AF_before
colnames(M2_AF_diff)<-"M2_AF_diff"

M1_AF_before_all<-Pop_afreq1_filt[,-which(colnames(Pop_afreq1_filt)==M2_MID)]
M1_AF_after_all<-Pop_afreq2_filt[,-which(colnames(Pop_afreq2_filt)==M2_MID)]

M1_AF_before_shared<-M1_AF_before_all[colnames(M1_AF_before_all)%in%colnames(M1_AF_after_all)]
M1_AF_after_shared<-M1_AF_after_all[colnames(M1_AF_after_all)%in%colnames(M1_AF_before_all)]

M1_AF_before<-data.frame(rowMeans(M1_AF_before_shared))
colnames(M1_AF_before)<-"M1_AF_before"

M1_AF_after<-data.frame(rowMeans(M1_AF_after_shared))
colnames(M1_AF_after)<-"M1_AF_after"

M1_AF_diff<-M2_AF_after-M2_AF_before
colnames(M1_AF_diff)<-"M1_AF_diff"

F_ST_genome_bef.aft.<-data.frame(FST_genome_pop)
colnames(F_ST_genome_bef.aft.)<-"F_ST_genome_bef.aft."

F_ST_M2_bef.aft.<-data.frame(FST_M2_pop)
colnames(F_ST_M2_bef.aft.)<-"F_ST_M2_bef.aft."

Rel_Fit_before <- data.frame(fitt[fitt$Type=="Fit",gen_nam[length(gen_nam)-30]])
colnames(Rel_Fit_before)<-"Rel_Fit_before"

Rel_Fit_after <- data.frame(fitt[fitt$Type=="Fit",gen_nam[length(gen_nam)]])
colnames(Rel_Fit_after)<-"Rel_Fit_after"

Rel_Fit_diff<-Rel_Fit_after-Rel_Fit_before
colnames(Rel_Fit_diff)<-"Rel_Fit_diff"

Summary_Pop<-cbind(Pop,X,Y,Env_before,Env_after,Diff_env,Env_range,gfTrans1,gfTrans2,offset,gfM2Trans1,gfM2Trans2,M2offset,M2_AF_before,M2_AF_after,M2_AF_diff,M1_AF_before,M1_AF_after,M1_AF_diff,F_ST_genome_bef.aft.,F_ST_M2_bef.aft.,Rel_Fit_before,Rel_Fit_after,Rel_Fit_diff)
write.csv(Summary_Pop,file=paste("Summary_Pop_",s1,".csv",sep=""))


ggplot()+
  geom_histogram(aes(afreq1_Nm),bins =100,col="cyan")+
  geom_histogram(aes(afreq2_Nm),bins =100,col="orange")+ 
  xlab("Allele frequency")

ggplot(data = M2)+
  geom_boxplot(aes(y=M2[,1],x=Pop_afreq1$Pops))

ggplot(data = M2_2)+
  geom_boxplot(aes(y=M2_2[,1],x=Pop_afreq2$Pops))

Pop_afreq1$Loc<-Loc
#Pop_afreq1$Pop<-Pop
Pop_afreq1$Loc <- factor(Pop_afreq1$Loc, levels = Pop_afreq1$Loc[1:10])

Pop_afreq2$Loc<-Loc
#Pop_afreq1$Pop<-Pop
Pop_afreq2$Loc <- factor(Pop_afreq2$Loc, levels = Pop_afreq2$Loc[1:10])

##################################
# Allele specific summary stats
##################################

r2<-data.frame(gfMod$result)
colnames(r2)<-"r2"

