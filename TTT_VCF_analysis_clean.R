require(OutFLANK)
require(vcfR)
require(adegenet)
require(gdm)
require(gradientForest)
require(foreach)
require(doParallel)
require(OutFLANK)
require(pbapply)
require(gdata)
require(data.table)
require(PresenceAbsence)
require(ROCR)
require(modEvA)
require(ggplot2)
require(dplyr)
require(grid)
require(gridExtra)
require(gtools)
require(cowplot)
require(stringr)
require(reshape2)
require(qqman)

setwd("/Users/akijarl/Desktop/PostDoc/SLiMstuff/SLiM_output/250K/VCF_output/300K/")

#load("PostGF.RData")

f1<-list.files()[grep(".vcf",list.files())][1]
s1<-substr(f1, start=12, stop=24)
g1<-substr(f1, start=26, stop=34)

fit<-read.table(paste("Fit_SP_100_",s1,".txt",sep=""),fill=T) 

fit_nam <- NULL
for(i in 1:100){
  fit_nam <- c(fit_nam,paste("P",i,"_fit",sep=""))
}

freq_nam <- NULL
for(i in 1:100){
  freq_nam <- c(freq_nam,paste("P",i,"_freq",sep=""))
}

env_nam <- NULL
for(i in 1:100){
  env_nam <- c(env_nam,paste("P",i,"_env",sep=""))
}

colnames(fit)<-c("s","m","n","r","Env_rate","Burnin","Env_shift", "Generation", fit_nam, freq_nam, env_nam)
specs<-fit[1,1:7]

plotTitle <- paste(s1,"_",g1,"\n",colnames(specs)[1],":",specs[1]," ", colnames(specs)[2],":",specs[2]," ",colnames(specs)[3],":",specs[3]," ",colnames(specs)[4],":",specs[4]," ",colnames(specs)[5],":",specs[5]," ",colnames(specs)[6],":",specs[6]," ",colnames(specs)[7],":",specs[7],sep="")

gen_nam <- paste("Gen",fit$Generation,sep="")

fitt<-data.frame(t(fit[,-1:-8]))
colnames(fitt)<-gen_nam

fitt$Location <- as.factor(rep(paste("A",seq(1,10,1),sep=""),30))
fitt$Location <- factor(fitt$Location, levels = unique(fitt$Location))

fitt$Type <- as.factor(c(rep("Fit",100),rep("Freq",100),rep("Env",100)))

# number of cores to use for parallel processing
cores <- 3
cl <- makeCluster(cores)
registerDoParallel(cl)

vcf1 <- read.vcfR(paste("TTT_SP_100_",s1, "_",gen_nam[length(gen_nam)-30],".vcf",sep=""), verbose = T)
vcf2 <- read.vcfR(paste("TTT_SP_100_",s1, "_",gen_nam[length(gen_nam)],".vcf",sep=""), verbose = T)

MAF<-maf(vcf1, element = 2)
MAF_filt<-MAF

### Convert VCF to 012 format ####
# Character matrix containing the genotypes
# individuals in columns
# Remove 1st column, which is 'Format'
geno1 <- vcf1@gt[,-1] 
geno2 <- vcf2@gt[,-1] 

position1 <- getPOS(vcf1) # Positions in bp
chromosome1 <- getCHROM(vcf1) # Chromosome information
ID1 <- getINFO(vcf1) # Meta data information

position2 <- getPOS(vcf2) # Positions in bp
chromosome2 <- getCHROM(vcf2) # Chromosome information
ID2 <- getINFO(vcf2) # Meta data information

#Create Genotype matrix
G1 <- matrix(NA, nrow = nrow(geno1), ncol = ncol(geno1))
G1[geno1 %in% c("0/0", "0|0")] <- 0
G1[geno1  %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G1[geno1 %in% c("1/1", "1|1")] <- 2

G2 <- matrix(NA, nrow = nrow(geno2), ncol = ncol(geno2))
G2[geno2 %in% c("0/0", "0|0")] <- 0
G2[geno2  %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G2[geno2 %in% c("1/1", "1|1")] <- 2

#Check number of duplicate positions
sum(duplicated(position1))
sum(duplicated(position2))

#Position of M2 allele
position1[grep("MT=2",ID1)]
position2[grep("MT=2",ID2)]

#Calculate allele frequencies across the whole meta population
a_freq1 <- rowSums(G1)/(2*ncol(G1))
a_freq2 <- rowSums(G2)/(2*ncol(G2))

#Filter for MAF<0.05 and >0.95
afreq1_filt<-a_freq1[which(a_freq1>0.05)]
afreq1_filt<-afreq1_filt[which(afreq1_filt<0.95)]

stopCluster(cl)

#Combine allele frequency, genomic position, & meta data into one data frame
PreN<-data.frame(a_freq1,position1,ID1,stringsAsFactors = F)
PreN[grep("MT=2",PreN$ID1),]

#Extract SLiM assigned MIDs to keep track of mutations
pat <- "MID=([^;]+);"
MID_pre<-paste("M",str_match(ID1, pat)[,2],sep="")
M2_MID<-paste("M",str_match(ID1[grep("MT=2",ID1)],pat)[,2],sep="")

PostN<-data.frame(a_freq2,position2,ID2)
PostN[grep("MT=2",ID2),]

MID_post<-paste("M",str_match(ID2, pat)[,2],sep="")

#save(PreN,file="PreN.RData")
#save(PostN,file="PostN.RData")

#load("PreN.RData")
#load("PostN.RData")

Start<-seq(1,ncol(geno1),specs$n)
Stop<-seq(specs$n,ncol(geno1),specs$n)

#Calculate allele frequencies across X locations
Pop_afreq1<-NULL
for(i in 1:100){
  Pop_afreq1<-rbind(Pop_afreq1,rowSums(G1[,Start[i]:Stop[i]])/(2*ncol(G1[,Start[i]:Stop[i]])))
}

Pop_afreq1<-data.frame(Pop_afreq1)
colnames(Pop_afreq1)<-MID_pre

Pop_afreq2<-NULL
for(i in 1:100){
  Pop_afreq2<-rbind(Pop_afreq2,rowSums(G2[,Start[i]:Stop[i]])/(2*ncol(G2[,Start[i]:Stop[i]])))
}

Pop_afreq2<-data.frame(Pop_afreq2)
colnames(Pop_afreq2)<-MID_post

#Filter for MAF<0.05 and >0.95
Pop_afreq1_filt<-Pop_afreq1[,which(colMeans(Pop_afreq1)>0.05)]
Pop_afreq1_filt<-Pop_afreq1_filt[,which(colMeans(Pop_afreq1_filt)<0.95)]

Pop_afreq2_filt<-Pop_afreq2[,which(colMeans(Pop_afreq2)>0.05)]
Pop_afreq2_filt<-Pop_afreq2_filt[,which(colMeans(Pop_afreq2_filt)<0.95)]

#Extract the M2 allele frequency as a distinct vector
M2<-data.frame(Pop_afreq1[,colnames(Pop_afreq1)==M2_MID])
colnames(M2)<-"M2"

#M2_d <- data.frame(fitt[fitt$Type=="Freq",c("Gen300300","Location")]) #Subset M2 allele frequencies and location by Generation
#colnames(M2_d)[1]<-"M2"

#Subset the environmental variables for the generation you're considering (make sure the M2 AF and environmental data are not being compare across generations)
envPop<-data.frame(fitt[fitt$Type=="Env",gen_nam[length(gen_nam)-30]]) #300 years prior to the end of the simulation is taken as the "before environmental shift" time
names(envPop) <- "envSelect"

envPop.shift<-data.frame(fitt[fitt$Type=="Env",gen_nam[length(gen_nam)]])
names(envPop.shift) <- "envSelect"

#Merge the population specific allele frequencies of all neutral (M1) alleles with the population specific frequency of the selected (M2) allele
alFreq<-cbind(data.frame(Pop_afreq1_filt[,colnames(Pop_afreq1_filt)!=M2_MID]),M2) 

#####
# build output GF data frames
gfR2tab <- function(gfMods.list, alFreqs){
  i=1
  while(is.null(gfMods.list[[i]])){i=i+1}
  tab <- do.call(rbind, gfMods.list)
  vrNm <- rep(row.names(tab)[1:nrow(gfMods.list[[i]])], 
              nrow(tab)/nrow(gfMods.list[[i]]))
  tab <- data.frame(variable=vrNm, tab)
  tab <- dcast(tab, SNPnames~variable, value.var="imps")
  envR2 <- rowSums(data.frame(tab[,-1]))
  R2Tab <- data.frame(tab, envR2=envR2)
  
  # get name of SNP if it has a positive R2
  posR2 <- unlist(lapply(gfMods.list, function(x){
    return(as.character(unique(x[,2])))}))
  
  # Find which loci have R2 < 0 (no GF model for those) & assign R2=0
  negR2 <- !(colnames(alFreqs) %in% posR2)
  negR2 <- colnames(alFreqs)[negR2] 
  
  noGF <- data.frame(matrix(0, nrow=length(negR2), ncol=ncol(R2Tab)))
  colnames(noGF) <- colnames(R2Tab)           
  noGF$SNPnames <- negR2
  
  R2Tab <- rbind(R2Tab, noGF)
  return(R2Tab[order(R2Tab$SNPnames),])}

##############################################
# Chunk to fit GF models to minor allele frequencies at the level of
# populations
# GF is fit to each SNP individually to 
# ease computational / memory burden

cl <- makeCluster(cores)
registerDoParallel(cl)

##### added by MCF, running all loci in on model ##########

gfMod <- gradientForest(data=data.frame(envPop, alFreq),
                        predictor.vars=colnames(envPop),
                        response.vars=colnames(alFreq),
                        corr.threshold=0.5, 
                        ntree=500, 
                        trace=T)

stopCluster(cl)

# Calculate genomic offset
# note that I am doing this for the avearge across all alleles since 
# GF was fit to all alleles simultaneously
# The more correct way is to calculate offset for adaptive alleles only,
# either individually or for a model fit to just those alleles.
gfTrans1 <- predict(gfMod, envPop)
colnames(gfTrans1)<-"C.Imp_genome_before"

gfTrans2 <- predict(gfMod, envPop.shift)
colnames(gfTrans2)<-"C.Imp_genome_after"

offset <- gfTrans2-gfTrans1
colnames(offset)<-"D_C.Imp_genome"

# Selected allele only
gfM2 <- gradientForest(data=data.frame(envPop, M2),
                        predictor.vars=colnames(envPop),
                        response.vars=colnames(M2),
                        corr.threshold=0.5, 
                        ntree=500, 
                        trace=T)

gfM2Trans1 <- predict(gfM2, envPop)
colnames(gfM2Trans1)<-"C.Imp_M2_before"

gfM2Trans2 <- predict(gfM2, envPop.shift)
colnames(gfM2Trans2)<-"C.Imp_M2_after"

M2offset <- gfM2Trans2-gfM2Trans1
colnames(M2offset)<-"D_C.Imp_M2"


#########################################
#Proportion of R^2>0 alleles out of total
#length(unique(impDat$allele))/length(alFreq)

###############################################
#Get alleles which had R^2>0 (R2) and R^2=0 (R0)
#R2<-alFreq[,colnames(alFreq)%in%impDat$allele]
#R0<-alFreq[,!colnames(alFreq)%in%impDat$allele]

#R2M<-data.frame(colnames(R2),colMeans(R2))
#R0M<- data.frame(colnames(R0),colMeans(R0))




###############################################
#Visualize R^2>0 compared to Spearman correltation of alFreq to each env.
###############################################
#envPop
#EnvCor<-cor(as.matrix(R2),envPop,method = "spearman")
#EnvCor<-data.frame(rownames(EnvCor),EnvCor)
#colnames(EnvCor)<-c("MID","rho")

#R2MID<-unique(data.frame(impDat$allele,impDat$r2))
#colnames(R2MID)<-c("MID","R2")

#Comp<-merge(EnvCor,R2MID, by="MID")

#Link<-NULL
#for(i in 1:length(Comp$MID)){
#  if(Comp$MID[i]%in%linked_MID){
#    Link<-c(Link,"Linked")
#    }
#  else{
#    Link<-c(Link,"Unlinked")
#  }
#}

#Comp$Link<-Link



#Location values
Loc <- NULL
for(j in 1:10){
  for(i in 1:10){
    Loc <- c(Loc,paste("A",i,sep=""))
  }
}

#Population values
Pop <- NULL
for(i in 1:100){
  Pop <- c(Pop,paste("P",i,sep=""))
}

##############################################################################
#Get  Weir & Cockerham F_ST values from the VCF files and use population data

#Create an object listing every population in the whole dataset
PopsALL <- NULL
for(j in rep(1:100)){
  for(i in rep(j,100)){
    PopsALL <- c(PopsALL,i)
  }
}

#Create an object splitting a single population into a Pre ("T1") and Post ("T2") "population"
PopsP <- c(rep("T1",100),rep("T2",100))

cores<-3
cl <- makeCluster(cores)
registerDoParallel(cl)

#Prepare the Pre (G1) and Post (G2) G matrices for FST calculation
Gt1<-t(G1)
rownames(Gt1)<-PopsALL
colnames(Gt1)<-MID_pre

Gt2<-t(G2)
rownames(Gt2)<-PopsALL
colnames(Gt2)<-MID_post

#Filter so that only variants present at both time points are compared
Gt1_m<-Gt1[,colnames(Gt1)%in%colnames(Pop_afreq1_filt)]
Gt2_m<-Gt2[,colnames(Gt2)%in%colnames(Pop_afreq2_filt)]
Gt1_m<-Gt1_m[,colnames(Gt1_m)%in%colnames(Gt2_m)]
Gt2_m<-Gt2_m[,colnames(Gt2_m)%in%colnames(Gt1_m)]

#Add loop to iterate across each TRUE population, not just x-location
#Filter by population
listGt<-list()
for(i in 1:100){
  Gt1_i<-Gt1_m[rownames(Gt1_m)==i,]
  Gt2_i<-Gt2_m[rownames(Gt2_m)==i,]
  listGt[[i]]<-rbind(Gt1_i,Gt2_i)
}

#Calculate per locus FST values
listPfst<-list()
for(i in 1:100){
  listPfst[[i]]<-MakeDiploidFSTMat(SNPmat = listGt[[i]], locusNames = colnames(listGt[[i]]), popNames = PopsP)
}

#Filter out NA values
listPfst_noNa<-list()
for(i in 1:100){
  listPfst_noNa<-lapply(listPfst,function(x) x[!is.na(x$FST),])
}

#Calculate FST values for each populations
FST_genome_pop<-NULL
for(i in 1:100){
  FST_genome_pop<-c(FST_genome_pop,mean(listPfst_noNa[[i]]$T1)/mean(listPfst_noNa[[i]]$T2))
}

############################
#Pull out only the M2 allele
Gt1_m2<-matrix(Gt1[,M2_MID])
colnames(Gt1_m2)<-M2_MID
rownames(Gt1_m2)<-PopsALL

Gt2_m2<-matrix(Gt2[,M2_MID])
colnames(Gt2_m2)<-M2_MID
rownames(Gt2_m2)<-PopsALL

listGt_m2<-list()
for(i in 1:100){
  Gt1_m2i<-matrix(Gt1_m2[rownames(Gt1_m2)==i,])
  colnames(Gt1_m2i)<-M2_MID
  rownames(Gt1_m2i)<-PopsALL[which(PopsALL==i)]
  Gt2_m2i<-matrix(Gt2_m2[rownames(Gt2_m2)==i,])
  colnames(Gt2_m2i)<-M2_MID
  rownames(Gt2_m2i)<-PopsALL[which(PopsALL==i)]
  listGt_m2[[i]]<-rbind(Gt1_m2i,Gt2_m2i)
}

getFSTs_diploids = function(popNameList, SNPDataColumn){  
  #eliminating the missing data for this locus
  popnames=unlist(as.character(popNameList))
  popNameTemp=popnames[which(SNPDataColumn!=9)]
  snpDataTemp=SNPDataColumn[SNPDataColumn!=9]
  
  HetCounts <- tapply(snpDataTemp, list(popNameTemp,snpDataTemp), length)
  HetCounts[is.na(HetCounts)] = 0
  
  #Case: all individuals are genetically identical at this locus
  if(dim(HetCounts)[2]==1){
    return (list(He=NA,FST=NA, T1=NA, T2=NA,FSTNoCorr=NA, T1NoCorr=NA, T2NoCorr=NA,meanAlleleFreq = NA))
  }
  
  if(dim(HetCounts)[2]==2){
    if(paste(colnames(HetCounts),collapse="")=="01"){HetCounts=cbind(HetCounts,"2"=0)}
    if(paste(colnames(HetCounts),collapse="")=="12"){HetCounts=cbind("0"=0,HetCounts)} 
    if(paste(colnames(HetCounts),collapse="")=="02"){HetCounts=cbind(HetCounts[,1],"1"=0, HetCounts[,2])}
  }
  
  out = WC_FST_Diploids_2Alleles(HetCounts)	
  return(out)
}

MakeDiploidFSTMat_2<-function(SNPmat,locusNames,popNames){
    locusname <- unlist(locusNames)
    popname <- unlist(popNames)
    snplevs <- levels(as.factor(unlist(SNPmat)))
    ls <- paste(snplevs, collapse = "")
    if (ls != "012" & ls != "0129" & ls != "01") {
      print("Error: Your snp matrix does not have 0,1, and 2")
      break
    }
    if (dim(SNPmat)[1] != length(popname)) {
      print("Error: your population names do not match your SNP matrix")
      break
    }
    if (dim(SNPmat)[2] != length(locusname)) {
      print("Error:  your locus names do not match your SNP matrix")
      break
    }
    writeLines("Calculating FSTs, may take a few minutes...")
    nloci <- length(locusname)
    FSTmat <- matrix(NA, nrow = nloci, ncol = 8)
    for (i in 1:nloci) {
      FSTmat[i, ] = unlist(getFSTs_diploids(popname, SNPmat[,i]))
      if (i%%10000 == 0) {
        print(paste(i, "done of", nloci))
      }
    }
    outTemp = as.data.frame(FSTmat)
    outTemp = cbind(locusname, outTemp)
    colnames(outTemp) = c("LocusName", "He", "FST", "T1", "T2", 
                          "FSTNoCorr", "T1NoCorr", "T2NoCorr", "meanAlleleFreq")
    return(outTemp)
  }

#Calculate M2 locus FST values
list_M2_Pfst<-list()
for(i in 1:100){
  list_M2_Pfst[[i]]<-MakeDiploidFSTMat_2(SNPmat = listGt_m2[[i]], locusNames = colnames(listGt_m2[[i]]), popNames = PopsP)
}

#Filter out NA values
list_M2_Pfst_noNa<-list()
for(i in 1:100){
  list_M2_Pfst_noNa<-lapply(list_M2_Pfst,function(x) x[!is.na(x$FST),])
}

#Calculate M2 FST values for each populations
FST_M2_pop<-NULL
for(i in 1:100){
  FST_M2_pop<-c(FST_M2_pop,mean(list_M2_Pfst_noNa[[i]]$T1)/mean(list_M2_Pfst_noNa[[i]]$T2))
}

stopCluster(cl)

##################################
#Population specific summary stats
##################################
Loc

Pop

X <- NULL
for(j in 1:10){
  for(i in 1:10){
    X <- c(X,i)
  }
}

Y <- NULL
for(j in 1:10){
  Y<-c(Y,rep(j,10))
}

Env_before<-envPop$envSelect

Env_after<-envPop.shift$envSelect

Diff_env<-Env_after-Env_before

Env_range<- envPop$envSelect%in%round(envPop.shift$envSelect,1)&round(envPop.shift$envSelect,1)%in%envPop$envSelect

M2_AF_before<-data.frame(Pop_afreq1_filt[,c(which(colnames(Pop_afreq1_filt)==M2_MID))])
colnames(M2_AF_before)<-"M2_AF_before"

M2_AF_after<-data.frame(Pop_afreq2_filt[,c(which(colnames(Pop_afreq2_filt)==M2_MID))])
colnames(M2_AF_after)<-"M2_AF_after"

M2_AF_diff<-M2_AF_after-M2_AF_before
colnames(M2_AF_diff)<-"M2_AF_diff"

M1_AF_before_all<-Pop_afreq1_filt[,-which(colnames(Pop_afreq1_filt)==M2_MID)]
M1_AF_after_all<-Pop_afreq2_filt[,-which(colnames(Pop_afreq2_filt)==M2_MID)]

M1_AF_before_shared<-M1_AF_before_all[colnames(M1_AF_before_all)%in%colnames(M1_AF_after_all)]
M1_AF_after_shared<-M1_AF_after_all[colnames(M1_AF_after_all)%in%colnames(M1_AF_before_all)]

M1_AF_before<-data.frame(rowMeans(M1_AF_before_shared))
colnames(M1_AF_before)<-"M1_AF_before"

M1_AF_after<-data.frame(rowMeans(M1_AF_after_shared))
colnames(M1_AF_after)<-"M1_AF_after"

M1_AF_diff<-M2_AF_after-M2_AF_before
colnames(M1_AF_diff)<-"M1_AF_diff"

F_ST_genome_bef.aft.<-data.frame(FST_genome_pop)
colnames(F_ST_genome_bef.aft.)<-"F_ST_genome_bef.aft."

F_ST_M2_bef.aft.<-data.frame(FST_M2_pop)
colnames(F_ST_M2_bef.aft.)<-"F_ST_M2_bef.aft."

Rel_Fit_before <- data.frame(fitt[fitt$Type=="Fit",gen_nam[length(gen_nam)-30]])
colnames(Rel_Fit_before)<-"Rel_Fit_before"

Rel_Fit_after <- data.frame(fitt[fitt$Type=="Fit",gen_nam[length(gen_nam)]])
colnames(Rel_Fit_after)<-"Rel_Fit_after"

Rel_Fit_diff<-Rel_Fit_after-Rel_Fit_before
colnames(Rel_Fit_diff)<-"Rel_Fit_diff"

Summary_Pop<-cbind(Pop,X,Y,Env_before,Env_after,Diff_env,Env_range,gfTrans1,gfTrans2,offset,gfM2Trans1,gfM2Trans2,M2offset,M2_AF_before,M2_AF_after,M2_AF_diff,M1_AF_before,M1_AF_after,M1_AF_diff,F_ST_genome_bef.aft.,F_ST_M2_bef.aft.,Rel_Fit_before,Rel_Fit_after,Rel_Fit_diff)
write.csv(Summary_Pop,file=paste("Summary_Pop_",s1,".csv",sep=""),row.names=F)


##################################
# Allele specific summary stats
##################################

r2<-data.frame(gfMod$result)
colnames(r2)<-"r2"


colfunc<-colorRampPalette(c("orange","cyan"))
