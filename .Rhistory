N<-data.frame(fit$n[1]*100)
colnames(N)<-"N"
if(ncol(fit)==613){
(specs<-data.frame(seed,fit[1,1:2],N,fit[1,3:12]))
plotTitle <- paste(colnames(specs)[1],":",specs[[1]],", ", colnames(specs)[2],":",specs[2],", ",colnames(specs)[3],":",specs[3],", ",colnames(specs)[4],":",specs[4],",",colnames(specs)[5],":",specs[5],"\n",colnames(specs)[6],":",specs[6],", ",colnames(specs)[7],":",specs[7],", ",colnames(specs)[8],":",specs[8],", ",colnames(specs)[9],":",specs[9],", ",colnames(specs)[10],":",specs[10], sep="")
fitt<-data.frame(t(fit[,-1:-13]))
} else {
(specs<-data.frame(seed,fit[1,1:2],N,fit[1,3:13])) # for case4
plotTitle <- paste(colnames(specs)[1],":",specs[[1]],", ", colnames(specs)[2],":",specs[2],", ",colnames(specs)[3],":",specs[3],", ",colnames(specs)[4],":",specs[4],",",colnames(specs)[5],":",specs[5],"\n",colnames(specs)[6],":",specs[6],", ",colnames(specs)[7],":",specs[7],", ",colnames(specs)[8],":",specs[8],", ",colnames(specs)[9],":",specs[9],", ",colnames(specs)[10],":",specs[10],", ",colnames(specs)[11],":",specs[11],sep="") # for case4
fitt<-data.frame(t(fit[,-1:-14])) # for case4
}
gen_nam <- paste("Gen",fit$Generation,sep="")
colnames(fitt)<-gen_nam
fitt$Location <- factor(rep(paste("P",1:100,sep=""),6), levels = unique(rep(paste("P",1:100,sep=""),6)))
fitt$Type <- as.factor(c(rep("Fit",100),rep("Freq",100),rep("Phen1",100), rep("Phen2",100),rep("Env1",100), rep("Env2",100)))
#VCF files are filtered with vcftools, as it is much faster than R. The filtering for MAF > 0.05 is accomplished with the following code:
vcf1_filt <- read.vcfR(paste("results/SLiM_output/VCF_files/T1_",seed,"_filtered_subset.recode.vcf",sep=""))
geno1_filt <- vcf1_filt@gt[,-1] # Remove 1st column, which is 'Format'
position1_filt <- as.numeric(getPOS(vcf1_filt)) # Positions in bp
chromosome1_filt <- as.numeric(getCHROM(vcf1_filt)) # Chromosome information
No_A<-unname(dim(vcf1_filt)[2]) #Get the number of filtered alleles
rm(vcf1_filt)
gc()
#Create Genotype matrix
G1f <- matrix(NA, nrow = nrow(geno1_filt), ncol = ncol(geno1_filt))
G1f[geno1_filt %in% c("0/0", "0|0")] <- 0
G1f[geno1_filt %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G1f[geno1_filt %in% c("1/1", "1|1")] <- 2
#Occasionally have a "2|#" genotype show up because of overlapping mutations from SLiM. This procuded NA genotypes which breaks
#the per locus FST calc. later, so this just gets rid of overlapped sites
G1f[!geno1_filt %in% c("0/0", "0|0", "0/1", "1/0", "1|0", "0|1", "1/1", "1|1")] <- 0
#Occasionally have a "2|#" genotype show up because of overlapping mutations from SLiM. This procuded NA genotypes which breaks
#the per locus FST calc. later, so this just gets rid of overlapped sites
geno1_filt[!geno1_filt %in% c("0/0", "0|0", "0/1", "1/0", "1|0", "0|1", "1/1", "1|1")]
#Occasionally have a "2|#" genotype show up because of overlapping mutations from SLiM. This procuded NA genotypes which breaks
#the per locus FST calc. later, so this just gets rid of overlapped sites
any(geno1_filt[!geno1_filt %in% c("0/0", "0|0", "0/1", "1/0", "1|0", "0|1", "1/1", "1|1")])
?writeLines
#Occasionally have a "2|#" genotype show up because of overlapping mutations from SLiM. This procuded NA genotypes which breaks
#the per locus FST calc. later, so this just gets rid of overlapped sites
if(any(geno1_filt[!geno1_filt %in% c("0/0", "0|0", "0/1", "1/0", "1|0", "0|1", "1/1", "1|1")])){
writeLines("Replaced unusual genotypes with '0|0'")
}
G1f[!geno1_filt %in% c("0/0", "0|0", "0/1", "1/0", "1|0", "0|1", "1/1", "1|1")] <- 0
#Check number of duplicate positions
sum(duplicated(position1_filt))
position1_filt[duplicated(position1_filt)]
#Read in positions of m2 mutations
pos_T1<-scan(paste("results/SLiM_output/Sim_sum/",seed,"_T1_Pos_ML_WF.txt",sep=""))
select_pos_num <-unique(pos_T1)
duplic_pos <- position1_filt[duplicated(position1_filt)]
select_pos <- paste("M",unique(pos_T1),sep="")
for(i in 1:length(position1_filt)){
if(duplicated(position1_filt)[i]){
position1_filt[i]<-position1_filt[i]+0.5
#print(position1_filt[i])
}
}
Start<-seq(1,ncol(geno1_filt),10)
#Stop<-seq(100,ncol(geno1_filt),10)
Stop<-seq(10,ncol(geno1_filt),10)
Pop_afreq1<-NULL
for(i in 1:100){
Pop_afreq1<-rbind(Pop_afreq1,rowSums(G1f[,Start[i]:Stop[i]])/(2*ncol(G1f[,Start[i]:Stop[i]])))
#print(paste("Start:", Start[i],", Stop:", Stop[i]))
}
Pop_afreq1<-data.frame(Pop_afreq1)
colnames(Pop_afreq1)<-paste("M",position1_filt,sep="")
#######################################################
# Set up environmental vartiables for Gradient Forest
#######################################################
cg<-read.table(paste("results/SLiM_output/CG_files/",seed,"_fitnessmat_pop.txt",sep=""),header=F)
colnames(cg)<-rep(paste("H",seq(1:100),sep=""))
cg$Transplant<-paste("T",seq(1:100),sep="")
cg_df <- melt(cg,  id.vars ="Transplant",  variable.name = "Home",
value.name = "Fitness")
cg_df$Transplant<-factor(cg_df$Transplant,levels=unique(cg_df$Transplant))
#Subset the environmental variables for the generation you're considering (make sure the M2 AF and environmental data are not being compare across generations)
envPop1<-data.frame(fitt[fitt$Type=="Env1",gen_nam[length(gen_nam)-3]]) #300 years prior to the end of the simulation is taken as the "before environmental shift" time
names(envPop1) <- "envPop1"
fakeEnv1 <- envPop1$envPop1 + rnorm(nrow(envPop1),0,1.3)
cor(envPop1$envPop1, fakeEnv1)
envPop2<-data.frame(fitt[fitt$Type=="Env2",gen_nam[length(gen_nam)-3]]) #300 years prior to the end of the simulation is taken as the "before environmental shift" time
names(envPop2) <- "envPop2"
fakeEnv2 <- envPop2$envPop2 + rnorm(nrow(envPop2),0,1.3)
# this standard deviation generally produces a correlation between 0.3 and 0.6
cor(envPop2$envPop2, fakeEnv2)
Pop <- levels(fitt$Location)
Popsenv <- data.frame(Pop, envPop1,envPop2,fakeEnv1,fakeEnv2)
nfake <- 10
Popsenv[,6:(5+nfake)] <- NA
cov1 <- genPositiveDefMat(nfake,covMethod="unifcorrmat" )
head(cov1)
a<- mvrnorm(nrow(Popsenv),mu=rep(0, nfake), Sigma=cov1$Sigma)
Popsenv[,6:(5+nfake)] <- a
sel_env_cols <- 2:3
all_env_cols <- 2:ncol(Popsenv)
sel_env_cols_plus2 <- 2:5
cov_allEnv <- cov(Popsenv[,all_env_cols])
round(cov_allEnv,2)
cov_allEnv <- cov(Popsenv[,all_env_cols])
round(cov_allEnv,2)
mahalanobis(as.numeric(e1),
as.numeric(e2),
cov_allEnv)
(e1 <- Popsenv[1,sel_env_cols]) # The common garden environment
(e2 <- Popsenv[50,sel_env_cols]) # The origin environment of the population/individual
cov_allEnv <- cov(Popsenv[,all_env_cols])
round(cov_allEnv,2)
mahalanobis(as.numeric(e1),
as.numeric(e2),
cov_allEnv)
(e1 <- Popsenv[1,all_env_cols]) # The common garden environment
(e2 <- Popsenv[50,all_env_cols]) # The origin environment of the population/individual
cov_allEnv <- cov(Popsenv[,all_env_cols])
round(cov_allEnv,2)
mahalanobis(as.numeric(e1),
as.numeric(e2),
cov_allEnv)
heatmap(cor(Popsenv[all_env_cols]))
for (i in 1:nrow(cg_df)){
# get the row in PopsenvStnd for the common garden genotype
row1 = which(Popsenv==gsub("T","P",as.character(cg_df$Transplant[i])))
# get the row in PopsenvStnd for the genotype source
row2 = which(Popsenv==gsub("H","P",as.character(cg_df$Home[i])))
# Look up the envi (all var)
(envpop1_all <- Popsenv[row1,all_env_cols])
(envpop2_all <- Popsenv[row2,all_env_cols])
# Look up the envi selected only
(envpop1_sel <- Popsenv[row1,sel_env_cols])
(envpop2_sel <- Popsenv[row2,sel_env_cols])
# Look up the envi selected plus 2 correlated env
(envpop1_sel_plus2 <- Popsenv[row1,sel_env_cols_plus2])
(envpop2_sel_plus2 <- Popsenv[row2,sel_env_cols_plus2])
### Calculate the environmental distance between the two rows
# Euclidean distance for selective environments
CGfit$EdSelEnv[i] <- dist(rbind(envpop1_sel,
envpop2_sel))
# Mahalanobis distance for selective environments
CGfit$MdSelEnv[i] <- mahalanobis(as.numeric(envpop1_sel),
as.numeric(envpop2_sel),
cov_selEnv)
# Euclidean distance for ALL environments
CGfit$EdAllEnv[i] <- dist(rbind(envpop1_all,
envpop2_all))
# Mahalanobis distance for ALL environments
CGfit$MdAllEnv[i] <- mahalanobis(as.numeric(envpop1_all),
as.numeric(envpop2_all),
cov_allEnv)
# Euclidean distance for selective environments + 2 env
CGfit$EdSelEnvPlus2[i] <- dist(rbind(envpop1_sel_plus2,
envpop2_sel_plus2))
# Mahalanobis distance for selective environments + 2 env
CGfit$MdSelEnvPlus2[i] <- mahalanobis(as.numeric(envpop1_sel_plus2),
as.numeric(envpop2_sel_plus2),
cov_selEnv_plus2)
}
for (i in 1:nrow(cg_df)){
# get the row in PopsenvStnd for the common garden genotype
row1 = which(Popsenv==gsub("T","P",as.character(cg_df$Transplant[i])))
# get the row in PopsenvStnd for the genotype source
row2 = which(Popsenv==gsub("H","P",as.character(cg_df$Home[i])))
# Look up the envi (all var)
(envpop1_all <- Popsenv[row1,all_env_cols])
(envpop2_all <- Popsenv[row2,all_env_cols])
# Look up the envi selected only
(envpop1_sel <- Popsenv[row1,sel_env_cols])
(envpop2_sel <- Popsenv[row2,sel_env_cols])
# Look up the envi selected plus 2 correlated env
(envpop1_sel_plus2 <- Popsenv[row1,sel_env_cols_plus2])
(envpop2_sel_plus2 <- Popsenv[row2,sel_env_cols_plus2])
### Calculate the environmental distance between the two rows
# Euclidean distance for selective environments
cg_df$EdSelEnv[i] <- dist(rbind(envpop1_sel,
envpop2_sel))
# Mahalanobis distance for selective environments
cg_df$MdSelEnv[i] <- mahalanobis(as.numeric(envpop1_sel),
as.numeric(envpop2_sel),
cov_selEnv)
# Euclidean distance for ALL environments
cg_df$EdAllEnv[i] <- dist(rbind(envpop1_all,
envpop2_all))
# Mahalanobis distance for ALL environments
cg_df$MdAllEnv[i] <- mahalanobis(as.numeric(envpop1_all),
as.numeric(envpop2_all),
cov_allEnv)
# Euclidean distance for selective environments + 2 env
cg_df$EdSelEnvPlus2[i] <- dist(rbind(envpop1_sel_plus2,
envpop2_sel_plus2))
# Mahalanobis distance for selective environments + 2 env
cg_df$MdSelEnvPlus2[i] <- mahalanobis(as.numeric(envpop1_sel_plus2),
as.numeric(envpop2_sel_plus2),
cov_selEnv_plus2)
}
cov_allEnv <- cov(Popsenv[,all_env_cols])
cov_selEnv <- cov(Popsenv[,sel_env_cols])
cov_selEnv_plus2 <- cov(Popsenv[,sel_env_cols_plus2])
for (i in 1:nrow(cg_df)){
# get the row in PopsenvStnd for the common garden genotype
row1 = which(Popsenv==gsub("T","P",as.character(cg_df$Transplant[i])))
# get the row in PopsenvStnd for the genotype source
row2 = which(Popsenv==gsub("H","P",as.character(cg_df$Home[i])))
# Look up the envi (all var)
(envpop1_all <- Popsenv[row1,all_env_cols])
(envpop2_all <- Popsenv[row2,all_env_cols])
# Look up the envi selected only
(envpop1_sel <- Popsenv[row1,sel_env_cols])
(envpop2_sel <- Popsenv[row2,sel_env_cols])
# Look up the envi selected plus 2 correlated env
(envpop1_sel_plus2 <- Popsenv[row1,sel_env_cols_plus2])
(envpop2_sel_plus2 <- Popsenv[row2,sel_env_cols_plus2])
### Calculate the environmental distance between the two rows
# Euclidean distance for selective environments
cg_df$EdSelEnv[i] <- dist(rbind(envpop1_sel,
envpop2_sel))
# Mahalanobis distance for selective environments
cg_df$MdSelEnv[i] <- mahalanobis(as.numeric(envpop1_sel),
as.numeric(envpop2_sel),
cov_selEnv)
# Euclidean distance for ALL environments
cg_df$EdAllEnv[i] <- dist(rbind(envpop1_all,
envpop2_all))
# Mahalanobis distance for ALL environments
cg_df$MdAllEnv[i] <- mahalanobis(as.numeric(envpop1_all),
as.numeric(envpop2_all),
cov_allEnv)
# Euclidean distance for selective environments + 2 env
cg_df$EdSelEnvPlus2[i] <- dist(rbind(envpop1_sel_plus2,
envpop2_sel_plus2))
# Mahalanobis distance for selective environments + 2 env
cg_df$MdSelEnvPlus2[i] <- mahalanobis(as.numeric(envpop1_sel_plus2),
as.numeric(envpop2_sel_plus2),
cov_selEnv_plus2)
}
start_time <- Sys.time()
end_time <- Sys.time()
print(end_time - start_time)
print("For Env. distance calculation\n",end_time - start_time)
print(c("For Env. distance calculation\n",end_time - start_time))
print("For the environmental distance calculation")
print(end_time - start_time)
writeLines("Environmental distance calculation")
print(end_time - start_time)
View(cg_df)
View(Popsenv)
envTab
envTab <- cbind(envPop1,envPop2,fakeEnv1,fakeEnv2)
View(envTab)
View(Popsenv)
Popsenv <- data.frame(envPop1,envPop2,fakeEnv1,fakeEnv2)
Popsenv <- data.frame(envPop1,envPop2,fakeEnv1,fakeEnv2)
nfake <- 10
Popsenv[,5:(5+nfake)] <- NA
cov1 <- genPositiveDefMat(nfake,covMethod="unifcorrmat" )
head(cov1)
a<- mvrnorm(nrow(Popsenv),mu=rep(0, nfake), Sigma=cov1$Sigma)
Popsenv[,5:(5+nfake)] <- a
5+nfake
Popsenv
Popsenv <- data.frame(envPop1,envPop2,fakeEnv1,fakeEnv2)
nfake <- 10
Popsenv[,5:(4+nfake)] <- NA
cov1 <- genPositiveDefMat(nfake,covMethod="unifcorrmat" )
head(cov1)
a<- mvrnorm(nrow(Popsenv),mu=rep(0, nfake), Sigma=cov1$Sigma)
Popsenv[,5:(4+nfake)] <- a
#Merge the population specific allele frequencies of all neutral (M1) alleles with the population specific frequency of the selected (M2) allele
#alFreq<-cbind(data.frame(Pop_afreq1))
alFreq<-Pop_afreq1
vars <- colnames(Popsenv)
vars
`getSplitImprove` <-function(fit, X) {
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
ok2 <- apply(ok, 2, sum)==nrow(ok)
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok2], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]==-3 & zapsmall(tmp[,"improve"]) > 0,c("split var","split point","improve")]
colnames(tmp) <- c("var_n","split","improve")
rownames(tmp)<-NULL     #S.J. Smith 11/05/2009
res <- cbind(data.frame(var=names(X)[tmp[,"var_n"]],rsq=rep(fit$rsq[fit$ntree],nrow(tmp))),tmp)
ok <- zapsmall(res[,"improve"]) > 0
res[ok,]
}
`getSplitImproveClassCompact` <- function(fit, bins, err0) {
#   Return a data-frame: var name, rsq, split value, improvement
#   Compact the splits into bins defined by bins matrix
#   The i'th bin for predictor p is the interval (bin[i,p],bin[i+1,p])
#   Every predictor is split into the same number of bins (nrow(bins)-1)
#   extract all trees to a matrix and select for splits with some improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
ok2 <- apply(ok, 2, sum)==nrow(ok)
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok2], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]== 1 & zapsmall(tmp[,"improve"]) > 0,c("split var","split point","improve")]
colnames(tmp) <- c("var_n","split","improve")
rownames(tmp) <- NULL
#   assign the split to the appropriate bin and aggregate importance in each bin
Xnames <- colnames(bins)
tmp <- data.frame(var=Xnames[tmp[,"var_n"]], tmp, bin=rep(0,nrow(tmp)))
for(p in Xnames) {
if(any(sub <- with(tmp,var==p)))
tmp$bin[sub] <- as.numeric(cut(tmp$split[sub], bins[,p], include=TRUE, ordered=TRUE))
}
tmp <- with(tmp[tmp$bin>0,],agg.sum(improve,list(var,bin),sort.it=TRUE))
names(tmp) <- c("var","bin","improve")
#   Set the split value to the bin centre, but retain the bin number in case
#   the bin centre is not appropriate value
tmp <- cbind(tmp,split=rep(NA,nrow(tmp)),rsq=rep((err0-fit$err.rate[fit$ntree, "OOB"])/err0, nrow(tmp)))
for(p in Xnames) {
if(any(sub <- with(tmp,var==p)))
tmp$split[sub] <- midpoints(bins[,p])[tmp$bin[sub]]
}
tmp[,c("var","rsq","split","improve","bin")]
}
`getSplitImproveClass` <- function(fit, X, err0)
{
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
ok2 <- apply(ok, 2, sum)==nrow(ok)
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok2], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]==1,c("split var","split point","improve")]
dimnames(tmp) <- list(NULL,c("var_n","split","improve"))
res<-cbind(data.frame(var=names(X)[tmp[,"var_n"]],rsq=rep((err0-fit$err.rate[fit$ntree,"OOB"])/err0,nrow(tmp))),tmp)
res
}
`Impurity.based.measures` <-function(obj)
{
#becomes an internal function not usually used by users
#Modified 07/10/2009 by SJS re: NE changes for classification trees.
dens <- lapply(names(obj$X), function(i) density(na.omit(obj$X[,i]),from=min(na.omit(obj$X[,i])),to=max(na.omit(obj$X[,i]))))
dens <- lapply(dens,whiten,lambda=0.90) # hard-coded whitening
names(dens) <- names(obj$X)
res <- do.call("rbind", lapply(names(obj$result), function(spec) cbind(spec=spec,obj$result[[spec]]))) #added by Smith 13/05/2009
res$spec <- as.factor(res$spec)
res$var <- as.factor(res$var)
res$improve <- pmax(0,res$improve)
res$rsq <- pmax(0,res$rsq)   #added by Ellis 12/05/2009
res$improve.tot <- tapply(res$improve,res$spec,sum)[res$spec]
res$improve.tot.var <- tapply(res$improve,interaction(res$spec,res$var),sum)[interaction(res$spec,res$var)]
res$improve.norm <- with(res,improve/improve.tot*rsq)
nodup <- !duplicated(res[,1:2])
res.u <- res[nodup, c("spec","var","rsq","improve.tot","improve.tot.var")]
res.u$rsq <- with(res.u, ifelse(is.na(rsq), 0, rsq))
res.u$rsq.var <- with(res.u,rsq*improve.tot.var/improve.tot)
list(res=res,res.u=res.u,dens=dens)
}
`whiten` <-  function(dens, lambda=0.9)
{
# add a small uniform value to the density to avoid zeroes when taking inverse
dens$y <- lambda*dens$y + (1-lambda)/diff(range(dens$x))
dens
}
gradientForest2<- function (data, predictor.vars, response.vars, ntree = 10, mtry = NULL,
transform = NULL, maxLevel = 0, corr.threshold = 0.5, compact = FALSE,
nbin = 101, trace = TRUE)
{
if (!inherits(data, "data.frame"))
stop("'data' must be a data.frame")
X <- data[predictor.vars]
Y <- data[response.vars]
if (compact) {
bins <- do.call("cbind", lapply(X, function(x) bin(x,
nbin = nbin)))
}
if (!is.null(transform)) {
Y <- apply(Y, 2, transform)
}
imp <- matrix(0, 0, 2, dimnames = list(NULL, c("%IncMSE",
"IncNodePurity")))
if (is.null(mtry))
fitcmd <- quote(randomForest(Species ~ rhs, data = cbind(Y,
X), maxLevel = maxLevel, keep.forest = TRUE, importance = TRUE,
ntree = ntree, keep.group = TRUE, keep.inbag = TRUE,
corr.threshold = corr.threshold, na.action = na.omit))
else fitcmd <- quote(randomForest(Species ~ rhs, data = cbind(Y,
X), maxLevel = maxLevel, keep.forest = TRUE, importance = TRUE,
ntree = ntree, mtry = mtry, keep.group = TRUE, keep.inbag = TRUE,
corr.threshold = corr.threshold, na.action = na.omit))
result <- list()
species.pos.rsq <- 0
form.rhs <- as.formula(paste("Y ~ ", paste(predictor.vars,
collapse = "+")))
if (trace) {
spcount <- 0
cat("Calculating forests for", length(response.vars),
"species\n")
}
##################################
#Here is the problem
##################################
for (spec in response.vars) {
if (trace)
cat(if ((spcount <- spcount + 1)%%options("width")$width ==
0)
"\n."
else ".")
try({
# spec <- response.vars[1]
thisfitcmd <- do.call("substitute", list(fitcmd,
list(Species = as.name(spec), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
fit <- eval(thisfitcmd)
if (fit$type == "regression") {
if (!is.na(fit$rsq[fit$ntree])) {
if (fit$rsq[fit$ntree] > 0) {
species.pos.rsq <- species.pos.rsq + 1
if (compact) {
result[[spec]] <- getSplitImproveCompact(fit,
bins)
}
else {
result[[spec]] <- getSplitImprove(fit,
X)
}
imp <- rbind(imp, fit$importance)
}
}
}
else if (fit$type == "classification") {
if (!is.na(fit$err.rate[fit$ntree, "OOB"])) {
p <- sum(Y[[spec]] == levels(Y[[spec]])[1])/length(Y[[spec]])
err0 <- 2 * p * (1 - p)
if (fit$err.rate[fit$ntree, "OOB"] <
2 * p * (1 - p)) {
species.pos.rsq <- species.pos.rsq + 1
if (compact) {
result[[spec]] <- getSplitImproveClassCompact(fit,
bins, err0)
}
else {
result[[spec]] <- getSplitImproveClass(fit,
X, err0)
}
nclass <- length(levels(Y[[spec]]))
imp <- rbind(imp, fit$importance[, -(1:nclass)])
}
}
}
else stop(paste("unknown randomForest type:",
fit$type))
}, silent = FALSE)
}
if (!length(result)) {
warning("No species models provided a positive R^2. \nThe gradient forest is empty")
return(NULL)
}
rsq <- sapply(result, function(x) x$rsq[1])
imp.rsq <- matrix(imp[, 1], length(predictor.vars), dimnames = list(predictor.vars,
names(result)))
imp.rsq[imp.rsq < 0] <- 0
imp.rsq <- sweep(imp.rsq, 2, colSums(imp.rsq, na.rm = T),
"/")
imp.rsq <- sweep(imp.rsq, 2, rsq, "*")
overall.imp <- tapply(imp[, 1], dimnames(imp)[[1]], mean,
na.rm = T)
overall.imp2 <- tapply(imp[, 2], dimnames(imp)[[1]], mean,
na.rm = T)
out1 <- list(X = X, Y = Y, result = result, overall.imp = overall.imp,
overall.imp2 = overall.imp2, ntree = ntree, imp.rsq = imp.rsq,
species.pos.rsq = species.pos.rsq, ranForest.type = fit$type)
out2 <- Impurity.based.measures(out1)
out1$result <- rsq
out <- c(out1, out2, call = match.call())
class(out) <- c("gradientForest", "list")
out
}
gfMod_all <- gradientForest2(data=data.frame(envTab[, vars], alFreq),
predictor.vars=vars,
response.vars=colnames(alFreq),
corr.threshold=0.5 ,
ntree=500,
trace=T)
envTab <- Popsenv
vars <- colnames(envTab)
envTab <- Popsenv
colnames(envTab)
vars <- colnames(envTab)
envTab[, vars]
gfMod_all <- gradientForest2(data=data.frame(envTab[, vars], alFreq),
predictor.vars=vars,
response.vars=colnames(alFreq),
corr.threshold=0.5 ,
ntree=500,
trace=T)
seed=seed_table$V3[1]
#seed=commandArgs(trailingOnly=T)
fit<-read.table(paste("results/SLiM_output/Sim_sum/",seed,"_Freq_ML_WF.txt",sep=""), header=T)
N<-data.frame(fit$n[1]*100)
colnames(N)<-"N"
if(ncol(fit)==613){
(specs<-data.frame(seed,fit[1,1:2],N,fit[1,3:12]))
plotTitle <- paste(colnames(specs)[1],":",specs[[1]],", ", colnames(specs)[2],":",specs[2],", ",colnames(specs)[3],":",specs[3],", ",colnames(specs)[4],":",specs[4],",",colnames(specs)[5],":",specs[5],"\n",colnames(specs)[6],":",specs[6],", ",colnames(specs)[7],":",specs[7],", ",colnames(specs)[8],":",specs[8],", ",colnames(specs)[9],":",specs[9],", ",colnames(specs)[10],":",specs[10], sep="")
fitt<-data.frame(t(fit[,-1:-13]))
} else {
(specs<-data.frame(seed,fit[1,1:2],N,fit[1,3:13])) # for case4
plotTitle <- paste(colnames(specs)[1],":",specs[[1]],", ", colnames(specs)[2],":",specs[2],", ",colnames(specs)[3],":",specs[3],", ",colnames(specs)[4],":",specs[4],",",colnames(specs)[5],":",specs[5],"\n",colnames(specs)[6],":",specs[6],", ",colnames(specs)[7],":",specs[7],", ",colnames(specs)[8],":",specs[8],", ",colnames(specs)[9],":",specs[9],", ",colnames(specs)[10],":",specs[10],", ",colnames(specs)[11],":",specs[11],sep="") # for case4
fitt<-data.frame(t(fit[,-1:-14])) # for case4
}
gen_nam <- paste("Gen",fit$Generation,sep="")
colnames(fitt)<-gen_nam
fitt$Location <- factor(rep(paste("P",1:100,sep=""),6), levels = unique(rep(paste("P",1:100,sep=""),6)))
fitt$Type <- as.factor(c(rep("Fit",100),rep("Freq",100),rep("Phen1",100), rep("Phen2",100),rep("Env1",100), rep("Env2",100)))
#VCF files are filtered with vcftools, as it is much faster than R. The filtering for MAF > 0.05 is accomplished with the following code:
vcf1_filt <- read.vcfR(paste("results/SLiM_output/VCF_files/T1_",seed,"_filtered_subset.recode.vcf",sep=""))
geno1_filt <- vcf1_filt@gt[,-1] # Remove 1st column, which is 'Format'
position1_filt <- as.numeric(getPOS(vcf1_filt)) # Positions in bp
chromosome1_filt <- as.numeric(getCHROM(vcf1_filt)) # Chromosome information
No_A<-unname(dim(vcf1_filt)[2]) #Get the number of filtered alleles
rm(list=ls())
gc()
