gc()
require(OutFLANK)
require(vcfR)
require(adegenet)
require(gdm)
require(gradientForest)
require(foreach)
require(doParallel)
require(pbapply)
require(gdata)
require(data.table)
require(PresenceAbsence)
require(ROCR)
require(modEvA)
require(dplyr)
require(grid)
require(gridExtra)
require(gtools)
require(stringr)
require(reshape2)
require(hierfstat)
options(scipen = 999)
#cores <- 7
#cl <- makeCluster(cores)
#registerDoParallel(cl)
#setwd("/Users/akijarl/Desktop/PostDoc/TTT_Offset_Vulnerability_GF_Sims/")
#setwd("/Users/akijarl/Desktop/TTT_Offset_Vulnerability_GF_Sims/")
setwd("E:/Research_AJL/TTT_Offset_Vulnerability_GF_Sims/")
seed_table <- read.table("seeds_source.txt")
seed=seed_table$V3[2]
#f1<-list.files("results/SLiM_output/Sim_sum")[grep(".txt",list.files("results/SLiM_output/Sim_sum"))][16]
#(seed<-substr(f1, start=1, stop=13))
#fit<-read.table(paste("Fit_SP_100_",seed,".txt",sep=""),fill=T)
fit<-read.table(paste("results/SLiM_output/Sim_sum/",seed,"_Freq_ML_WF.txt",sep=""), header=T)
N<-data.frame(fit$n[1]*100)
colnames(N)<-"N"
(specs<-data.frame(seed,fit[1,1:2],N,fit[1,3:12]))
#write.table(fit,"results/SLiM_output/Sim_sum/1599298910931_Freq_ML_WF.csv",quote=F,sep=",",row.names=F)
#write.table(specs,"R_results/output_metadata.txt",append=F,quote=F,sep=",",row.names=F)
plotTitle <- paste(colnames(specs)[1],":",specs[[1]],", ", colnames(specs)[2],":",specs[2],", ",colnames(specs)[3],":",specs[3],", ",colnames(specs)[4],":",specs[4],",",colnames(specs)[5],":",specs[5],"\n",colnames(specs)[6],":",specs[6],", ",colnames(specs)[7],":",specs[7],", ",colnames(specs)[8],":",specs[8],", ",colnames(specs)[9],":",specs[9],", ",colnames(specs)[10],":",specs[10], sep="")
gen_nam <- paste("Gen",fit$Generation,sep="")
fitt<-data.frame(t(fit[,-1:-13]))
colnames(fitt)<-gen_nam
fitt$Location <- factor(rep(paste("A",1:100,sep=""),6), levels = unique(rep(paste("A",1:100,sep=""),6)))
fitt$Type <- as.factor(c(rep("Fit",100),rep("Freq",100),rep("Phen1",100), rep("Phen2",100),rep("Env1",100), rep("Env2",100)))
vcf1_filt <- read.vcfR(paste("results/SLiM_output/VCF_files/T1_",seed,"_filtered_subset.recode.vcf",sep=""))
geno1_filt <- vcf1_filt@gt[,-1] # Remove 1st column, which is 'Format'
position1_filt <- as.numeric(getPOS(vcf1_filt)) # Positions in bp
chromosome1_filt <- as.numeric(getCHROM(vcf1_filt)) # Chromosome information
No_A<-unname(dim(vcf1_filt)[2]) #Get the number of filtered alleles
rm(vcf1_filt)
gc()
#Create Genotype matrix
G1f <- matrix(NA, nrow = nrow(geno1_filt), ncol = ncol(geno1_filt))
G1f[geno1_filt %in% c("0/0", "0|0")] <- 0
G1f[geno1_filt %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G1f[geno1_filt %in% c("1/1", "1|1")] <- 2
geno1_filt[!geno1_filt %in% c("0/0", "0|0", "0/1", "1/0", "1|0", "0|1", "1/1", "1|1")]
#Check number of duplicate positions
sum(duplicated(position1_filt))
position1_filt[duplicated(position1_filt)]
#Read in positions of m2 mutations
pos_T1<-scan(paste("results/SLiM_output/Sim_sum/",seed,"_T1_Pos_ML_WF.txt",sep=""))
select_pos_num <-unique(pos_T1)
duplic_pos <- position1_filt[duplicated(position1_filt)]
select_pos <- paste("M",unique(pos_T1),sep="")
for(i in 1:length(position1_filt)){
if(duplicated(position1_filt)[i]){
position1_filt[i]<-position1_filt[i]+0.5
#print(position1_filt[i])
}
}
Start<-seq(1,ncol(geno1_filt),10)
#Stop<-seq(100,ncol(geno1_filt),10)
Stop<-seq(10,ncol(geno1_filt),10)
Pop_afreq1<-NULL
for(i in 1:100){
Pop_afreq1<-rbind(Pop_afreq1,rowSums(G1f[,Start[i]:Stop[i]])/(2*ncol(G1f[,Start[i]:Stop[i]])))
#print(paste("Start:", Start[i],", Stop:", Stop[i]))
}
Pop_afreq1<-data.frame(Pop_afreq1)
colnames(Pop_afreq1)<-paste("M",position1_filt,sep="")
#Subset the environmental variables for the generation you're considering (make sure the M2 AF and environmental data are not being compare across generations)
envPop1<-data.frame(fitt[fitt$Type=="Env1",gen_nam[length(gen_nam)-3]]) #300 years prior to the end of the simulation is taken as the "before environmental shift" time
names(envPop1) <- "envPop1"
fakeEnv1 <- envPop1$envPop1 + rnorm(nrow(envPop1),0,1.3)
cor(envPop1$envPop1, fakeEnv1)
envPop2<-data.frame(fitt[fitt$Type=="Env2",gen_nam[length(gen_nam)-3]]) #300 years prior to the end of the simulation is taken as the "before environmental shift" time
names(envPop2) <- "envPop2"
fakeEnv2 <- envPop2$envPop2 + rnorm(nrow(envPop2),0,1.3)
# this standard deviation generally produces a correlation between 0.3 and 0.6
cor(envPop2$envPop2, fakeEnv2)
envTab <- cbind(envPop1,envPop2,fakeEnv1,fakeEnv2)
#envTab <- cbind(envTab$envPop1/sd(envPop1$envPop1),envTab$envPop2/sd(envPop2$envPop2),envTab$fakeEnv1/sd(fakeEnv1),envTab$fakeEnv2/sd(fakeEnv2))
colnames(envTab) <- c("envPop1","envPop2","fakeEnv1","fakeEnv2")
#Merge the population specific allele frequencies of all neutral (M1) alleles with the population specific frequency of the selected (M2) allele
#alFreq<-cbind(data.frame(Pop_afreq1))
alFreq<-Pop_afreq1
vars <- c("envPop1","envPop2","fakeEnv1","fakeEnv2")
`getSplitImprove` <-function(fit, X) {
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
ok2 <- apply(ok, 2, sum)==nrow(ok)
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok2], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]==-3 & zapsmall(tmp[,"improve"]) > 0,c("split var","split point","improve")]
colnames(tmp) <- c("var_n","split","improve")
rownames(tmp)<-NULL     #S.J. Smith 11/05/2009
res <- cbind(data.frame(var=names(X)[tmp[,"var_n"]],rsq=rep(fit$rsq[fit$ntree],nrow(tmp))),tmp)
ok <- zapsmall(res[,"improve"]) > 0
res[ok,]
}
`getSplitImproveClassCompact` <- function(fit, bins, err0) {
#   Return a data-frame: var name, rsq, split value, improvement
#   Compact the splits into bins defined by bins matrix
#   The i'th bin for predictor p is the interval (bin[i,p],bin[i+1,p])
#   Every predictor is split into the same number of bins (nrow(bins)-1)
#   extract all trees to a matrix and select for splits with some improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
ok2 <- apply(ok, 2, sum)==nrow(ok)
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok2], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]== 1 & zapsmall(tmp[,"improve"]) > 0,c("split var","split point","improve")]
colnames(tmp) <- c("var_n","split","improve")
rownames(tmp) <- NULL
#   assign the split to the appropriate bin and aggregate importance in each bin
Xnames <- colnames(bins)
tmp <- data.frame(var=Xnames[tmp[,"var_n"]], tmp, bin=rep(0,nrow(tmp)))
for(p in Xnames) {
if(any(sub <- with(tmp,var==p)))
tmp$bin[sub] <- as.numeric(cut(tmp$split[sub], bins[,p], include=TRUE, ordered=TRUE))
}
tmp <- with(tmp[tmp$bin>0,],agg.sum(improve,list(var,bin),sort.it=TRUE))
names(tmp) <- c("var","bin","improve")
#   Set the split value to the bin centre, but retain the bin number in case
#   the bin centre is not appropriate value
tmp <- cbind(tmp,split=rep(NA,nrow(tmp)),rsq=rep((err0-fit$err.rate[fit$ntree, "OOB"])/err0, nrow(tmp)))
for(p in Xnames) {
if(any(sub <- with(tmp,var==p)))
tmp$split[sub] <- midpoints(bins[,p])[tmp$bin[sub]]
}
tmp[,c("var","rsq","split","improve","bin")]
}
`getSplitImproveClass` <- function(fit, X, err0)
{
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
ok2 <- apply(ok, 2, sum)==nrow(ok)
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok2], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]==1,c("split var","split point","improve")]
dimnames(tmp) <- list(NULL,c("var_n","split","improve"))
res<-cbind(data.frame(var=names(X)[tmp[,"var_n"]],rsq=rep((err0-fit$err.rate[fit$ntree,"OOB"])/err0,nrow(tmp))),tmp)
res
}
`Impurity.based.measures` <-function(obj)
{
#becomes an internal function not usually used by users
#Modified 07/10/2009 by SJS re: NE changes for classification trees.
dens <- lapply(names(obj$X), function(i) density(na.omit(obj$X[,i]),from=min(na.omit(obj$X[,i])),to=max(na.omit(obj$X[,i]))))
dens <- lapply(dens,whiten,lambda=0.90) # hard-coded whitening
names(dens) <- names(obj$X)
res <- do.call("rbind", lapply(names(obj$result), function(spec) cbind(spec=spec,obj$result[[spec]]))) #added by Smith 13/05/2009
res$improve <- pmax(0,res$improve)
res$rsq <- pmax(0,res$rsq)   #added by Ellis 12/05/2009
res$improve.tot <- tapply(res$improve,res$spec,sum)[res$spec]
res$improve.tot.var <- tapply(res$improve,interaction(res$spec,res$var),sum)[interaction(res$spec,res$var)]
res$improve.norm <- with(res,improve/improve.tot*rsq)
nodup <- !duplicated(res[,1:2])
res.u <- res[nodup, c("spec","var","rsq","improve.tot","improve.tot.var")]
res.u$rsq <- with(res.u, ifelse(is.na(rsq), 0, rsq))
res.u$rsq.var <- with(res.u,rsq*improve.tot.var/improve.tot)
list(res=res,res.u=res.u,dens=dens)
}
`whiten` <-  function(dens, lambda=0.9)
{
# add a small uniform value to the density to avoid zeroes when taking inverse
dens$y <- lambda*dens$y + (1-lambda)/diff(range(dens$x))
dens
}
gradientForest2<- function (data, predictor.vars, response.vars, ntree = 10, mtry = NULL,
transform = NULL, maxLevel = 0, corr.threshold = 0.5, compact = FALSE,
nbin = 101, trace = TRUE)
{
if (!inherits(data, "data.frame"))
stop("'data' must be a data.frame")
X <- data[predictor.vars]
Y <- data[response.vars]
if (compact) {
bins <- do.call("cbind", lapply(X, function(x) bin(x,
nbin = nbin)))
}
if (!is.null(transform)) {
Y <- apply(Y, 2, transform)
}
imp <- matrix(0, 0, 2, dimnames = list(NULL, c("%IncMSE",
"IncNodePurity")))
if (is.null(mtry))
fitcmd <- quote(randomForest(Species ~ rhs, data = cbind(Y,
X), maxLevel = maxLevel, keep.forest = TRUE, importance = TRUE,
ntree = ntree, keep.group = TRUE, keep.inbag = TRUE,
corr.threshold = corr.threshold, na.action = na.omit))
else fitcmd <- quote(randomForest(Species ~ rhs, data = cbind(Y,
X), maxLevel = maxLevel, keep.forest = TRUE, importance = TRUE,
ntree = ntree, mtry = mtry, keep.group = TRUE, keep.inbag = TRUE,
corr.threshold = corr.threshold, na.action = na.omit))
result <- list()
species.pos.rsq <- 0
form.rhs <- as.formula(paste("Y ~ ", paste(predictor.vars,
collapse = "+")))
if (trace) {
spcount <- 0
cat("Calculating forests for", length(response.vars),
"species\n")
}
##################################
#Here is the problem
##################################
for (spec in response.vars) {
if (trace)
cat(if ((spcount <- spcount + 1)%%options("width")$width ==
0)
"\n."
else ".")
try({
# spec <- response.vars[1]
thisfitcmd <- do.call("substitute", list(fitcmd,
list(Species = as.name(spec), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
fit <- eval(thisfitcmd)
if (fit$type == "regression") {
if (!is.na(fit$rsq[fit$ntree])) {
if (fit$rsq[fit$ntree] > 0) {
species.pos.rsq <- species.pos.rsq + 1
if (compact) {
result[[spec]] <- getSplitImproveCompact(fit,
bins)
}
else {
result[[spec]] <- getSplitImprove(fit,
X)
}
imp <- rbind(imp, fit$importance)
}
}
}
else if (fit$type == "classification") {
if (!is.na(fit$err.rate[fit$ntree, "OOB"])) {
p <- sum(Y[[spec]] == levels(Y[[spec]])[1])/length(Y[[spec]])
err0 <- 2 * p * (1 - p)
if (fit$err.rate[fit$ntree, "OOB"] <
2 * p * (1 - p)) {
species.pos.rsq <- species.pos.rsq + 1
if (compact) {
result[[spec]] <- getSplitImproveClassCompact(fit,
bins, err0)
}
else {
result[[spec]] <- getSplitImproveClass(fit,
X, err0)
}
nclass <- length(levels(Y[[spec]]))
imp <- rbind(imp, fit$importance[, -(1:nclass)])
}
}
}
else stop(paste("unknown randomForest type:",
fit$type))
}, silent = FALSE)
}
if (!length(result)) {
warning("No species models provided a positive R^2. \nThe gradient forest is empty")
return(NULL)
}
rsq <- sapply(result, function(x) x$rsq[1])
imp.rsq <- matrix(imp[, 1], length(predictor.vars), dimnames = list(predictor.vars,
names(result)))
imp.rsq[imp.rsq < 0] <- 0
imp.rsq <- sweep(imp.rsq, 2, colSums(imp.rsq, na.rm = T),
"/")
imp.rsq <- sweep(imp.rsq, 2, rsq, "*")
overall.imp <- tapply(imp[, 1], dimnames(imp)[[1]], mean,
na.rm = T)
overall.imp2 <- tapply(imp[, 2], dimnames(imp)[[1]], mean,
na.rm = T)
out1 <- list(X = X, Y = Y, result = result, overall.imp = overall.imp,
overall.imp2 = overall.imp2, ntree = ntree, imp.rsq = imp.rsq,
species.pos.rsq = species.pos.rsq, ranForest.type = fit$type)
out2 <- Impurity.based.measures(out1)
out1$result <- rsq
out <- c(out1, out2, call = match.call())
class(out) <- c("gradientForest", "list")
out
}
gfMod_all <- gradientForest2(data=data.frame(envTab[, vars], alFreq),
predictor.vars=vars,
response.vars=colnames(alFreq),
corr.threshold=0.5 ,
ntree=500,
trace=T)
gfMod_all <- gradientForest(data=data.frame(envTab[, vars], alFreq),
predictor.vars=vars,
response.vars=colnames(alFreq),
corr.threshold=0.5 ,
ntree=500,
trace=T)
`getSplitImprove` <-function(fit, X) {
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
#ok2 <- apply(ok, 2, sum)==nrow(ok)
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]==-3 & zapsmall(tmp[,"improve"]) > 0,c("split var","split point","improve")]
colnames(tmp) <- c("var_n","split","improve")
rownames(tmp)<-NULL     #S.J. Smith 11/05/2009
res <- cbind(data.frame(var=names(X)[tmp[,"var_n"]],rsq=rep(fit$rsq[fit$ntree],nrow(tmp))),tmp)
ok <- zapsmall(res[,"improve"]) > 0
res[ok,]
}
`getSplitImproveClassCompact` <- function(fit, bins, err0) {
#   Return a data-frame: var name, rsq, split value, improvement
#   Compact the splits into bins defined by bins matrix
#   The i'th bin for predictor p is the interval (bin[i,p],bin[i+1,p])
#   Every predictor is split into the same number of bins (nrow(bins)-1)
#   extract all trees to a matrix and select for splits with some improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
#ok2 <- apply(ok, 2, sum)==nrow(ok)
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]== 1 & zapsmall(tmp[,"improve"]) > 0,c("split var","split point","improve")]
colnames(tmp) <- c("var_n","split","improve")
rownames(tmp) <- NULL
#   assign the split to the appropriate bin and aggregate importance in each bin
Xnames <- colnames(bins)
tmp <- data.frame(var=Xnames[tmp[,"var_n"]], tmp, bin=rep(0,nrow(tmp)))
for(p in Xnames) {
if(any(sub <- with(tmp,var==p)))
tmp$bin[sub] <- as.numeric(cut(tmp$split[sub], bins[,p], include=TRUE, ordered=TRUE))
}
tmp <- with(tmp[tmp$bin>0,],agg.sum(improve,list(var,bin),sort.it=TRUE))
names(tmp) <- c("var","bin","improve")
#   Set the split value to the bin centre, but retain the bin number in case
#   the bin centre is not appropriate value
tmp <- cbind(tmp,split=rep(NA,nrow(tmp)),rsq=rep((err0-fit$err.rate[fit$ntree, "OOB"])/err0, nrow(tmp)))
for(p in Xnames) {
if(any(sub <- with(tmp,var==p)))
tmp$split[sub] <- midpoints(bins[,p])[tmp$bin[sub]]
}
tmp[,c("var","rsq","split","improve","bin")]
}
`getSplitImproveClass` <- function(fit, X, err0)
{
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
#ok2 <- apply(ok, 2, sum)==nrow(ok)
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]==1,c("split var","split point","improve")]
dimnames(tmp) <- list(NULL,c("var_n","split","improve"))
res<-cbind(data.frame(var=names(X)[tmp[,"var_n"]],rsq=rep((err0-fit$err.rate[fit$ntree,"OOB"])/err0,nrow(tmp))),tmp)
res
}
`Impurity.based.measures` <-function(obj)
{
#becomes an internal function not usually used by users
#Modified 07/10/2009 by SJS re: NE changes for classification trees.
dens <- lapply(names(obj$X), function(i) density(na.omit(obj$X[,i]),from=min(na.omit(obj$X[,i])),to=max(na.omit(obj$X[,i]))))
dens <- lapply(dens,whiten,lambda=0.90) # hard-coded whitening
names(dens) <- names(obj$X)
res <- do.call("rbind", lapply(names(obj$result), function(spec) cbind(spec=spec,obj$result[[spec]]))) #added by Smith 13/05/2009
res$improve <- pmax(0,res$improve)
res$rsq <- pmax(0,res$rsq)   #added by Ellis 12/05/2009
res$improve.tot <- tapply(res$improve,res$spec,sum)[res$spec]
res$improve.tot.var <- tapply(res$improve,interaction(res$spec,res$var),sum)[interaction(res$spec,res$var)]
res$improve.norm <- with(res,improve/improve.tot*rsq)
nodup <- !duplicated(res[,1:2])
res.u <- res[nodup, c("spec","var","rsq","improve.tot","improve.tot.var")]
res.u$rsq <- with(res.u, ifelse(is.na(rsq), 0, rsq))
res.u$rsq.var <- with(res.u,rsq*improve.tot.var/improve.tot)
list(res=res,res.u=res.u,dens=dens)
}
`whiten` <-  function(dens, lambda=0.9)
{
# add a small uniform value to the density to avoid zeroes when taking inverse
dens$y <- lambda*dens$y + (1-lambda)/diff(range(dens$x))
dens
}
gradientForest2<- function (data, predictor.vars, response.vars, ntree = 10, mtry = NULL,
transform = NULL, maxLevel = 0, corr.threshold = 0.5, compact = FALSE,
nbin = 101, trace = TRUE)
{
if (!inherits(data, "data.frame"))
stop("'data' must be a data.frame")
X <- data[predictor.vars]
Y <- data[response.vars]
if (compact) {
bins <- do.call("cbind", lapply(X, function(x) bin(x,
nbin = nbin)))
}
if (!is.null(transform)) {
Y <- apply(Y, 2, transform)
}
imp <- matrix(0, 0, 2, dimnames = list(NULL, c("%IncMSE",
"IncNodePurity")))
if (is.null(mtry))
fitcmd <- quote(randomForest(Species ~ rhs, data = cbind(Y,
X), maxLevel = maxLevel, keep.forest = TRUE, importance = TRUE,
ntree = ntree, keep.group = TRUE, keep.inbag = TRUE,
corr.threshold = corr.threshold, na.action = na.omit))
else fitcmd <- quote(randomForest(Species ~ rhs, data = cbind(Y,
X), maxLevel = maxLevel, keep.forest = TRUE, importance = TRUE,
ntree = ntree, mtry = mtry, keep.group = TRUE, keep.inbag = TRUE,
corr.threshold = corr.threshold, na.action = na.omit))
result <- list()
species.pos.rsq <- 0
form.rhs <- as.formula(paste("Y ~ ", paste(predictor.vars,
collapse = "+")))
if (trace) {
spcount <- 0
cat("Calculating forests for", length(response.vars),
"species\n")
}
##################################
#Here is the problem
##################################
for (spec in response.vars) {
if (trace)
cat(if ((spcount <- spcount + 1)%%options("width")$width ==
0)
"\n."
else ".")
try({
# spec <- response.vars[1]
thisfitcmd <- do.call("substitute", list(fitcmd,
list(Species = as.name(spec), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
fit <- eval(thisfitcmd)
if (fit$type == "regression") {
if (!is.na(fit$rsq[fit$ntree])) {
if (fit$rsq[fit$ntree] > 0) {
species.pos.rsq <- species.pos.rsq + 1
if (compact) {
result[[spec]] <- getSplitImproveCompact(fit,
bins)
}
else {
result[[spec]] <- getSplitImprove(fit,
X)
}
imp <- rbind(imp, fit$importance)
}
}
}
else if (fit$type == "classification") {
if (!is.na(fit$err.rate[fit$ntree, "OOB"])) {
p <- sum(Y[[spec]] == levels(Y[[spec]])[1])/length(Y[[spec]])
err0 <- 2 * p * (1 - p)
if (fit$err.rate[fit$ntree, "OOB"] <
2 * p * (1 - p)) {
species.pos.rsq <- species.pos.rsq + 1
if (compact) {
result[[spec]] <- getSplitImproveClassCompact(fit,
bins, err0)
}
else {
result[[spec]] <- getSplitImproveClass(fit,
X, err0)
}
nclass <- length(levels(Y[[spec]]))
imp <- rbind(imp, fit$importance[, -(1:nclass)])
}
}
}
else stop(paste("unknown randomForest type:",
fit$type))
}, silent = FALSE)
}
if (!length(result)) {
warning("No species models provided a positive R^2. \nThe gradient forest is empty")
return(NULL)
}
rsq <- sapply(result, function(x) x$rsq[1])
imp.rsq <- matrix(imp[, 1], length(predictor.vars), dimnames = list(predictor.vars,
names(result)))
imp.rsq[imp.rsq < 0] <- 0
imp.rsq <- sweep(imp.rsq, 2, colSums(imp.rsq, na.rm = T),
"/")
imp.rsq <- sweep(imp.rsq, 2, rsq, "*")
overall.imp <- tapply(imp[, 1], dimnames(imp)[[1]], mean,
na.rm = T)
overall.imp2 <- tapply(imp[, 2], dimnames(imp)[[1]], mean,
na.rm = T)
out1 <- list(X = X, Y = Y, result = result, overall.imp = overall.imp,
overall.imp2 = overall.imp2, ntree = ntree, imp.rsq = imp.rsq,
species.pos.rsq = species.pos.rsq, ranForest.type = fit$type)
out2 <- Impurity.based.measures(out1)
out1$result <- rsq
out <- c(out1, out2, call = match.call())
class(out) <- c("gradientForest", "list")
out
}
gfMod_all <- gradientForest2(data=data.frame(envTab[, vars], alFreq),
predictor.vars=vars,
response.vars=colnames(alFreq),
corr.threshold=0.5 ,
ntree=500,
trace=T)
gfTrans1e1 <- predict(gfMod_all, envPop1)
predict
?predict
class(out)
str(gfMod_all)
