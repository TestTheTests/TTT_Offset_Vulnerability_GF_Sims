require(gtools, lib.loc=library.path)
require(stringr, lib.loc=library.path)
require(reshape2, lib.loc=library.path)
require(hierfstat)
install.packages("devtools")
library(STICH)
library(STITCH)
install.packages("Rcpp")
require(OutFLANK)
require(vcfR)
require(adegenet)
require(gdm)
require(gradientForest)
require(foreach)
require(doParallel)
require(pbapply)
require(gdata)
require(data.table)
require(PresenceAbsence)
require(ROCR)
require(modEvA)
require(dplyr)
require(grid)
require(gridExtra)
require(gtools)
require(stringr)
require(reshape2)
require(hierfstat)
require(OutFLANK)
require(vcfR)
require(adegenet)
require(gdm)
require(gradientForest)
require(foreach)
require(doParallel)
require(pbapply)
require(gdata)
require(data.table)
require(PresenceAbsence)
require(ROCR)
require(modEvA)
require(dplyr)
require(grid)
require(gridExtra)
require(gtools)
require(stringr)
require(reshape2)
require(hierfstat)
options(scipen = 999)
#cores <- 7
#cl <- makeCluster(cores)
#registerDoParallel(cl)
#setwd("/Users/akijarl/Desktop/PostDoc/TTT_Offset_Vulnerability_GF_Sims/")
#setwd("/Users/akijarl/Desktop/TTT_Offset_Vulnerability_GF_Sims/")
setwd("E:/Research_AJL/TTT_Offset_Vulnerability_GF_Sims/")
seed_table <- read.table("seeds_source.txt")
seed=seed_table$V3[2]
#f1<-list.files("results/SLiM_output/Sim_sum")[grep(".txt",list.files("results/SLiM_output/Sim_sum"))][16]
#(seed<-substr(f1, start=1, stop=13))
#fit<-read.table(paste("Fit_SP_100_",seed,".txt",sep=""),fill=T)
fit<-read.table(paste("results/SLiM_output/Sim_sum/",seed,"_Freq_ML_WF.txt",sep=""), header=T)
N<-data.frame(fit$n[1]*100)
colnames(N)<-"N"
(specs<-data.frame(seed,fit[1,1:2],N,fit[1,3:12]))
#write.table(fit,"results/SLiM_output/Sim_sum/1599298910931_Freq_ML_WF.csv",quote=F,sep=",",row.names=F)
#write.table(specs,"R_results/output_metadata.txt",append=F,quote=F,sep=",",row.names=F)
plotTitle <- paste(colnames(specs)[1],":",specs[[1]],", ", colnames(specs)[2],":",specs[2],", ",colnames(specs)[3],":",specs[3],", ",colnames(specs)[4],":",specs[4],",",colnames(specs)[5],":",specs[5],"\n",colnames(specs)[6],":",specs[6],", ",colnames(specs)[7],":",specs[7],", ",colnames(specs)[8],":",specs[8],", ",colnames(specs)[9],":",specs[9],", ",colnames(specs)[10],":",specs[10], sep="")
gen_nam <- paste("Gen",fit$Generation,sep="")
fitt<-data.frame(t(fit[,-1:-13]))
colnames(fitt)<-gen_nam
fitt$Location <- factor(rep(paste("A",1:100,sep=""),6), levels = unique(rep(paste("A",1:100,sep=""),6)))
fitt$Type <- as.factor(c(rep("Fit",100),rep("Freq",100),rep("Phen1",100), rep("Phen2",100),rep("Env1",100), rep("Env2",100)))
vcf1_filt <- read.vcfR(paste("results/SLiM_output/VCF_files/T1_",seed,"_filtered_subset.recode.vcf",sep=""))
geno1_filt <- vcf1_filt@gt[,-1] # Remove 1st column, which is 'Format'
position1_filt <- as.numeric(getPOS(vcf1_filt)) # Positions in bp
chromosome1_filt <- as.numeric(getCHROM(vcf1_filt)) # Chromosome information
No_A<-unname(dim(vcf1_filt)[2]) #Get the number of filtered alleles
rm(vcf1_filt)
gc()
#Create Genotype matrix
G1f <- matrix(NA, nrow = nrow(geno1_filt), ncol = ncol(geno1_filt))
G1f[geno1_filt %in% c("0/0", "0|0")] <- 0
G1f[geno1_filt %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G1f[geno1_filt %in% c("1/1", "1|1")] <- 2
geno1_filt[!geno1_filt %in% c("0/0", "0|0", "0/1", "1/0", "1|0", "0|1", "1/1", "1|1")]
#Check number of duplicate positions
sum(duplicated(position1_filt))
position1_filt[duplicated(position1_filt)]
#Read in positions of m2 mutations
pos_T1<-scan(paste("results/SLiM_output/Sim_sum/",seed,"_T1_Pos_ML_WF.txt",sep=""))
select_pos_num <-unique(pos_T1)
duplic_pos <- position1_filt[duplicated(position1_filt)]
select_pos <- paste("M",unique(pos_T1),sep="")
for(i in 1:length(position1_filt)){
if(duplicated(position1_filt)[i]){
position1_filt[i]<-position1_filt[i]+0.5
#print(position1_filt[i])
}
}
Start<-seq(1,ncol(geno1_filt),10)
#Stop<-seq(100,ncol(geno1_filt),10)
Stop<-seq(10,ncol(geno1_filt),10)
Pop_afreq1<-NULL
for(i in 1:100){
Pop_afreq1<-rbind(Pop_afreq1,rowSums(G1f[,Start[i]:Stop[i]])/(2*ncol(G1f[,Start[i]:Stop[i]])))
#print(paste("Start:", Start[i],", Stop:", Stop[i]))
}
Pop_afreq1<-data.frame(Pop_afreq1)
colnames(Pop_afreq1)<-paste("M",position1_filt,sep="")
#Subset the environmental variables for the generation you're considering (make sure the M2 AF and environmental data are not being compare across generations)
envPop1<-data.frame(fitt[fitt$Type=="Env1",gen_nam[length(gen_nam)-3]]) #300 years prior to the end of the simulation is taken as the "before environmental shift" time
names(envPop1) <- "envPop1"
fakeEnv1 <- envPop1$envPop1 + rnorm(nrow(envPop1),0,1.3)
cor(envPop1$envPop1, fakeEnv1)
envPop2<-data.frame(fitt[fitt$Type=="Env2",gen_nam[length(gen_nam)-3]]) #300 years prior to the end of the simulation is taken as the "before environmental shift" time
names(envPop2) <- "envPop2"
fakeEnv2 <- envPop2$envPop2 + rnorm(nrow(envPop2),0,1.3)
# this standard deviation generally produces a correlation between 0.3 and 0.6
cor(envPop2$envPop2, fakeEnv2)
envTab <- cbind(envPop1,envPop2,fakeEnv1,fakeEnv2)
#envTab <- cbind(envTab$envPop1/sd(envPop1$envPop1),envTab$envPop2/sd(envPop2$envPop2),envTab$fakeEnv1/sd(fakeEnv1),envTab$fakeEnv2/sd(fakeEnv2))
colnames(envTab) <- c("envPop1","envPop2","fakeEnv1","fakeEnv2")
#Merge the population specific allele frequencies of all neutral (M1) alleles with the population specific frequency of the selected (M2) allele
#alFreq<-cbind(data.frame(Pop_afreq1))
alFreq<-Pop_afreq1
vars <- c("envPop1","envPop2","fakeEnv1","fakeEnv2")
gfMod_all <- gradientForest(data=data.frame(envTab[, vars], alFreq),
predictor.vars=vars,
response.vars=colnames(alFreq),
corr.threshold=0.5 ,
ntree=500,
trace=T)
gradientForest()
gradientForest
data = data.frame(envTab[, vars], alFreq)
View(data)
data = data.frame(envTab[, vars], alFreq)
predictor.vars = vars
response.vars = colnames(alFreq)
inherits(data, "data.frame")
X <- data[predictor.vars]
Y <- data[response.vars]
is.null(transform)
transform = NULL
!is.null(transform)
imp <- matrix(0, 0, 2, dimnames = list(NULL, c("%IncMSE",
"IncNodePurity")))
View(imp)
is.null(mtry)
ntree = 10
mtry = NULL
maxLevel = 0
corr.threshold = 0.5
compact = FALSE
nbin = 101
trace = TRUE
is.null(mtry)
randomForest
randomForest(Species ~ rhs, data = cbind(Y,
X), maxLevel = maxLevel, keep.forest = TRUE, importance = TRUE,
ntree = ntree, keep.group = TRUE, keep.inbag = TRUE,
corr.threshold = corr.threshold, na.action = na.omit)
quote(randomForest(Species ~ rhs, data = cbind(Y,
X), maxLevel = maxLevel, keep.forest = TRUE, importance = TRUE,
ntree = ntree, keep.group = TRUE, keep.inbag = TRUE,
corr.threshold = corr.threshold, na.action = na.omit))
fitcmd <- quote(randomForest(Species ~ rhs, data = cbind(Y,
X), maxLevel = maxLevel, keep.forest = TRUE, importance = TRUE,
ntree = ntree, keep.group = TRUE, keep.inbag = TRUE,
corr.threshold = corr.threshold, na.action = na.omit))
fitcmd
result <- list()
species.pos.rsq <- 0
form.rhs <- as.formula(paste("Y ~ ", paste(predictor.vars,
collapse = "+")))
form.rhs
trace
spcount <- 0
cat("Calculating forests for", length(response.vars),
"species\n")
spec
response.vars
spcount
cat(if ((spcount <- spcount + 1)%%options("width")$width ==
0)
"\n."
else ".")
do.call("substitute", list(fitcmd,
list(Species = as.name(spec), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
do.call("substitute", list(fitcmd,
list(Species = as.name(response.vars[1]), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
do.call("substitute", list(fitcmd,
list(Species = as.name(response.vars[1]), SpeciesName = response.vars[1],
ntree = ntree, rhs = form.rhs[[3]])))
thisfitcmd <- do.call("substitute", list(fitcmd,
list(Species = as.name(response.vars[1]), SpeciesName = response.vars[1],
ntree = ntree, rhs = form.rhs[[3]])))
fit <- eval(thisfitcmd)
fit
fit$type
(fit$type == "regression")
(!is.na(fit$rsq[fit$ntree]))
(fit$rsq[fit$ntree] > 0)
compact
result
getSplitImprove(fit,
X)
??getSplitImprove
getSplitImproveCompact
getSplitImproveCompact(fit,
bins)
getSplitImprove
require(gradientForest)
getSplitImprove
`getSplitImprove` <-function(fit, X) {
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]==-3 & zapsmall(tmp[,"improve"]) > 0,c("split var","split point","improve")]
colnames(tmp) <- c("var_n","split","improve")
rownames(tmp)<-NULL     #S.J. Smith 11/05/2009
res <- cbind(data.frame(var=names(X)[tmp[,"var_n"]],rsq=rep(fit$rsq[fit$ntree],nrow(tmp))),tmp)
ok <- zapsmall(res[,"improve"]) > 0
res[ok,]
}
getSplitImprove(fit,
X)
lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE))
sapply(trees, class)
sapply(trees, class) != "try-error"
do.call("rbind", lapply((1:fit$ntree)[ok], function(k) cbind(tree = k, trees[[k]])))
ok <- sapply(trees, class) != "try-error"
do.call("rbind", lapply((1:fit$ntree)[ok], function(k) cbind(tree = k, trees[[k]])))
1:fit$ntree
do.call("rbind", lapply((1:fit$ntree)[ok], function(k) cbind(tree = k, trees[[k]])))
do.call("rbind", lapply((1:fit$ntree)[ok], function(k) cbind(tree = k, trees[[k]])))
function(k)
do.call("rbind", lapply((1:fit$ntree)[ok], function(k) cbind(tree = k, trees[[k]])))
tmp
res <- cbind(data.frame(var=names(X)[tmp[,"var_n"]],rsq=rep(fit$rsq[fit$ntree],nrow(tmp))),tmp)
ok <- zapsmall(res[,"improve"]) > 0
res[ok,]
ok
[ok,]
?do.call
fit$ntree
1:fit$ntree)[ok]
(1:fit$ntree)[ok]
(1:fit$ntree)
(1:fit$ntree)[ok]
rbind((1:fit$ntree)[ok])
cbind(tree = k, trees[[k]])
data
for (spec in response.vars) {
if (trace)
cat(if ((spcount <- spcount + 1)%%options("width")$width ==
0)
"\n."
else ".")
try({
thisfitcmd <- do.call("substitute", list(fitcmd,
list(Species = as.name(spec), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
fit <- eval(thisfitcmd)
if (fit$type == "regression") {
if (!is.na(fit$rsq[fit$ntree])) {
if (fit$rsq[fit$ntree] > 0) {
species.pos.rsq <- species.pos.rsq + 1
if (compact) {
result[[spec]] <- getSplitImproveCompact(fit,
bins)
}
else {
result[[spec]] <- getSplitImprove(fit,
X)
}
imp <- rbind(imp, fit$importance)
}
}
}
else if (fit$type == "classification") {
if (!is.na(fit$err.rate[fit$ntree, "OOB"])) {
p <- sum(Y[[spec]] == levels(Y[[spec]])[1])/length(Y[[spec]])
err0 <- 2 * p * (1 - p)
if (fit$err.rate[fit$ntree, "OOB"] <
2 * p * (1 - p)) {
species.pos.rsq <- species.pos.rsq + 1
if (compact) {
result[[spec]] <- getSplitImproveClassCompact(fit,
bins, err0)
}
else {
result[[spec]] <- getSplitImproveClass(fit,
X, err0)
}
nclass <- length(levels(Y[[spec]]))
imp <- rbind(imp, fit$importance[, -(1:nclass)])
}
}
}
else stop(paste("unknown randomForest type:",
fit$type))
}, silent = FALSE)
}
(trace)
thisfitcmd <- do.call("substitute", list(fitcmd,
list(Species = as.name(spec), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
thisfitcmd
thisfitcmd
spec
response.vars[1]
spec <- response.vars[1]
spec
# spec <- response.vars[1]
thisfitcmd <- do.call("substitute", list(fitcmd,
list(Species = as.name(spec), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
fit <- eval(thisfitcmd)
fit
fit <- eval(thisfitcmd)
fit
ntree = 100
fit <- eval(thisfitcmd)
fit
thisfitcmd <- do.call("substitute", list(fitcmd,
list(Species = as.name(spec), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
fit <- eval(thisfitcmd)
fit
thisfitcmd <- do.call("substitute", list(fitcmd,
list(Species = as.name(spec), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
fit <- eval(thisfitcmd)
fit
ntree=10
thisfitcmd <- do.call("substitute", list(fitcmd,
list(Species = as.name(spec), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
fit <- eval(thisfitcmd)
fit
(fit$type == "regression")
(!is.na(fit$rsq[fit$ntree]))
(fit$rsq[fit$ntree] > 0)
getSplitImprove(fit,
X)
`getSplitImprove` <-function(fit, X) {
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok], function(k) cbind(tree = k, trees[[k]])))
do.call("rbind", lapply((1:fit$ntree)[ok], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]==-3 & zapsmall(tmp[,"improve"]) > 0,c("split var","split point","improve")]
colnames(tmp) <- c("var_n","split","improve")
rownames(tmp)<-NULL     #S.J. Smith 11/05/2009
res <- cbind(data.frame(var=names(X)[tmp[,"var_n"]],rsq=rep(fit$rsq[fit$ntree],nrow(tmp))),tmp)
ok <- zapsmall(res[,"improve"]) > 0
res[ok,]
}
X
fit
result[[spec]] <- getSplitImprove(fit, X)
results
result
result[[spec]] <- getSplitImprove(fit, X)
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
trees
options(scipen = 0)
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
trees
ok <- sapply(trees, class) != "try-error"
ok
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
ok
class(ok)
?sapply
?class
class2(ok)
.class2(ok)
.class2(ok)[3]
class(trees)
class(trees[1])
class(trees[[1]])
sapply(trees, class) != "try-error"
c(sapply(trees, class)) != "try-error"
sapply(trees, class) != "try-error"
sapply(trees, class)
sapply(trees, .class2) != "try-error"
sapply(trees, .class2)
sapply(trees, .class2)[1] != "try-error"
sapply(trees, class)
ok <- sapply(trees, class) != "try-error"
ok
ncol(trees)
dim(trees)
str(trees)
length(trees)
ok
ok==TRUE
ok[ok==TRUE]
ok[ok==TRUE,]
isTRUE(ok)
isTRUE(ok[1])
unlist(ok)
c(ok)
isTRUE(c(ok))
sum(ok)
sum(ok)==2*length(trees)
.class2(trees[1])
.class2(trees[[1]])
class(trees[[1]])
sapply(trees, class)
"try-error" %in% sapply(trees, class)
?apply
ok <- sapply(trees, class) != "try-error"
str(ok)
ok
apply(ok, 2, isTRUE)
apply(ok, 2, <2)
apply(ok, 2, sum)
nrow(ok)
apply(ok, 2, sum)==nrow(ok)
ok2 <- apply(ok, 2, sum)==nrow(ok)
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok2], function(k) cbind(tree = k, trees[[k]])))
tmp
colnames(tmp) <- c("var_n","split","improve")
tmp <- tmp[tmp[,"status"]==-3 & zapsmall(tmp[,"improve"]) > 0,c("split var","split point","improve")]
colnames(tmp) <- c("var_n","split","improve")
rownames(tmp)<-NULL     #S.J. Smith 11/05/2009
res <- cbind(data.frame(var=names(X)[tmp[,"var_n"]],rsq=rep(fit$rsq[fit$ntree],nrow(tmp))),tmp)
ok <- zapsmall(res[,"improve"]) > 0
res[ok,]
`getSplitImprove` <-function(fit, X) {
#   return a data-frame: var name, rsq, var number, split value, improvement
trees <- lapply(1:fit$ntree, function(k) try(getTree(fit, k),silent=TRUE)) #Nick Ellis 10/12/2009
ok <- sapply(trees, class) != "try-error"
ok2 <- apply(ok, 2, sum)==nrow(ok)
tmp <- do.call("rbind", lapply((1:fit$ntree)[ok2], function(k) cbind(tree = k, trees[[k]])))
tmp <- tmp[tmp[,"status"]==-3 & zapsmall(tmp[,"improve"]) > 0,c("split var","split point","improve")]
colnames(tmp) <- c("var_n","split","improve")
rownames(tmp)<-NULL     #S.J. Smith 11/05/2009
res <- cbind(data.frame(var=names(X)[tmp[,"var_n"]],rsq=rep(fit$rsq[fit$ntree],nrow(tmp))),tmp)
ok <- zapsmall(res[,"improve"]) > 0
res[ok,]
}
result[[spec]] <- getSplitImprove(fit,
X)
##################################
#Here is the problem
##################################
for (spec in response.vars) {
if (trace)
cat(if ((spcount <- spcount + 1)%%options("width")$width ==
0)
"\n."
else ".")
try({
# spec <- response.vars[1]
thisfitcmd <- do.call("substitute", list(fitcmd,
list(Species = as.name(spec), SpeciesName = spec,
ntree = ntree, rhs = form.rhs[[3]])))
fit <- eval(thisfitcmd)
if (fit$type == "regression") {
if (!is.na(fit$rsq[fit$ntree])) {
if (fit$rsq[fit$ntree] > 0) {
species.pos.rsq <- species.pos.rsq + 1
if (compact) {
result[[spec]] <- getSplitImproveCompact(fit,
bins)
}
else {
result[[spec]] <- getSplitImprove(fit,
X)
}
imp <- rbind(imp, fit$importance)
}
}
}
else if (fit$type == "classification") {
if (!is.na(fit$err.rate[fit$ntree, "OOB"])) {
p <- sum(Y[[spec]] == levels(Y[[spec]])[1])/length(Y[[spec]])
err0 <- 2 * p * (1 - p)
if (fit$err.rate[fit$ntree, "OOB"] <
2 * p * (1 - p)) {
species.pos.rsq <- species.pos.rsq + 1
if (compact) {
result[[spec]] <- getSplitImproveClassCompact(fit,
bins, err0)
}
else {
result[[spec]] <- getSplitImproveClass(fit,
X, err0)
}
nclass <- length(levels(Y[[spec]]))
imp <- rbind(imp, fit$importance[, -(1:nclass)])
}
}
}
else stop(paste("unknown randomForest type:",
fit$type))
}, silent = FALSE)
}
rm(list=ls())
gc()
ls()
