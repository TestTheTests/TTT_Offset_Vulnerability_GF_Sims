sum <- AABB+AaBB+aaBB+AABb+AaBb+aaBb+AAbb+Aabb+aabb
# guess initial haplotype frequencies
AB <- 1/4
Ab <- 1/4
aB <- 1/4
ab <- 1/4
# initial probabilities of the genotypes
pAABB <- AB*AB
pAaBB <- 2*AB*aB
paaBB <- aB*aB
pAABb <- 2*AB*Ab
pAaBb <- 2*AB*ab+2*Ab*aB
paaBb <- 2*aB*ab
pAAbb <- Ab*Ab
pAabb <- 2*Ab*ab
paabb <- ab*ab
# vector of the probabilities
x <- c(pAABB,pAaBB,paaBB,pAABb,pAaBb,paaBb,pAAbb,pAabb,paabb)
# iterations for plotting
g <- c(1:10)
plotAB <- list()
plotAb <- list()
plotaB <- list()
plotab <- list()
plotD <- list()
plotlike <- list()
for(i in 1:10){
# estimate the fraction of double heterozygotes in the 'AB/ab' phase
ABphase <- AB*ab/(AB*ab+aB*Ab)
# calculate D
D <- abs(AB*ab-Ab*aB)
# calculate the likelihood of the data
like <- dmultinom(c(AABB,AaBB,aaBB,AABb,AaBb,aaBb,AAbb,Aabb,aabb),prob=x)
# store current iteration results
plotAB[i] <- AB
plotAb[i] <- Ab
plotaB[i] <- aB
plotab[i] <- ab
plotD[i] <- D
plotlike[i] <- like
# show current iteration results
print(paste('AB',AB,'Ab',Ab,'aB',aB,'ab',ab,'AB_phase',ABphase,
'D',D,'like',like))
# update haplotype frequency estimates
AB <- (2*AABB+AABb+AaBB+AaBb*ABphase)/(2*sum)
Ab <- (2*AAbb+AABb++Aabb+AaBb*(1-ABphase))/(2*sum)
aB <- (2*aaBB+aaBb+AaBB+AaBb*(1-ABphase))/(2*sum)
ab <- (2*aabb+aaBb+Aabb+AaBb*ABphase)/(2*sum)
# update genotype frequency estimates
pAABB <- AB*AB
pAaBB <- 2*AB*aB
paaBB <- aB*aB
pAABb <- 2*AB*Ab
pAaBb <- 2*AB*ab+2*Ab*aB
paaBb <- 2*aB*ab
pAAbb <- Ab*Ab
pAabb <- 2*Ab*ab
paabb <- ab*ab
# save genotype frequencies in a vector for the multinomial
x <- c(pAABB,pAaBB,paaBB,pAABb,pAaBb,paaBb,pAAbb,pAabb,paabb)
}
# plot AB frequency
plot(g, plotAB, ylim=c(0,1), type='b', col='blue', lwd=3, xlab="iterations",
ylab="Haplotype frequency or D")
# plot Ab
par(new=TRUE)# save the last plot to overlay
plot(g, plotAb, type="b", lwd=3, ylim=c(0,1), col="red", xlab=" ", ylab=" ")
# plot aB
par(new=TRUE)# save the last plot to overlay
plot(g, plotaB, type="b", lwd=3, ylim=c(0,1), col="green", xlab=" ", ylab=" ")
# plot ab
par(new=TRUE)# save the last plot to overlay
plot(g, plotab, type="b", lwd=3, ylim=c(0,1), col="orange", xlab=" ", ylab=" ")
# plot D
par(new=TRUE)# save the last plot to overlay
plot(g, plotD, ylim=c(0,1), type='b', col='gray', lwd=3, xlab=" ", ylab=" ")
## Legend
legend('topright', bg='white', legend=c('AB','Ab','aB','ab','D'),
col=c('blue','red','green','orange','gray'), lty=1, lwd=3)
}
Dcalc(AABB, AaBB, aaBB, AABb, AaBb, aaBb, AAbb, Aabb, aabb)
install.packages("pegas")
detach("package:ade4", unload = TRUE)
detach("package:adegenet", unload = TRUE)
install.packages("diveRsity")
remotes::install_github("thierrygosselin/radiator")
detach("package:ade4", unload = TRUE)
detach("package:adegenet", unload = TRUE)
memory.limit()
memory.size()
memory.size(T)
require(hierfstat)
install.packages("hierfstat")
require(hierfstat)
load("E:/Research_AJL/TTT_Offset_Vulnerability_GF_Sims/results/R_results/1940819310024.RData")
require(doParallel, lib.loc=library.path)
install.packages("doParallel")
require(doParallel, lib.loc=library.path)
.libPaths()
# Post_geno<-data.frame(PopsALL,Gt2f)
# colnames(Post_geno)[1]<-"Locality"
cores <- 7
cl <- makeCluster(cores)
registerDoParallel(cl)
require(doParallel)
cl <- makeCluster(cores)
registerDoParallel(cl)
start_time <- Sys.time()
Pre_FST<-pairwise.WCfst(Pre_geno,diploid = T)
end_time <- Sys.time()
print(paste("Run time:",end_time - start_time))
stopCluster(cl)
.libPaths()
#library.path <- c("C:/Users/18084/Documents/R/win-library/3.6","E:/R-3.6.2/library")
library.path <- .libPaths()
require(OutFLANK, lib.loc=library.path)
require(vcfR, lib.loc=library.path)
require(adegenet, lib.loc=library.path)
require(gdm, lib.loc=library.path)
require(gradientForest, lib.loc=library.path)
require(foreach, lib.loc=library.path)
require(doParallel, lib.loc=library.path)
require(pbapply, lib.loc=library.path)
require(gdata, lib.loc=library.path)
require(data.table, lib.loc=library.path)
require(PresenceAbsence, lib.loc=library.path)
require(ROCR, lib.loc=library.path)
require(modEvA, lib.loc=library.path)
require(dplyr, lib.loc=library.path)
require(grid, lib.loc=library.path)
require(gridExtra, lib.loc=library.path)
require(gtools, lib.loc=library.path)
require(stringr, lib.loc=library.path)
require(reshape2, lib.loc=library.path)
require(hierfstat)
memory)=
memory()
Memory()
?Memory
memory.limit()
memory.size()
memory.size(T)
memory.size(T)
gc()
memory.size()
?gc
gc(T)
install.packages(c("adegenet", "ape", "asremlPlus", "backports", "bayestestR", "broom", "calibrate", "cubature", "dae", "dbplyr", "deldir", "dplyr", "DT", "effectsize", "ellipsis", "emmeans", "fs", "gganimate", "ggeffects", "glue", "gplots", "haven", "htmltools", "httpuv", "insight", "isoband", "jsonlite", "knitr", "later", "lubridate", "magick", "modelr", "mvtnorm", "nloptr", "openssl", "parameters", "performance", "pillar", "pinfsc50", "pkgbuild", "pkgload", "processx", "promises", "ps", "raster", "Rcpp", "RcppArmadillo", "rlang", "rmarkdown", "roxygen2", "rversions", "scales", "segmented", "sf", "shiny", "sjlabelled", "sjmisc", "sjPlot", "sp", "spData", "spdep", "tibble", "tidyr", "tidyselect", "tinytex", "transformr", "units", "vctrs", "xfun"))
install.packages(c("nlme", "survival"), lib="E:/R-3.6.2/library")
library(hierfstat)
detach("package:hierfstat", unload = TRUE)
install.packages(hierfstat)
install.packages("hierfstat")
library(devtools)
install_github("jgx65/hierfstat")
library(hierfstat)
.libPaths()
library(devtools)
>install_github()
?install_github()
install_github("jgx65/hierfstat")
require(hierfstat)
install.packages("hierfstat")
require(hierfstat)
library(hierfstat)
.libPaths()
#library.path <- c("C:/Users/18084/Documents/R/win-library/3.6","E:/R-3.6.2/library")
library.path <- .libPaths()
require(OutFLANK, lib.loc=library.path)
require(vcfR, lib.loc=library.path)
require(adegenet, lib.loc=library.path)
require(gdm, lib.loc=library.path)
require(gradientForest, lib.loc=library.path)
require(foreach, lib.loc=library.path)
require(doParallel, lib.loc=library.path)
require(pbapply, lib.loc=library.path)
require(gdata, lib.loc=library.path)
require(data.table, lib.loc=library.path)
require(PresenceAbsence, lib.loc=library.path)
require(ROCR, lib.loc=library.path)
require(modEvA, lib.loc=library.path)
require(dplyr, lib.loc=library.path)
require(grid, lib.loc=library.path)
require(gridExtra, lib.loc=library.path)
require(gtools, lib.loc=library.path)
require(stringr, lib.loc=library.path)
require(reshape2, lib.loc=library.path)
require(hierfstat)
install.packages(c("data.table", "gdm", "gridExtra", "modEvA", "pbapply", "PresenceAbsence", "ROCR"))
require(OutFLANK, lib.loc=library.path)
require(vcfR, lib.loc=library.path)
require(adegenet, lib.loc=library.path)
require(gdm, lib.loc=library.path)
require(gradientForest, lib.loc=library.path)
require(foreach, lib.loc=library.path)
require(doParallel, lib.loc=library.path)
require(pbapply, lib.loc=library.path)
require(gdata, lib.loc=library.path)
require(data.table, lib.loc=library.path)
require(PresenceAbsence, lib.loc=library.path)
require(ROCR, lib.loc=library.path)
require(modEvA, lib.loc=library.path)
require(dplyr, lib.loc=library.path)
require(grid, lib.loc=library.path)
require(gridExtra, lib.loc=library.path)
require(gtools, lib.loc=library.path)
require(stringr, lib.loc=library.path)
require(reshape2, lib.loc=library.path)
require(hierfstat)
require(OutFLANK, lib.loc=library.path)
require(vcfR, lib.loc=library.path)
require(adegenet, lib.loc=library.path)
require(gdm, lib.loc=library.path)
require(gradientForest, lib.loc=library.path)
require(foreach, lib.loc=library.path)
require(doParallel, lib.loc=library.path)
require(pbapply, lib.loc=library.path)
require(gdata, lib.loc=library.path)
require(data.table, lib.loc=library.path)
require(PresenceAbsence, lib.loc=library.path)
require(ROCR, lib.loc=library.path)
require(modEvA, lib.loc=library.path)
require(dplyr, lib.loc=library.path)
require(grid, lib.loc=library.path)
require(gridExtra, lib.loc=library.path)
require(gtools, lib.loc=library.path)
require(stringr, lib.loc=library.path)
require(reshape2, lib.loc=library.path)
require(hierfstat)
install.packages(c("cowplot", "qqman"))
install.packages(c("data.table", "gdm", "gridExtra", "modEvA", "pbapply", "PresenceAbsence", "ROCR"))
library(devtools)
install_github("jgx65/hierfstat")
install.packages("devtools")
library(devtools)
install_github("jgx65/hierfstat")
detach("package:hierfstat", unload = TRUE)
library(devtools)
install_github("jgx65/hierfstat")
require(hierfstat)
remove.packages("hierfstat")
install.packages("hierfstat")
require(hierfstat)
library(hierfstat)
remove.packages("hierfstat")
library.path <- .libPaths()
require(OutFLANK, lib.loc=library.path)
require(vcfR, lib.loc=library.path)
require(adegenet, lib.loc=library.path)
require(gdm, lib.loc=library.path)
require(gradientForest, lib.loc=library.path)
require(foreach, lib.loc=library.path)
require(doParallel, lib.loc=library.path)
require(pbapply, lib.loc=library.path)
require(gdata, lib.loc=library.path)
require(data.table, lib.loc=library.path)
require(PresenceAbsence, lib.loc=library.path)
require(ROCR, lib.loc=library.path)
require(modEvA, lib.loc=library.path)
require(dplyr, lib.loc=library.path)
require(grid, lib.loc=library.path)
require(gridExtra, lib.loc=library.path)
require(gtools, lib.loc=library.path)
require(stringr, lib.loc=library.path)
require(reshape2, lib.loc=library.path)
require(hierfstat)
install.packages("devtools")
library(STICH)
library(STITCH)
install.packages("Rcpp")
install.packages("seqinr", dependencies = T)
require(data.table)
require(tidyverse)
require(cowplot)
require(Rsamtools)
setwd("E:/Research_AJL/Cornell")
genomecov <- fread("NovaSeq/ShadHap1_L002_genomcecov.out")
colnames(genomecov)<-c("Contig","Coverage","Bases","Total","Fraction")
contigcov <- genomecov[genomecov$Contig!="genome",]
contigcov$CovTot <- contigcov$Coverage * contigcov$Bases
f <- aggregate(contigcov$CovTot, by=list(contigcov$Contig), FUN=sum)
colnames(f)<-c("Contig","Sum of coverage")
x<-contigcov[!duplicated(contigcov$Contig), ]
f$Total <- x$Total
f$CovPerBase <- f$`Sum of coverage`/f$Total
f$CovPerInd <- f$CovPerBase/95
summary(f$CovPerInd)
summary(f$CovPerInd)
fe<-f$CovPerInd[order(f$CovPerInd)]
#barplot(f$CovPerBase[order(f$CovPerBase)], space=5, xlab = "Contig", ylab="Per base coverage per contig")# , names.arg = d$Chromosome, las=2)
barplot(fe, space=5, xlab = "Contig", ylab="Coverage per contig per individual")# , names.arg = d$Chromosome, las=2)
barplot(log10(fe[fe>0]), space=5, xlab = "Contig", ylab="Log10 coverage per contig per individual")# , names.arg = d$Chromosome, las=2)
abline(h=log10(g$CovPerInd),col="red")
gencov <- genomecov[genomecov$Contig=="genome",]
gencov$CovTot <- as.numeric(gencov$Coverage) * as.numeric(gencov$Bases)
g <- aggregate(gencov$CovTot, by=list(gencov$Contig), FUN=sum)
colnames(g)<-c("Contig","Sum of coverage")
g$Total <- gencov$Total[1]
g$CovPerBase <- g$`Sum of coverage`/g$Total
g$CovPerInd <- g$CovPerBase/95
summary(g$CovPerInd)
summary(d[d$Chromosome=="genome",])
summary(d[d$`Mean read depth`!=0,])
d$`Coverage per individual` <- d$`Mean read depth`/95
d<-d[order(d$`Coverage per individual`),]
plot(d$`Coverage per individual`, type="l", xlab="Contig", ylab="Coverage per individual")
points(d$`Coverage per individual`[d$`Coverage per individual`<10],col="blue")
abline(h=10, col="red")
clearBC <- fread("NovaSeq/ShadHap1_L002_clearBC.log")
nrow(clearBC)
sum(clearBC$`Correct reads`,clearBC$`Corrected reads`)
unclearBC <- fread("NovaSeq/ShadHap1_L002_unclearBC.log")
nrow(unclearBC)
nrow(clearBC)+nrow(unclearBC)
c_counts <- read.table("NovaSeq/ShadHap1_per.C-barcoded.counts")
colnames(c_counts) <- c("barcode", "correct", "corrected")
#View(c_counts)
nrow(c_counts)
sum(c_counts$correct,c_counts$corrected)
target <- c()
for (i in 01:96) {
target <-  c(target,paste("C", i, sep = ""))
}
total_assigned <- sum(c_counts[c_counts$barcode %in% target,"correct"]) + sum(c_counts[c_counts$barcode %in% target,"corrected"])
total_assigned <- sum(c_counts$correct,c_counts$corrected)
read_count <- 830765001 #from wc -l ShadHap1_L002_S1_I2_001_reads.txt
# 830765001 from wc -l ShadHap1_L002_S1_I1_001_reads.txt
# 830765001 from wc -l ShadHap1_L002_S1_R1_001_reads.txt
# 830765001 from wc -l ShadHap1_L002_S1_R2_001_reads.txt
prop_assigned <- total_assigned / read_count
prop_assigned*100
c_counts_total <-rowSums(cbind(c_counts$correct,c_counts$corrected))
names(c_counts_total) <- c_counts$barcode
c_counts_total <- c_counts_total[order(c_counts_total)]
end_point = 0.5 + length(c_counts_total) + length(c_counts_total) - 1
barplot(c_counts_total, xaxt="n", horiz = F, space= 1)
text(seq(1.5, end_point, by = 2), par("usr")[3]-0.25,
srt = 60, adj = 1, xpd = TRUE,
labels = paste(names(c_counts_total)), cex = 1)
summary(c_counts_total[-1])
c_counts <- read.table("NovaSeq/ShadHap1_per.C-barcoded.counts")
colnames(c_counts) <- c("barcode", "correct", "corrected")
#View(c_counts)
# nrow(c_counts)
# sum(c_counts$correct,c_counts$corrected)
#
# target <- c()
#
# for (i in 01:96) {
#   target <-  c(target,paste("C", i, sep = ""))
# }
#
# total_assigned <- sum(c_counts[c_counts$barcode %in% target,"correct"]) + sum(c_counts[c_counts$barcode %in% target,"corrected"])
#
# total_assigned <- sum(c_counts$correct,c_counts$corrected)
#
# read_count <- 830765001 #from wc -l ShadHap1_L002_S1_I2_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_I1_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_R1_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_R2_001_reads.txt
#
# prop_assigned <- total_assigned / read_count
# prop_assigned*100
c_counts_total <-rowSums(cbind(c_counts$correct,c_counts$corrected))
names(c_counts_total) <- c_counts$barcode
c_counts_total <- c_counts_total[order(c_counts_total)]
end_point = 0.5 + length(c_counts_total) + length(c_counts_total) - 1
barplot(c_counts_total, xaxt="n", horiz = F, space= 1)
text(seq(1.5, end_point, by = 2), par("usr")[3]-0.25,
srt = 60, adj = 1, xpd = TRUE,
labels = paste(names(c_counts_total)), cex = 1)
summary(c_counts_total[-1])
c_counts <- read.table("NovaSeq/ShadHap2_cat_C-barcoded_counts.out")
colnames(c_counts) <- c("barcode", "correct", "corrected")
#View(c_counts)
# nrow(c_counts)
# sum(c_counts$correct,c_counts$corrected)
#
# target <- c()
#
# for (i in 01:96) {
#   target <-  c(target,paste("C", i, sep = ""))
# }
#
# total_assigned <- sum(c_counts[c_counts$barcode %in% target,"correct"]) + sum(c_counts[c_counts$barcode %in% target,"corrected"])
#
# total_assigned <- sum(c_counts$correct,c_counts$corrected)
#
# read_count <- 830765001 #from wc -l ShadHap1_L002_S1_I2_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_I1_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_R1_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_R2_001_reads.txt
#
# prop_assigned <- total_assigned / read_count
# prop_assigned*100
c_counts_total <-rowSums(cbind(c_counts$correct,c_counts$corrected))
names(c_counts_total) <- c_counts$barcode
c_counts_total <- c_counts_total[order(c_counts_total)]
end_point = 0.5 + length(c_counts_total) + length(c_counts_total) - 1
barplot(c_counts_total, xaxt="n", horiz = F, space= 1)
text(seq(1.5, end_point, by = 2), par("usr")[3]-0.25,
srt = 60, adj = 1, xpd = TRUE,
labels = paste(names(c_counts_total)), cex = 1)
summary(c_counts_total[-1])
c_counts <- read.table("NovaSeq/ShadHap3_L001_C-barcoded_counts.out")
colnames(c_counts) <- c("barcode", "correct", "corrected")
#View(c_counts)
# nrow(c_counts)
# sum(c_counts$correct,c_counts$corrected)
#
# target <- c()
#
# for (i in 01:96) {
#   target <-  c(target,paste("C", i, sep = ""))
# }
#
# total_assigned <- sum(c_counts[c_counts$barcode %in% target,"correct"]) + sum(c_counts[c_counts$barcode %in% target,"corrected"])
#
# total_assigned <- sum(c_counts$correct,c_counts$corrected)
#
# read_count <- 830765001 #from wc -l ShadHap1_L002_S1_I2_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_I1_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_R1_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_R2_001_reads.txt
#
# prop_assigned <- total_assigned / read_count
# prop_assigned*100
c_counts_total <-rowSums(cbind(c_counts$correct,c_counts$corrected))
names(c_counts_total) <- c_counts$barcode
c_counts_total <- c_counts_total[order(c_counts_total)]
end_point = 0.5 + length(c_counts_total) + length(c_counts_total) - 1
barplot(c_counts_total, xaxt="n", horiz = F, space= 1)
text(seq(1.5, end_point, by = 2), par("usr")[3]-0.25,
srt = 60, adj = 1, xpd = TRUE,
labels = paste(names(c_counts_total)), cex = 1)
summary(c_counts_total[-1])
c_counts <- read.table("NovaSeq/ShadHap4_L002_C-barcoded_counts.out")
colnames(c_counts) <- c("barcode", "correct", "corrected")
#View(c_counts)
# nrow(c_counts)
# sum(c_counts$correct,c_counts$corrected)
#
# target <- c()
#
# for (i in 01:96) {
#   target <-  c(target,paste("C", i, sep = ""))
# }
#
# total_assigned <- sum(c_counts[c_counts$barcode %in% target,"correct"]) + sum(c_counts[c_counts$barcode %in% target,"corrected"])
#
# total_assigned <- sum(c_counts$correct,c_counts$corrected)
#
# read_count <- 830765001 #from wc -l ShadHap1_L002_S1_I2_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_I1_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_R1_001_reads.txt
# # 830765001 from wc -l ShadHap1_L002_S1_R2_001_reads.txt
#
# prop_assigned <- total_assigned / read_count
# prop_assigned*100
c_counts_total <-rowSums(cbind(c_counts$correct,c_counts$corrected))
names(c_counts_total) <- c_counts$barcode
c_counts_total <- c_counts_total[order(c_counts_total)]
end_point = 0.5 + length(c_counts_total) + length(c_counts_total) - 1
barplot(c_counts_total, xaxt="n", horiz = F, space= 1)
text(seq(1.5, end_point, by = 2), par("usr")[3]-0.25,
srt = 60, adj = 1, xpd = TRUE,
labels = paste(names(c_counts_total)), cex = 1)
summary(c_counts_total[-1])
require(OutFLANK)
require(vcfR)
require(adegenet)
require(gdm)
require(gradientForest)
require(foreach)
require(doParallel)
require(pbapply)
require(gdata)
require(data.table)
require(PresenceAbsence)
require(ROCR)
require(modEvA)
require(dplyr)
require(grid)
require(gridExtra)
require(gtools)
require(stringr)
require(reshape2)
require(hierfstat)
require(clusterGeneration)
options(scipen = 999)
#Visualizing multilocus data
require(ggplot2)
require(cowplot)
require(qqman)
require(RColorBrewer)
require(colorspace)
require(dplyr)
require(reshape2)
setwd("E:/Research_AJL/TTT_Offset_Vulnerability_GF_Sims/")
colfunc<-colorRampPalette(c("orange","cyan"))
colour1 = rep(colfunc(10),10)
colour1_transparent <- adjustcolor(colour1, alpha.f = 0.3)
par(mfrow=c(2,1))
par(mar = c(1,4,4,0))
plot(fit$Gen,fit$P19_phen1,type="l", main=plotTitle, xlab="",xaxt="n", ylab="Phenotype 1",col="white",ylim=c(-1,1))
k=1
for(i in which(fitt$Type=="Phen1")){
lines(fit$Gen,fit[,i+13],lwd=2,col=colour1[k])
#lines(fit$Gen,fit[,i+14],lwd=2,col=colour1[k])
k=k+1
}
load("E:/Research_AJL/TTT_Offset_Vulnerability_GF_Sims/results/R_results/1442299973452.RData")
