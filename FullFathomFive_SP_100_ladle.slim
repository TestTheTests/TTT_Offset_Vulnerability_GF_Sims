initialize() {
//setSeed(1707249891095);
defineConstant("my_seed", getSeed()); 
defineConstant("s", 0.1); // Selection coefficient for local fitness gradient
defineConstant("d", seq(0,9,1)); // Set of environmental "demes" 
defineConstant("m", 0.05); // Set universal migration rate between populations
defineConstant("n", 100); // Set universal deme population size

//defineConstant("Burnin", 4500);
//defineConstant("Sim_Len", 5000);

initializeMutationRate(1e-7);

initializeMutationType("m1", 0.5, "f", 0.0); // Neutral
initializeMutationType("m2", 0.5, "f", 0.0); // Mutation under selection across an environmental gradient, initially neutral

initializeGenomicElementType("g1", m1, 1); // Genomic element 
//initializeGenomicElementType("g1", m2, 0);

for (index in 0:9)
initializeGenomicElement(g1, index*50000, index*50000 + 49999); // Generate ten exclusively neutral genomic regions, each with 50,000 nucleotides
//initializeGenomicElement(g2, 50000, 10099); // Generate a single potentially adaptable genomic region, containing 100 nucleotides, on a 10.1 kb chromosome

initializeRecombinationRate(1e-8); // Single recombination rate for entire genome

initializeSex("A"); //Set each population to contain two autosomal sexes that must reproduce to yield next generation

//initializeTreeSeq();
//simplificationRatio=INF);
}

//5 by 5 matrix of populations
2 {
metapopSide = 10; // Number of subpops along one side of the grid, in this case 5
metapopSize = metapopSide * metapopSide; // Create a full 10 by 10 matrix 
for (i in 1:metapopSize)
sim.addSubpop(i, n);
subpops = sim.subpopulations;
for (x in 1:metapopSide)
for (y in 1:metapopSide)
{
destID = (x - 1) + (y - 1) * metapopSide + 1;
destSubpop = subpops[destID - 1];
if (x > 1) // Left to right
destSubpop.setMigrationRates(destID - 1, m);
if (x < metapopSide) // Right to left
destSubpop.setMigrationRates(destID + 1, m);
if (y > 1) // Top to bottom
destSubpop.setMigrationRates(destID - metapopSide, m);
if (y < metapopSide) // Bottom to top
destSubpop.setMigrationRates(destID + metapopSide, m);
}

//sim.rescheduleScriptBlock(s1, Burnin);
//sim.rescheduleScriptBlock(s2, Burnin, Sim_Len);
//sim.rescheduleScriptBlock(s3, Sim_Len);
}

1 late() {
sim.outputFull("slim_temp_" + my_seed + ".txt");
}

4500 late() {
target = sample(p19.genomes, 1);
target.addNewMutation(m2, 0.0, 249999);
//p9.genomes.addNewMutation(m2, 0.0, 249999);
}

//Set fitness for each population based on 10x10 grid. Fitness based on x*(s/4.5)+(1-s), where s=0.1 and d=seq(0,9,1)

fitness(m2,p1) {return d[0]*(s/4.5)+(1-s);}
fitness(m2,p11) {return d[0]*(s/4.5)+(1-s);}
fitness(m2,p21) {return d[0]*(s/4.5)+(1-s);}
fitness(m2,p31) {return d[0]*(s/4.5)+(1-s);}
fitness(m2,p41) {return d[0]*(s/4.5)+(1-s);}
fitness(m2,p51) {return d[0]*(s/4.5)+(1-s);}
fitness(m2,p61) {return d[0]*(s/4.5)+(1-s);}
fitness(m2,p71) {return d[0]*(s/4.5)+(1-s);}
fitness(m2,p81) {return d[0]*(s/4.5)+(1-s);}
fitness(m2,p91) {return d[0]*(s/4.5)+(1-s);}

fitness(m2,p2) {return d[1]*(s/4.5)+(1-s);}
fitness(m2,p12) {return d[1]*(s/4.5)+(1-s);}
fitness(m2,p22) {return d[1]*(s/4.5)+(1-s);}
fitness(m2,p32) {return d[1]*(s/4.5)+(1-s);}
fitness(m2,p42) {return d[1]*(s/4.5)+(1-s);}
fitness(m2,p52) {return d[1]*(s/4.5)+(1-s);}
fitness(m2,p62) {return d[1]*(s/4.5)+(1-s);}
fitness(m2,p72) {return d[1]*(s/4.5)+(1-s);}
fitness(m2,p82) {return d[1]*(s/4.5)+(1-s);}
fitness(m2,p92) {return d[1]*(s/4.5)+(1-s);}

fitness(m2,p3) {return d[2]*(s/4.5)+(1-s);}
fitness(m2,p13) {return d[2]*(s/4.5)+(1-s);}
fitness(m2,p23) {return d[2]*(s/4.5)+(1-s);}
fitness(m2,p33) {return d[2]*(s/4.5)+(1-s);}
fitness(m2,p43) {return d[2]*(s/4.5)+(1-s);}
fitness(m2,p53) {return d[2]*(s/4.5)+(1-s);}
fitness(m2,p63) {return d[2]*(s/4.5)+(1-s);}
fitness(m2,p73) {return d[2]*(s/4.5)+(1-s);}
fitness(m2,p83) {return d[2]*(s/4.5)+(1-s);}
fitness(m2,p93) {return d[2]*(s/4.5)+(1-s);}

fitness(m2,p4) {return d[3]*(s/4.5)+(1-s);}
fitness(m2,p14) {return d[3]*(s/4.5)+(1-s);}
fitness(m2,p24) {return d[3]*(s/4.5)+(1-s);}
fitness(m2,p34) {return d[3]*(s/4.5)+(1-s);}
fitness(m2,p44) {return d[3]*(s/4.5)+(1-s);}
fitness(m2,p54) {return d[3]*(s/4.5)+(1-s);}
fitness(m2,p64) {return d[3]*(s/4.5)+(1-s);}
fitness(m2,p74) {return d[3]*(s/4.5)+(1-s);}
fitness(m2,p84) {return d[3]*(s/4.5)+(1-s);}
fitness(m2,p94) {return d[3]*(s/4.5)+(1-s);}

fitness(m2,p5) {return d[4]*(s/4.5)+(1-s);}
fitness(m2,p15) {return d[4]*(s/4.5)+(1-s);}
fitness(m2,p25) {return d[4]*(s/4.5)+(1-s);}
fitness(m2,p35) {return d[4]*(s/4.5)+(1-s);}
fitness(m2,p45) {return d[4]*(s/4.5)+(1-s);}
fitness(m2,p55) {return d[4]*(s/4.5)+(1-s);}
fitness(m2,p65) {return d[4]*(s/4.5)+(1-s);}
fitness(m2,p75) {return d[4]*(s/4.5)+(1-s);}
fitness(m2,p85) {return d[4]*(s/4.5)+(1-s);}
fitness(m2,p95) {return d[4]*(s/4.5)+(1-s);}

fitness(m2,p6) {return d[5]*(s/4.5)+(1-s);}
fitness(m2,p16) {return d[5]*(s/4.5)+(1-s);}
fitness(m2,p26) {return d[5]*(s/4.5)+(1-s);}
fitness(m2,p36) {return d[5]*(s/4.5)+(1-s);}
fitness(m2,p46) {return d[5]*(s/4.5)+(1-s);}
fitness(m2,p56) {return d[5]*(s/4.5)+(1-s);}
fitness(m2,p66) {return d[5]*(s/4.5)+(1-s);}
fitness(m2,p76) {return d[5]*(s/4.5)+(1-s);}
fitness(m2,p86) {return d[5]*(s/4.5)+(1-s);}
fitness(m2,p96) {return d[5]*(s/4.5)+(1-s);}

fitness(m2,p7) {return d[6]*(s/4.5)+(1-s);}
fitness(m2,p17) {return d[6]*(s/4.5)+(1-s);}
fitness(m2,p27) {return d[6]*(s/4.5)+(1-s);}
fitness(m2,p37) {return d[6]*(s/4.5)+(1-s);}
fitness(m2,p47) {return d[6]*(s/4.5)+(1-s);}
fitness(m2,p57) {return d[6]*(s/4.5)+(1-s);}
fitness(m2,p67) {return d[6]*(s/4.5)+(1-s);}
fitness(m2,p77) {return d[6]*(s/4.5)+(1-s);}
fitness(m2,p87) {return d[6]*(s/4.5)+(1-s);}
fitness(m2,p97) {return d[6]*(s/4.5)+(1-s);}

fitness(m2,p8) {return d[7]*(s/4.5)+(1-s);}
fitness(m2,p18) {return d[7]*(s/4.5)+(1-s);}
fitness(m2,p28) {return d[7]*(s/4.5)+(1-s);}
fitness(m2,p38) {return d[7]*(s/4.5)+(1-s);}
fitness(m2,p48) {return d[7]*(s/4.5)+(1-s);}
fitness(m2,p58) {return d[7]*(s/4.5)+(1-s);}
fitness(m2,p68) {return d[7]*(s/4.5)+(1-s);}
fitness(m2,p78) {return d[7]*(s/4.5)+(1-s);}
fitness(m2,p88) {return d[7]*(s/4.5)+(1-s);}
fitness(m2,p98) {return d[7]*(s/4.5)+(1-s);}

fitness(m2,p9) {return d[8]*(s/4.5)+(1-s);}
fitness(m2,p19) {return d[8]*(s/4.5)+(1-s);}
fitness(m2,p29) {return d[8]*(s/4.5)+(1-s);}
fitness(m2,p39) {return d[8]*(s/4.5)+(1-s);}
fitness(m2,p49) {return d[8]*(s/4.5)+(1-s);}
fitness(m2,p59) {return d[8]*(s/4.5)+(1-s);}
fitness(m2,p69) {return d[8]*(s/4.5)+(1-s);}
fitness(m2,p79) {return d[8]*(s/4.5)+(1-s);}
fitness(m2,p89) {return d[8]*(s/4.5)+(1-s);}
fitness(m2,p99) {return d[8]*(s/4.5)+(1-s);}

fitness(m2,p10) {return d[9]*(s/4.5)+(1-s);}
fitness(m2,p20) {return d[9]*(s/4.5)+(1-s);}
fitness(m2,p30) {return d[9]*(s/4.5)+(1-s);}
fitness(m2,p40) {return d[9]*(s/4.5)+(1-s);}
fitness(m2,p50) {return d[9]*(s/4.5)+(1-s);}
fitness(m2,p60) {return d[9]*(s/4.5)+(1-s);}
fitness(m2,p70) {return d[9]*(s/4.5)+(1-s);}
fitness(m2,p80) {return d[9]*(s/4.5)+(1-s);}
fitness(m2,p90) {return d[9]*(s/4.5)+(1-s);}
fitness(m2,p100) {return d[9]*(s/4.5)+(1-s);}


4500:5000 late() {
if (size(sim.subpopulations.genomes.mutationsOfType(m2)) == 0)
{
// Stop at extinction
catn("Extinction in generation " + sim.generation + ".");
//sim.simulationFinished();
sim.readFromPopulationFile("slim_temp_" + my_seed  + ".txt");
setSeed(getSeed() + 1);
}
}

2:5000 early(){	
	//inds = sim.subpopulations.individuals;
	pops = sim.subpopulations;
	if (sim.generation % 10 == 0){ 
		// get positions of all m2 mutations and store in Q
		//g = sim.subpopulations.genomes;
		// get the unique mutations in the sample, sorted by position		
		//o = sortBy(unique(g.mutationsOfType(m2)), "position"); 
		mut = sim.mutationsOfType(m2);

		fit=c();
		for (i in pops){
  			fit = c(fit,mean(i.cachedFitness(NULL)));
  		}
  		
  		freq=c();
  		for (i in 0:(size(sim.subpopulations)-1)){
  			freq = c(freq,size(sim.subpopulations[i].genomes.mutationsOfType(m2))/size(sim.subpopulations[i].genomes));
  		}
				
		out = paste(c(sim.generation, fit, freq));
		writeFile(paste(c("Fit_output_SP_100_", getSeed(), ".txt"), sep=""), out, append=T);
		}	
}

5000 late(){	

muts = sample(sim.subpopulations.genomes.mutationsOfType(m1),1000);

nfreq=c();

//nfreq=matrix(0.:(size(muts)*size(sim.subpopulations)-1),ncol=size(muts));
//,nrow=size(sim.subpopulations)

for (i in 0:(size(sim.subpopulations)-1)){
nfreq=c();
  		for (j in 0:(size(muts)-1)){
  		if (size(sim.subpopulations[i].genomes.mutationsOfType(m1)[which(sim.subpopulations[i].genomes.mutationsOfType(m1)==muts[j])])>=1)
  		nfreq = c(nfreq,size(sim.subpopulations[i].genomes.mutationsOfType(m1)[which(sim.subpopulations[i].genomes.mutationsOfType(m1)==muts[j])])/size(sim.subpopulations[i].genomes));
  		else
  		nfreq = c(nfreq,0.);
  	}
  	//print(paste(nfreq));
  	writeFile(paste(c("Freq_output_SP_100_", getSeed(), ".txt"), sep=""), paste(nfreq), append=T);	
}
}



5000 late() {sim.outputFixedMutations();}
